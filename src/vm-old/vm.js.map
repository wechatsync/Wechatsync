{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./src/constant.ts","webpack:///./src/type.ts","webpack:///./src/error.ts","webpack:///./src/context.ts","webpack:///./src/standard/es5.ts","webpack:///./node_modules/_lodash.isfunction@3.0.9@lodash.isfunction/index.js","webpack:///./src/runtime.ts","webpack:///./src/signal.ts","webpack:///./src/packages/babel-types/index.ts","webpack:///./src/utils.ts","webpack:///./src/vm.ts","webpack:///./node_modules/_babylon@6.18.0@babylon/lib/index.js","webpack:///./src/evaluate.ts","webpack:///external \"babel-types\"","webpack:///./src/Prototype.ts","webpack:///./src/This.ts","webpack:///./src/standard/es2015.ts","webpack:///./src/standard/es2016.ts","webpack:///./src/standard/es2017.ts","webpack:///./src/standard/experimental.ts","webpack:///./src/path.ts","webpack:///./src/scope.ts","webpack:///./src/var.ts","webpack:///./src/stack.ts"],"names":["root","factory","exports","module","require","define","amd","a","i","global","__WEBPACK_EXTERNAL_MODULE__13__","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","THIS","MODULE","EXPORTS","REQUIRE","UNDEFINED","ARGUMENTS","NEW","ANONYMOUS","ScopeType","isolatedScopeMap","Function","Constructor","Method","Kind","presetMap","ErrIsNot","type","TypeError","varName","ReferenceError","SyntaxError","target","DEFAULT_CONTEXT","Array","Boolean","clearInterval","clearTimeout","console","Date","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","Error","escape","eval","EvalError","Infinity","isFinite","isNaN","JSON","Math","NaN","Number","parseFloat","parseInt","RangeError","RegExp","setInterval","setTimeout","String","unescape","URIError","Promise","Proxy","Reflect","Set","WeakSet","Map","WeakMap","ArrayBuffer","SharedArrayBuffer","DataView","Atomics","Float32Array","Float64Array","Int16Array","Int32Array","Int8Array","Intl","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray","WebAssembly","externalContext","ctx","attr","this","Context","overriteStack","err","stack","node","push","filename","currentStackName","location","loc","toString","raw","BinaryExpressionOperatorEvaluateMap","b","in","instanceof","AssignmentExpressionEvaluateMap","$var","v","set","pow","es5","File","path","evaluate","createChild","program","Program","scope","body","isFunctionDeclaration","isVariableDeclaration","declarations","declaration","kind","Var","var","id","undefined","Identifier","hasBinding","ErrNotDefined","RegExpLiteral","pattern","flags","StringLiteral","NumericLiteral","BooleanLiteral","NullLiteral","IfStatement","ifScope","If","invasive","isolated","test","consequent","alternate","EmptyStatement","BlockStatement","tempResult","blockScope","Block","block","parent","result","Signal","DebuggerStatement","LabeledStatement","label","labelName","BreakStatement","ContinueStatement","ReturnStatement","argument","VariableDeclaration","varKeyValueMap","isIdentifier","init","isObjectPattern","vars","properties","isObjectProperty","alias","obj","isArrayPattern","iterator","ErrInvalidIterable","elements","forEach","$varName","typeAnnotation","el","declare","VariableDeclarator","isObjectExpression","varValue","newScope","propertyName","FunctionDeclaration","func","async","__awaiter","__this","__generator","handler","_a","fieldContext","next","sent","isReturn","generator","FunctionExpression","defineFunctionLength","params","length","defineFunctionName","functionName","ExpressionStatement","expression","ForStatement","forScope","For","update","loopScope","fork","ForChild","signal","isBreak","isContinue","ForInStatement","left","right","forInScope","ForIn","DoWhileStatement","doWhileScope","DoWhile","WhileStatement","whileScope","While","ThrowStatement","CatchClause","TryStatement","tryScope","Try","param","catchScope","Catch","const","finalizer","finallyScope","Finally","SwitchStatement","discriminant","switchScope","Switch","matched","cases","$case","SwitchCase","stmt","UpdateExpression","prefix","$$var","isMemberExpression","computed","Const","operator","ThisExpression","hasOwnBinding","ErrNoSuper","thisVar","ArrayExpression","newArray","item","isSpreadElement","arr","concat","_toConsumableArray","ObjectExpression","computedProperties","tempProperty","ObjectProperty","val","ObjectMethod","methodName","method","enter","args","slice","arguments","leave","definer","shouldReturnInstance","This","pop","funcScope","let","isAssignmentPattern","isRestElement","__proto__","constructor","BinaryExpression","UnaryExpression","void","typeof","delete","$this","CallExpression","callee","isStringLiteral","map","arg","isValidFunction","isFunction","context","ErrIsNotFunction","apply","MemberExpression","ErrCanNotReadProperty","types","Prototype","AssignmentExpression","rightValue","varOrNot","globalScope","globalVar","LogicalExpression","ConditionalExpression","NewExpression","entity","SequenceExpression","expressions","freeGlobal","freeSelf","self","objectProto","nativeObjectToString","symToStringTag","baseGetTag","isOwn","tag","unmasked","e","getRawTag","objectToString","isObject","instance","_createClass","defineProperties","props","descriptor","configurable","writable","protoProps","staticProps","subClass","superClass","setPrototypeOf","_extends","assign","source","isArray","arr2","from","fn","gen","resolve","reject","step","info","error","done","then","thisArg","f","y","g","_","trys","ops","verb","throw","return","op","strings","freeze","_arguments","P","fulfilled","rejected","is","runInContext","code","preset","env","Scope","Root","level","setContext","$exports","$module","ast","parse","sourceType","plugins","Path","Stack","moduleVar","createContext","sandbox","makePredicate","words","split","str","indexOf","reservedWords","6","strict","strictBind","isKeyword","nonASCIIidentifierStartChars","nonASCIIidentifierChars","nonASCIIidentifierStart","nonASCIIidentifier","astralIdentifierStartCodes","astralIdentifierCodes","isInAstralSet","pos","isIdentifierStart","fromCharCode","isIdentifierChar","defaultOptions","sourceFilename","startLine","allowReturnOutsideFunction","allowImportExportEverywhere","allowSuperOutsideMethod","strictMode","_typeof","classCallCheck","inherits","possibleConstructorReturn","TokenType","conf","keyword","beforeExpr","startsExpr","rightAssociative","isLoop","isAssign","postfix","binop","updateContext","KeywordTokenType","_TokenType","options","BinopTokenType","_TokenType2","prec","num","regexp","string","eof","bracketL","bracketR","braceL","braceBarL","braceR","braceBarR","parenL","parenR","comma","semi","colon","doubleColon","dot","question","arrow","template","ellipsis","backQuote","dollarBraceL","at","eq","incDec","logicalOR","logicalAND","bitwiseOR","bitwiseXOR","bitwiseAND","equality","relational","bitShift","plusMin","modulo","star","slash","exponent","keywords","keys","lineBreak","lineBreakG","isNewLine","nonASCIIwhitespace","TokContext","token","isExpr","preserveSpace","override","types$1","braceStatement","braceExpression","templateQuasi","parenStatement","parenExpression","readTmplToken","functionExpression","state","out","curContext","exprAllowed","prevType","_let","_const","_var","input","end","braceIsBlock","statementParens","_if","_for","_with","_while","_function","Position","line","col","column","SourceLocation","start","State","potentialArrowAt","inMethod","inFunction","inGenerator","inAsync","inPropertyName","inType","inClassProperty","noAnonFunctionType","labels","decorators","tokens","comments","trailingComments","leadingComments","commentStack","lineStart","curLine","startLoc","endLoc","curPosition","lastTokEndLoc","lastTokStartLoc","lastTokStart","lastTokEnd","containsEsc","containsOctal","octalPosition","invalidTemplateEscapePosition","exportedIdentifiers","clone","skipArrays","Token","codePointToString","Tokenizer","isLookahead","nextToken","eat","match","word","lookahead","old","curr","setStrict","lastIndexOf","skipSpace","finishToken","readToken","fullCharCodeAtPos","readWord","getTokenFromCode","charCodeAt","pushComment","text","comment","addComment","skipBlockComment","raise","lastIndex","exec","index","skipLineComment","startSkip","ch","loop","readToken_dot","readNumber","next2","readToken_slash","readRegexp","finishOp","readToken_mult_modulo","width","readToken_pipe_amp","hasPlugin","readToken_caret","readToken_plus_min","readToken_lt_gt","size","inModule","unexpected","readToken_eq_excl","readRadixNumber","readString","escaped","inClass","charAt","content","mods","readWord1","readInt","radix","len","total","startsWithDot","octal","isFloat","readCodePoint","throwOnInvalid","codePos","readHexChar","quote","chunkStart","readEscapedChar","containsInvalid","inTemplate","_code","octalStr","substr","first","escStart","esc","_return","_else","frozenDeprecatedWildcardPluginList","Parser","_Tokenizer","opts","getOptions","_this","loadPlugins","isReservedWord","extend","loadAllPlugins","_this2","pluginNames","filter","plugin","pluginList","pluginMap","unshift","_iterator","_isArray","_i","_ref","file","startNode","parseTopLevel","pp","addExtra","extra","isRelational","expectRelational","isContextual","eatContextual","expectContextual","message","canInsertSemicolon","isLineTerminator","semicolon","expect","messageOrType","pp$1","parseBlockBody","finishNode","loopLabel","switchLabel","stmtToDirective","expr","directiveLiteral","startNodeAt","directive","finishNodeAt","parseStatement","topLevel","parseDecorators","starttype","_break","_continue","parseBreakContinueStatement","_debugger","parseDebuggerStatement","_do","parseDoStatement","parseForStatement","parseFunctionStatement","_class","parseClass","parseIfStatement","parseReturnStatement","_switch","parseSwitchStatement","_throw","parseThrowStatement","_try","parseTryStatement","parseVarStatement","parseWhileStatement","parseWithStatement","parseBlock","parseEmptyStatement","_export","_import","parseImport","parseExport","parseFunction","maybeName","parseExpression","parseLabeledStatement","parseExpressionStatement","takeDecorators","allowExport","decorator","parseDecorator","parseMaybeAssign","parseIdentifier","lab","parseParenExpression","forAwait","parseFor","_init","varKind","parseVar","_in","parseForIn","refShorthandDefaultPos","description","toAssignable","checkLVal","sawDefault","cur","_case","_default","isCase","empty","_catch","clause","parseBindingAtom","guardedHandlers","_finally","statementStart","allowDirectives","isValidDirective","parenthesized","directives","parsedNonDirective","oldStrict","isFor","decl","parseVarHead","isStatement","allowExpressionBody","isAsync","optionalId","oldInMethod","initFunction","_yield","parseBindingIdentifier","parseFunctionParams","parseFunctionBody","parseBindingList","parseClassId","parseClassSuper","parseClassBody","isClassProperty","isClassMethod","isNonstaticConstructor","static","hadConstructorCall","hadConstructor","classBody","parseClassMethod","parseClassProperty","parsePropertyName","isSimple","_key","isGenerator","checkGetterSetterParamCount","parseMethod","parseExprSubscripts","specifier","parseExportFrom","exported","specifiers","parseExportSpecifiersMaybe","isExportDefaultSpecifier","_specifier","_specifier2","needsSemi","checkExport","shouldParseExportDeclaration","parseExportDeclaration","parseExportSpecifiers","parseExprAtom","checkNames","isDefault","checkDuplicateExports","_iterator2","_isArray2","_i2","_ref2","_iterator3","_isArray3","_i3","_ref3","checkDeclaration","isClass","_iterator4","_isArray4","_i4","_ref4","prop","_iterator5","_isArray5","_i5","_ref5","elem","raiseDuplicateExportError","nodes","needsFrom","local","__clone","parseImportSpecifiers","startPos","parseImportSpecifierDefault","parseImportSpecifier","imported","checkReservedWord","pp$2","isBinding","contextDescription","toAssignableList","exprList","last","elt","toReferencedList","parseSpread","parseRest","shouldAllowYieldIdentifier","parseObj","close","allowEmpty","elts","parseAssignableListItemTypes","parseMaybeDefault","checkClashes","pp$3","checkPropClash","propHash","proto","getExpression","noIn","afterLeftParse","refNeedsArrowPos","_left","parseYield","failOnShorthandAssign","parseMaybeConditional","errorMsg","parseExprOps","parseConditional","parseMaybeUnary","parseExprOp","leftStartPos","leftStartLoc","minPrec","parenthesizedArgument","argType","_node","parseSubscripts","base","noCalls","parseNoCallExpr","_node2","_node3","possibleAsync","_node4","parseCallExpressionArguments","shouldParseAsyncArrow","parseAsyncArrowFromCallExpression","_node5","quasi","parseTemplate","possibleAsyncArrow","innerParenStart","parseExprListItem","parseArrowExpression","canBeArrow","_super","allowAwait","allowYield","parseAwait","_node6","oldInFunction","oldLabels","parseLiteral","_null","_true","_false","parseParenAndDistinguishExpression","parseExprList","parseFunctionExpression","_new","parseNew","meta","parseMetaProperty","innerStartPos","innerStartLoc","spreadStart","optionalCommaStart","spreadNodeStartPos","spreadNodeStartLoc","parseParenItem","innerEndPos","innerEndLoc","arrowNode","shouldParseArrow","parseArrow","parenStart","metaProp","parseTemplateElement","isTagged","replace","cooked","tail","curElt","quasis","isPattern","firstRestLocation","position","shorthand","asyncId","parseObjPropValue","isGetterOrSetterMethod","paramCount","parseObjectMethod","parseObjectProperty","oldInPropertyName","isStrictBody","isExpression","allowExpression","oldInAsync","oldInFunc","oldInGen","isStrict","nameHash","liberal","identifierName","checkKeywords","delegate","pp$4","commentKeys","Node","node2","processComment","offset","getLineInfo","pp$6","firstChild","lastChild","j","lastInStack","lastComment","commentPreviousNode","splice","lastArg","innerComments","pp$7","isSimpleProperty","estreeParseRegExpLiteral","regex","estreeParseLiteral","directiveToStmt","primitiveTypes","pp$8","flowParseTypeInitialiser","tok","oldInType","flowParseType","flowParsePredicate","moduloLoc","moduloPos","checksLoc","flowParseTypeAndPredicateInitialiser","predicate","flowParseDeclareClass","flowParseInterfaceish","flowParseDeclareFunction","typeNode","typeContainer","typeParameters","flowParseTypeParameterDeclaration","tmp","flowParseFunctionTypeParams","rest","_flowParseTypeAndPred","returnType","flowParseDeclare","flowParseDeclareVariable","flowParseDeclareModuleExports","flowParseDeclareModule","flowParseDeclareTypeAlias","flowParseDeclareOpaqueType","flowParseDeclareInterface","flowParseDeclareExportDeclaration","default","flowParseTypeAnnotatableIdentifier","bodyNode","_bodyNode","flowParseTypeAnnotation","flowParseTypeAlias","flowParseOpaqueType","extends","mixins","flowParseInterfaceExtends","flowParseObjectType","flowParseQualifiedTypeIdentifier","flowParseTypeParameterInstantiation","flowParseInterface","flowParseRestrictedIdentifier","supertype","impltype","flowParseTypeParameter","variance","flowParseVariance","ident","bound","jsxTagStart","flowParseObjectPropertyKey","flowParseObjectTypeIndexer","isStatic","flowObjectTypeSemicolon","flowParseObjectTypeMethodish","flowParseFunctionTypeParam","flowParseObjectTypeMethod","optional","flowParseObjectTypeCallProperty","valueNode","allowStatic","allowExact","allowSpread","nodeStart","propertyKey","callProperties","indexers","endDelim","exact","variancePos","qualification","flowParseGenericType","flowParseTypeofType","flowParsePrimaryType","flowParseTupleType","lh","reinterpretTypeAsFunctionTypeParam","ret","flowIdentToTypeAnnotation","isGroupedType","oldNoAnonFunctionType","flowParsePostfixType","elementType","flowParsePrefixType","flowParseAnonFunctionWithoutParens","flowParseIntersectionType","flowParseUnionType","flowParseTypeAndPredicateAnnotation","_flowParseTypeAndPred2","typeCastToParameter","fromCodePoint","stringFromCharCode","floor","MAX_SIZE","codeUnits","highSurrogate","lowSurrogate","codePoint","fromCodePoint$1","XHTMLEntities","quot","amp","apos","lt","gt","nbsp","iexcl","cent","pound","curren","yen","brvbar","sect","uml","copy","ordf","laquo","not","shy","reg","macr","deg","plusmn","sup2","sup3","acute","micro","para","middot","cedil","sup1","ordm","raquo","frac14","frac12","frac34","iquest","Agrave","Aacute","Acirc","Atilde","Auml","Aring","AElig","Ccedil","Egrave","Eacute","Ecirc","Euml","Igrave","Iacute","Icirc","Iuml","ETH","Ntilde","Ograve","Oacute","Ocirc","Otilde","Ouml","times","Oslash","Ugrave","Uacute","Ucirc","Uuml","Yacute","THORN","szlig","agrave","aacute","acirc","atilde","auml","aring","aelig","ccedil","egrave","eacute","ecirc","euml","igrave","iacute","icirc","iuml","eth","ntilde","ograve","oacute","ocirc","otilde","ouml","divide","oslash","ugrave","uacute","ucirc","uuml","yacute","thorn","yuml","OElig","oelig","Scaron","scaron","Yuml","fnof","circ","tilde","Alpha","Beta","Gamma","Delta","Epsilon","Zeta","Eta","Theta","Iota","Kappa","Lambda","Mu","Nu","Xi","Omicron","Pi","Rho","Sigma","Tau","Upsilon","Phi","Chi","Psi","Omega","alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigmaf","sigma","tau","upsilon","phi","chi","psi","omega","thetasym","upsih","piv","ensp","emsp","thinsp","zwnj","zwj","lrm","rlm","ndash","mdash","lsquo","rsquo","sbquo","ldquo","rdquo","bdquo","dagger","Dagger","bull","hellip","permil","prime","Prime","lsaquo","rsaquo","oline","frasl","euro","image","weierp","real","trade","alefsym","larr","uarr","rarr","darr","harr","crarr","lArr","uArr","rArr","dArr","hArr","forall","part","exist","nabla","isin","notin","ni","prod","sum","minus","lowast","radic","infin","ang","and","or","cap","cup","there4","sim","cong","asymp","ne","equiv","le","ge","sub","sup","nsub","sube","supe","oplus","otimes","perp","sdot","lceil","rceil","lfloor","rfloor","lang","rang","loz","spades","clubs","hearts","diams","HEX_NUMBER","DECIMAL_NUMBER","j_oTag","j_cTag","j_expr","jsxName","jsxText","jsxTagEnd","pp$9","getQualifiedJSXName","namespace","jsxReadToken","jsxReadEntity","jsxReadNewLine","normalizeCRLF","jsxReadString","count","jsxReadWord","jsxParseIdentifier","jsxParseNamespacedName","jsxParseElementName","newNode","jsxParseAttributeValue","jsxParseExpressionContainer","jsxParseEmptyExpression","jsxParseSpreadChild","jsxParseAttribute","jsxParseOpeningElementAt","attributes","selfClosing","jsxParseClosingElementAt","jsxParseElementAt","children","openingElement","closingElement","contents","jsxParseElement","estree","inner","_len","_len2","_key2","reverse","_len3","_key3","_len4","_key4","funcNode","_len5","_key5","_len6","_key6","_len7","_key7","_len8","_key8","flow","typeCastNode","exportKind","declarationNode","_declarationNode","_declarationNode2","_exprListItem","container","superTypeParameters","implemented","implements","importKind","firstIdentLoc","firstIdent","specifierTypeKind","as_ident","jsxError","arrowExpression","jsx","refShortHandDefaultPos","parser","tokTypes","visitors","es2015","es2016","es2017","experimental","ArrowFunctionExpression","lastThis","TemplateLiteral","sort","element","join","TemplateElement","ForOfStatement","SymbolConst","forOfScope","ForOf","ClassDeclaration","ClassConstructor","Class","ClassBody","find","methods","parentNode","SuperClass","_classCallCheck","classScope","ClassConstructorArguments","ClassEntity","_possibleConstructorReturn","getPrototypeOf","_inherits","classMethods","methodScope","ClassMethodArguments","ClassMethod","ClassExpression","Super","findParent","parentPath","isCallExpression","SpreadElement","ImportDeclaration","defaultImport","otherImport","moduleName","isImportDefaultSpecifier","isImportSpecifier","requireVar","requireFunc","targetModule","ExportDefaultDeclaration","moduleObject","ExportNamedDeclaration","AssignmentPattern","RestElement","YieldExpression","TaggedTemplateExpression","templateObject","_taggedTemplateLiteral","expressionResultList","MetaProperty","AwaitExpression","ImportSpecifier","ImportDefaultSpecifier","ExportSpecifier","SpreadProperty","DoExpression","Do","Decorator","origin","ErrDuplicateDeclard","Let","targetScope","rawName","del","childScope","siblingScope","locate","limitSize","stackTraceLimit","stackList","items","stackName","shift","peek","isEmpty","clear"],"mappings":"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I,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,IAAK,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,GAAI,EAAG,IAAK,GAAI,IAAK,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,GAAI,IAAK,KAAM,KAAM,KAAM,IAAK,KAAM,IAAK,EAAG,GAAI,IAAK,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,GAAI,IAAK,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,KAAM,GAAI,IAAK,KAAM,EAAG,KAAM,IAAK,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,KAAM,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,KAAM,IAAK,GAAI,GAAI,KAAM,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAA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","file":"vm.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babel-types\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"babel-types\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"babel-types\")) : factory(root[\"babel-types\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(global, function(__WEBPACK_EXTERNAL_MODULE__13__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 10);\n","export const THIS = \"this\";\nexport const MODULE = \"module\";\nexport const EXPORTS = \"exports\";\nexport const REQUIRE = \"require\";\nexport const UNDEFINED = \"undefined\";\nexport const ARGUMENTS = \"arguments\";\nexport const NEW = \"new\";\nexport const ANONYMOUS = \"anonymous\";\n","import * as t from \"babel-types\";\nimport { Path } from \"./path\";\n\nexport enum ScopeType {\n  Root,\n  Function, // isolated scope\n  Method, // isolated scope\n  Constructor, // isolated scope\n  For,\n  ForChild,\n  ForIn,\n  ForOf,\n  While,\n  DoWhile,\n  Do,\n  Switch,\n  If,\n  ElseIf,\n  Object,\n  Try,\n  Catch,\n  Finally,\n  Class,\n  Block\n}\n\nexport const isolatedScopeMap = {\n  [ScopeType.Function]: true,\n  [ScopeType.Constructor]: true,\n  [ScopeType.Method]: true,\n  [ScopeType.Object]: true\n};\n\nexport enum Kind {\n  Var = \"var\",\n  Const = \"const\",\n  Let = \"let\"\n}\n\nexport type KindType = \"var\" | \"const\" | \"let\";\n\nexport interface IES5TypeMap {\n  File: t.File;\n  Program: t.Program;\n  Identifier: t.Identifier;\n  NullLiteral: t.NullLiteral;\n  StringLiteral: t.StringLiteral;\n  NumericLiteral: t.NumericLiteral;\n  BooleanLiteral: t.BooleanLiteral;\n  RegExpLiteral: t.RegExpLiteral;\n  FunctionDeclaration: t.FunctionDeclaration;\n  FunctionExpression: t.FunctionExpression;\n  ArrayExpression: t.ArrayExpression;\n  SwitchCase: t.SwitchCase;\n  CatchClause: t.CatchClause;\n  VariableDeclarator: t.VariableDeclarator;\n  ExpressionStatement: t.ExpressionStatement;\n  BlockStatement: t.BlockStatement;\n  EmptyStatement: t.EmptyStatement;\n  DebuggerStatement: t.DebuggerStatement;\n  // WithStatement: t.WithStatement; // babylon parse in strict mode and disable WithStatement\n  ReturnStatement: t.ReturnStatement;\n  LabeledStatement: t.LabeledStatement;\n  BreakStatement: t.BreakStatement;\n  ContinueStatement: t.ContinueStatement;\n  IfStatement: t.IfStatement;\n  SwitchStatement: t.SwitchStatement;\n  ThrowStatement: t.ThrowStatement;\n  TryStatement: t.TryStatement;\n  WhileStatement: t.WhileStatement;\n  DoWhileStatement: t.DoWhileStatement;\n  ForStatement: t.ForStatement;\n  ForInStatement: t.ForInStatement;\n  VariableDeclaration: t.VariableDeclaration;\n  ThisExpression: t.ThisExpression;\n  ObjectExpression: t.ObjectExpression;\n  ObjectProperty: t.ObjectProperty;\n  ObjectMethod: t.ObjectMethod;\n  UnaryExpression: t.UnaryExpression;\n  UpdateExpression: t.UpdateExpression;\n  BinaryExpression: t.BinaryExpression;\n  AssignmentExpression: t.AssignmentExpression;\n  LogicalExpression: t.LogicalExpression;\n  MemberExpression: t.MemberExpression;\n  ConditionalExpression: t.ConditionalExpression;\n  CallExpression: t.CallExpression;\n  NewExpression: t.NewExpression;\n  SequenceExpression: t.SequenceExpression;\n}\n\nexport interface IES2015TypeMap {\n  ArrowFunctionExpression: t.ArrowFunctionExpression;\n  TemplateLiteral: t.TemplateLiteral;\n  TaggedTemplateExpression: t.TaggedTemplateExpression;\n  ForOfStatement: t.ForOfStatement;\n  ClassExpression: t.ClassExpression;\n  ClassMethod: t.ClassMethod;\n  MetaProperty: t.MetaProperty;\n  Super: t.Super;\n  TemplateElement: t.TemplateElement;\n  SpreadElement: t.SpreadElement;\n  ClassDeclaration: t.ClassDeclaration;\n  YieldExpression: t.YieldExpression;\n  // ObjectPattern: t.ObjectPattern;\n  // ArrayPattern: t.ArrayPattern;\n  RestElement: t.RestElement;\n  AssignmentPattern: t.AssignmentPattern;\n  ClassBody: t.ClassBody;\n  ImportDeclaration: t.ImportDeclaration;\n  ExportNamedDeclaration: t.ExportNamedDeclaration;\n  ExportDefaultDeclaration: t.ExportDefaultDeclaration;\n}\n\nexport interface IES2016TypeMap {\n  BinaryExpression: t.BinaryExpression;\n}\n\nexport interface IES2017TypeMap {\n  AwaitExpression: t.AwaitExpression;\n}\n\nexport interface IExperimentalTypeMap {\n  // ExportAllDeclaration: t.ExportAllDeclaration;\n  ImportSpecifier: t.ImportSpecifier;\n  ImportDefaultSpecifier: t.ImportDefaultSpecifier;\n  // ImportNamespaceSpecifier: t.ImportNamespaceSpecifier;\n  ExportSpecifier: t.ExportSpecifier;\n  SpreadProperty: t.SpreadProperty;\n  DoExpression: t.DoExpression;\n  Decorator: t.Decorator;\n}\n\nexport interface INodeTypeMap\n  extends IES5TypeMap,\n    IES2015TypeMap,\n    IES2016TypeMap,\n    IES2017TypeMap,\n    IExperimentalTypeMap {}\n\nexport type ES5Map = {\n  [key in keyof IES5TypeMap]: (path: Path<IES5TypeMap[key]>) => any\n};\n\nexport type ES2015Map = {\n  [key in keyof IES2015TypeMap]: (path: Path<IES2015TypeMap[key]>) => any\n};\n\nexport type ES2016Map = {\n  [key in keyof IES2016TypeMap]: (path: Path<IES2016TypeMap[key]>) => any\n};\n\nexport type ES2017Map = {\n  [key in keyof IES2017TypeMap]: (path: Path<IES2017TypeMap[key]>) => any\n};\n\nexport type ExperimentalMap = {\n  [key in keyof IExperimentalTypeMap]: (\n    path: Path<IExperimentalTypeMap[key]>\n  ) => any\n};\n\nexport type IEcmaScriptMap = {\n  [key in keyof INodeTypeMap]: (path: Path<INodeTypeMap[key]>) => any\n};\n\nexport type EvaluateFunc = (path: Path<t.Node>) => any;\n\nexport enum presetMap {\n  es5 = \"es5\",\n  es2015 = \"es2015\",\n  es2016 = \"es2016\",\n  es2017 = \"es2017\",\n  es2018 = \"es2018\",\n  env = \"env\"\n}\n","export function ErrNotDefined(varName: string): ReferenceError {\n  return new ReferenceError(`${varName} is not defined`);\n}\n\nexport function ErrImplement(varName: string): SyntaxError {\n  return new SyntaxError(`Not implement for '${varName}' syntax`);\n}\n\nexport function ErrDuplicateDeclard(varName: string): SyntaxError {\n  return new SyntaxError(`Identifier '${varName}' has already been declared`);\n}\n\nexport function ErrIsNot(name: string, type: string): TypeError {\n  return new TypeError(`${name} is not ${type}`);\n}\n\nexport function ErrInvalidIterable(name): TypeError {\n  return ErrIsNot(name, \"iterable\");\n}\n\nexport function ErrNoSuper(): ReferenceError {\n  return new ReferenceError(\n    `Must call super constructor in derived class before accessing 'this' or returning from derived constructor`\n  );\n}\n\nexport function ErrIsNotFunction(name: string): ReferenceError {\n  return new TypeError(`${name} is not a function`);\n}\n\nexport function ErrCanNotReadProperty(\n  property: string,\n  target: string\n): ReferenceError {\n  return new TypeError(`Cannot read property '${property}' of ${target}`);\n}\n","import { UNDEFINED } from \"./constant\";\n\nexport interface ISandBox {\n  [k: string]: any;\n}\n\ndeclare const WebAssembly: any;\n\n// ECMA standar refs: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects\nexport const DEFAULT_CONTEXT: ISandBox = {\n  Function,\n  Array,\n  Boolean,\n  clearInterval,\n  clearTimeout,\n  console,\n  Date,\n  decodeURI,\n  decodeURIComponent,\n  encodeURI,\n  encodeURIComponent,\n  Error,\n  escape,\n  eval,\n  EvalError,\n  Infinity,\n  isFinite,\n  isNaN,\n  JSON,\n  Math,\n  NaN,\n  Number,\n  [\"null\"]: null,\n  [UNDEFINED]: void 0,\n  Object,\n  parseFloat,\n  parseInt,\n  RangeError,\n  ReferenceError,\n  RegExp,\n  setInterval,\n  setTimeout,\n  String,\n  SyntaxError,\n  TypeError,\n  unescape,\n  URIError\n};\n\n// need to polyfill by user\n/* istanbul ignore if */\nif (typeof Promise !== UNDEFINED) {\n  DEFAULT_CONTEXT.Promise = Promise;\n}\n\n/* istanbul ignore if */\nif (typeof Proxy !== UNDEFINED) {\n  DEFAULT_CONTEXT.Proxy = Proxy;\n}\n\n/* istanbul ignore if */\nif (typeof Reflect !== UNDEFINED) {\n  DEFAULT_CONTEXT.Reflect = Reflect;\n}\n\n/* istanbul ignore if */\nif (typeof Symbol !== UNDEFINED) {\n  DEFAULT_CONTEXT.Symbol = Symbol;\n}\n\n/* istanbul ignore if */\nif (typeof Set !== UNDEFINED) {\n  DEFAULT_CONTEXT.Set = Set;\n}\n\n/* istanbul ignore if */\nif (typeof WeakSet !== UNDEFINED) {\n  DEFAULT_CONTEXT.WeakSet = WeakSet;\n}\n\n/* istanbul ignore if */\nif (typeof Map !== UNDEFINED) {\n  DEFAULT_CONTEXT.Map = Map;\n}\n\n/* istanbul ignore if */\nif (typeof WeakMap !== UNDEFINED) {\n  DEFAULT_CONTEXT.WeakMap = WeakMap;\n}\n\n/* istanbul ignore if */\nif (typeof ArrayBuffer !== UNDEFINED) {\n  DEFAULT_CONTEXT.ArrayBuffer = ArrayBuffer;\n}\n\n/* istanbul ignore if */\nif (typeof SharedArrayBuffer !== UNDEFINED) {\n  DEFAULT_CONTEXT.ArrayBuffer = SharedArrayBuffer;\n}\n\n/* istanbul ignore if */\nif (typeof DataView !== UNDEFINED) {\n  DEFAULT_CONTEXT.ArrayBuffer = DataView;\n}\n\n/* istanbul ignore if */\nif (typeof Atomics !== UNDEFINED) {\n  DEFAULT_CONTEXT.Atomics = Atomics;\n}\n\n/* istanbul ignore if */\nif (typeof Float32Array !== UNDEFINED) {\n  DEFAULT_CONTEXT.Float32Array = Float32Array;\n}\n\n/* istanbul ignore if */\nif (typeof Float64Array !== UNDEFINED) {\n  DEFAULT_CONTEXT.Float64Array = Float64Array;\n}\n\n/* istanbul ignore if */\nif (typeof Int16Array !== UNDEFINED) {\n  DEFAULT_CONTEXT.Int16Array = Int16Array;\n}\n\n/* istanbul ignore if */\nif (typeof Int32Array !== UNDEFINED) {\n  DEFAULT_CONTEXT.Int32Array = Int32Array;\n}\n\n/* istanbul ignore if */\nif (typeof Int8Array !== UNDEFINED) {\n  DEFAULT_CONTEXT.Int32Array = Int8Array;\n}\n\n/* istanbul ignore if */\nif (typeof Intl !== UNDEFINED) {\n  DEFAULT_CONTEXT.Intl = Intl;\n}\n\n/* istanbul ignore if */\nif (typeof Uint16Array !== UNDEFINED) {\n  DEFAULT_CONTEXT.Uint16Array = Uint16Array;\n}\n\n/* istanbul ignore if */\nif (typeof Uint32Array !== UNDEFINED) {\n  DEFAULT_CONTEXT.Uint32Array = Uint32Array;\n}\n\n/* istanbul ignore if */\nif (typeof Uint8Array !== UNDEFINED) {\n  DEFAULT_CONTEXT.Uint8Array = Uint8Array;\n}\n\n/* istanbul ignore if */\nif (typeof Uint8ClampedArray !== UNDEFINED) {\n  DEFAULT_CONTEXT.Uint8ClampedArray = Uint8ClampedArray;\n}\n\n/* istanbul ignore if */\nif (typeof WebAssembly !== UNDEFINED) {\n  DEFAULT_CONTEXT.WebAssembly = WebAssembly;\n}\n\nexport class Context {\n  constructor(externalContext: ISandBox = {}) {\n    const ctx = { ...DEFAULT_CONTEXT, ...externalContext };\n    for (const attr in ctx) {\n      /* istanbul ignore next */\n      if (ctx.hasOwnProperty(attr)) {\n        this[attr] = ctx[attr];\n      }\n    }\n  }\n}\n","import * as types from \"babel-types\";\nimport * as isFunction from \"lodash.isfunction\";\nimport {\n  ErrNoSuper,\n  ErrNotDefined,\n  ErrIsNotFunction,\n  ErrCanNotReadProperty,\n  ErrInvalidIterable\n} from \"../error\";\nimport { __generator, _toConsumableArray, __awaiter } from \"../runtime\";\nimport { Var, IVar } from \"../var\";\nimport { ES5Map, Kind, ScopeType } from \"../type\";\nimport { Signal } from \"../signal\";\nimport { Scope } from \"../scope\";\nimport { Stack } from \"../stack\";\nimport { THIS, UNDEFINED, ARGUMENTS, NEW, ANONYMOUS } from \"../constant\";\n\nimport {\n  isArrayPattern,\n  isAssignmentPattern,\n  isFunctionDeclaration,\n  isIdentifier,\n  isMemberExpression,\n  isObjectExpression,\n  isObjectPattern,\n  isObjectProperty,\n  isRestElement,\n  isSpreadElement,\n  isVariableDeclaration,\n  isStringLiteral\n} from \"../packages/babel-types\";\n\nimport { defineFunctionLength, defineFunctionName } from \"../utils\";\n\nimport { Prototype } from \"../Prototype\";\nimport { This } from \"../This\";\n\nfunction overriteStack(err: Error, stack: Stack, node: types.Node): Error {\n  stack.push({\n    filename: ANONYMOUS,\n    stack: stack.currentStackName,\n    location: node.loc\n  });\n  err.stack = err.toString() + \"\\n\" + stack.raw;\n  return err;\n}\n\nexport const BinaryExpressionOperatorEvaluateMap = {\n  // tslint:disable-next-line\n  \"==\": (a, b) => a == b,\n  // tslint:disable-next-line\n  \"!=\": (a, b) => a != b,\n  \"===\": (a, b) => a === b,\n  \"!==\": (a, b) => a !== b,\n  \"<\": (a, b) => a < b,\n  \"<=\": (a, b) => a <= b,\n  \">\": (a, b) => a > b,\n  \">=\": (a, b) => a >= b,\n  // tslint:disable-next-line\n  \"<<\": (a, b) => a << b,\n  // tslint:disable-next-line\n  \">>\": (a, b) => a >> b,\n  // tslint:disable-next-line\n  \">>>\": (a, b) => a >>> b,\n  \"+\": (a, b) => a + b,\n  \"-\": (a, b) => a - b,\n  \"*\": (a, b) => a * b,\n  \"/\": (a, b) => a / b,\n  \"%\": (a, b) => a % b,\n  // tslint:disable-next-line\n  \"|\": (a, b) => a | b,\n  // tslint:disable-next-line\n  \"^\": (a, b) => a ^ b,\n  // tslint:disable-next-line\n  \"&\": (a, b) => a & b,\n  // \"**\": (a, b) => {\n  //   throw ErrImplement('**')\n  // },\n  in: (a, b) => a in b,\n  instanceof: (a, b) => a instanceof b\n};\n\nexport const AssignmentExpressionEvaluateMap = {\n  \"=\": ($var: IVar, v) => {\n    $var.set(v);\n    return v;\n  },\n  \"+=\": ($var: IVar, v) => {\n    $var.set($var.value + v);\n    return $var.value;\n  },\n  \"-=\": ($var: IVar, v) => {\n    $var.set($var.value - v);\n    return $var.value;\n  },\n  \"*=\": ($var: IVar, v) => {\n    $var.set($var.value * v);\n    return $var.value;\n  },\n  \"**=\": ($var: IVar, v) => {\n    $var.set(Math.pow($var.value, v));\n    return $var.value;\n  },\n  \"/=\": ($var: IVar, v) => {\n    $var.set($var.value / v);\n    return $var.value;\n  },\n  \"%=\": ($var: IVar, v) => {\n    $var.set($var.value % v);\n    return $var.value;\n  },\n  \"<<=\": ($var: IVar, v) => {\n    // tslint:disable-next-line: no-bitwise\n    $var.set($var.value << v);\n    return $var.value;\n  },\n  \">>=\": ($var: IVar, v) => {\n    // tslint:disable-next-line: no-bitwise\n    $var.set($var.value >> v);\n    return $var.value;\n  },\n  \">>>=\": ($var: IVar, v) => {\n    // tslint:disable-next-line: no-bitwise\n    $var.set($var.value >>> v);\n    return $var.value;\n  },\n  \"|=\": ($var: IVar, v) => {\n    // tslint:disable-next-line: no-bitwise\n    $var.set($var.value | v);\n    return $var.value;\n  },\n  \"^=\": ($var: IVar, v) => {\n    // tslint:disable-next-line: no-bitwise\n    $var.set($var.value ^ v);\n    return $var.value;\n  },\n  \"&=\": ($var: IVar, v) => {\n    // tslint:disable-next-line: no-bitwise\n    $var.set($var.value & v);\n    return $var.value;\n  }\n};\n\nexport const es5: ES5Map = {\n  File(path) {\n    path.evaluate(path.createChild(path.node.program));\n  },\n  Program(path) {\n    const { node: program, scope } = path;\n    // hoisting\n    for (const node of program.body) {\n      if (isFunctionDeclaration(node)) {\n        path.evaluate(path.createChild(node));\n      } else if (isVariableDeclaration(node)) {\n        for (const declaration of node.declarations) {\n          if (node.kind === Kind.Var) {\n            scope.var((declaration.id as types.Identifier).name, undefined);\n          }\n        }\n      }\n    }\n\n    for (const node of program.body) {\n      if (!isFunctionDeclaration(node)) {\n        path.evaluate(path.createChild(node));\n      }\n    }\n  },\n  Identifier(path) {\n    const { node, scope, stack } = path;\n    if (node.name === UNDEFINED) {\n      return undefined;\n    }\n    const $var = scope.hasBinding(node.name);\n    if ($var) {\n      return $var.value;\n    } else {\n      throw overriteStack(ErrNotDefined(node.name), stack, node);\n    }\n  },\n  RegExpLiteral(path) {\n    const { node } = path;\n    return new RegExp(node.pattern, node.flags);\n  },\n  StringLiteral(path) {\n    return path.node.value;\n  },\n  NumericLiteral(path) {\n    return path.node.value;\n  },\n  BooleanLiteral(path) {\n    return path.node.value;\n  },\n  NullLiteral(path) {\n    return null;\n  },\n  IfStatement(path) {\n    const ifScope = path.scope.createChild(ScopeType.If);\n    ifScope.invasive = true;\n    ifScope.isolated = false;\n    if (path.evaluate(path.createChild(path.node.test, ifScope))) {\n      return path.evaluate(path.createChild(path.node.consequent, ifScope));\n    } else if (path.node.alternate) {\n      return path.evaluate(path.createChild(path.node.alternate, ifScope));\n    }\n  },\n  EmptyStatement(path) {\n    // do nothing\n  },\n  BlockStatement(path) {\n    const { node: block, scope } = path;\n\n    let blockScope: Scope = !scope.isolated\n      ? scope\n      : scope.createChild(ScopeType.Block);\n\n    if (scope.isolated) {\n      blockScope = scope.createChild(ScopeType.Block);\n      blockScope.invasive = true;\n    } else {\n      blockScope = scope;\n    }\n\n    blockScope.isolated = true;\n\n    // hoisting\n    for (const node of block.body) {\n      if (isFunctionDeclaration(node)) {\n        path.evaluate(path.createChild(node));\n      } else if (isVariableDeclaration(node)) {\n        for (const declaration of node.declarations) {\n          if (node.kind === Kind.Var) {\n            if (!scope.isolated && scope.invasive) {\n              const targetScope = (function get(s: Scope) {\n                if (s.parent) {\n                  if (s.parent.invasive) {\n                    return get(s.parent);\n                  } else {\n                    return s.parent;\n                  }\n                } else {\n                  return s;\n                }\n              })(scope);\n              targetScope.parent.var(\n                (declaration.id as types.Identifier).name,\n                undefined\n              );\n            } else {\n              scope.var((declaration.id as types.Identifier).name, undefined);\n            }\n          }\n        }\n      }\n    }\n\n    let tempResult;\n    for (const node of block.body) {\n      const result = (tempResult = path.evaluate(\n        path.createChild(node, blockScope)\n      ));\n      if (result instanceof Signal) {\n        return result;\n      }\n    }\n    // to support do-expression\n    // anyway, return the last item\n    return tempResult;\n  },\n  // babylon parse in strict mode and disable WithStatement\n  // WithStatement(path) {\n  // throw ErrNotSupport(path.node.type);\n  // },\n  DebuggerStatement(path) {\n    // tslint:disable-next-line\n    debugger;\n  },\n  LabeledStatement(path) {\n    const label = path.node.label as types.Identifier;\n    return path.evaluate(\n      path.createChild(path.node.body, path.scope, { labelName: label.name })\n    );\n  },\n  BreakStatement(path) {\n    const label = path.node.label;\n    return new Signal(\"break\", label ? label.name : undefined);\n  },\n  ContinueStatement(path) {\n    const label = path.node.label;\n    return new Signal(\"continue\", label ? label.name : undefined);\n  },\n  ReturnStatement(path) {\n    return new Signal(\n      \"return\",\n      path.node.argument\n        ? path.evaluate(path.createChild(path.node.argument))\n        : undefined\n    );\n  },\n  VariableDeclaration(path) {\n    const { node, scope, stack } = path;\n    const kind = node.kind;\n\n    for (const declaration of node.declarations) {\n      const varKeyValueMap: { [k: string]: any } = {};\n      /**\n       * example:\n       *\n       * var a = 1\n       */\n      if (isIdentifier(declaration.id)) {\n        varKeyValueMap[declaration.id.name] = declaration.init\n          ? path.evaluate(path.createChild(declaration.init))\n          : undefined;\n      } else if (isObjectPattern(declaration.id)) {\n        /**\n         * example:\n         *\n         * const {q,w,e} = {};\n         */\n        const vars: Array<{ key: string; alias: string }> = [];\n        for (const n of declaration.id.properties) {\n          if (isObjectProperty(n)) {\n            vars.push({\n              key: (n.key as any).name as string,\n              alias: (n.value as any).name as string\n            });\n          }\n        }\n        const obj = path.evaluate(path.createChild(declaration.init));\n\n        for (const $var of vars) {\n          if ($var.key in obj) {\n            varKeyValueMap[$var.alias] = obj[$var.key];\n          }\n        }\n      } else if (isArrayPattern(declaration.id)) {\n        // @es2015 destrucuring\n        // @flow\n        const initValue = path.evaluate(path.createChild(declaration.init));\n\n        if (!initValue[Symbol.iterator]) {\n          throw overriteStack(\n            ErrInvalidIterable(\"{(intermediate value)}\"),\n            stack,\n            declaration.init\n          );\n        }\n\n        declaration.id.elements.forEach((n, i) => {\n          if (isIdentifier(n)) {\n            const $varName: string = n.typeAnnotation\n              ? (n.typeAnnotation.typeAnnotation as any).id.name\n              : n.name;\n\n            const el = initValue[i];\n            varKeyValueMap[$varName] = el;\n          }\n        });\n      } else {\n        throw node;\n      }\n\n      // start defned var\n      for (const varName in varKeyValueMap) {\n        /**\n         * If the scope is penetrating and defined as VAR, it is defined on its parent scope\n         * example:\n         *\n         * {\n         *   var a = 123\n         * }\n         */\n        if (scope.invasive && kind === Kind.Var) {\n          const targetScope = (function get(s: Scope) {\n            if (s.parent) {\n              if (s.parent.invasive) {\n                return get(s.parent);\n              } else {\n                return s.parent;\n              }\n            } else {\n              return s;\n            }\n          })(scope);\n\n          targetScope.declare(kind, varName, varKeyValueMap[varName]);\n        } else {\n          scope.declare(kind, varName, varKeyValueMap[varName]);\n        }\n      }\n    }\n  },\n  VariableDeclarator: path => {\n    const { node, scope } = path;\n    // @es2015 destructuring\n    if (isObjectPattern(node.id)) {\n      const newScope = scope.createChild(ScopeType.Object);\n      if (isObjectExpression(node.init)) {\n        path.evaluate(path.createChild(node.init, newScope));\n      }\n      for (const n of node.id.properties) {\n        if (isObjectProperty(n)) {\n          const propertyName: string = (n as any).id.name;\n          const $var = newScope.hasBinding(propertyName);\n          const varValue = $var ? $var.value : undefined;\n          scope.var(propertyName, varValue);\n          return varValue;\n        }\n      }\n    } else if (isObjectExpression(node.init)) {\n      const varName: string = (node.id as types.Identifier).name;\n      const varValue = path.evaluate(path.createChild(node.init));\n      scope.var(varName, varValue);\n      return varValue;\n    } else {\n      throw node;\n    }\n  },\n  FunctionDeclaration(path) {\n    const { node, scope } = path;\n    const { name: functionName } = node.id;\n\n    let func;\n\n    if (node.async) {\n      // FIXME: support async function\n      func = function() {\n        return __awaiter(this, void 0, void 0, () => {\n          // tslint:disable-next-line\n          const __this = this;\n\n          // tslint:disable-next-line\n          function handler(_a) {\n            const functionBody = node.body;\n            const block = functionBody.body[_a.label];\n            // the last block\n            if (!block) {\n              return [2, undefined];\n            }\n\n            const fieldContext = {\n              call: false,\n              value: null\n            };\n            function next(value) {\n              fieldContext.value = value;\n              fieldContext.call = true;\n              _a.sent();\n            }\n\n            const r = path.evaluate(\n              path.createChild(block, path.scope, { next })\n            );\n\n            if (Signal.isReturn(r)) {\n              return [2 /* return */, r.value];\n            }\n            if (fieldContext.call) {\n              return [4 /* yield */, fieldContext.value];\n            } else {\n              // next block\n              _a.label++;\n              return handler(_a);\n            }\n          }\n\n          return __generator(__this, handler);\n        });\n      };\n    } else if (node.generator) {\n      func = function() {\n        // tslint:disable-next-line\n        const __this = this;\n\n        // tslint:disable-next-line\n        function handler(_a) {\n          const functionBody = node.body;\n          const block = functionBody.body[_a.label];\n          // the last block\n          if (!block) {\n            return [2, undefined];\n          }\n\n          const fieldContext = {\n            call: false,\n            value: null\n          };\n          function next(value) {\n            fieldContext.value = value;\n            fieldContext.call = true;\n            _a.sent();\n          }\n\n          const r = path.evaluate(\n            path.createChild(block, path.scope, { next })\n          );\n\n          if (Signal.isReturn(r)) {\n            return [2, r.value];\n          }\n          if (fieldContext.call) {\n            return [4, fieldContext.value];\n          } else {\n            // next block\n            _a.label++;\n            return handler(_a);\n          }\n        }\n\n        return __generator(__this, handler);\n      };\n    } else {\n      func = es5.FunctionExpression(path.createChild(node as any));\n    }\n\n    defineFunctionLength(func, node.params.length || 0);\n    defineFunctionName(func, functionName);\n\n    // Function can repeat declaration\n    scope.var(functionName, func);\n  },\n  ExpressionStatement(path) {\n    return path.evaluate(path.createChild(path.node.expression));\n  },\n  ForStatement(path) {\n    const { node, scope, ctx } = path;\n    const labelName = ctx.labelName as string | void;\n    const forScope = scope.createChild(ScopeType.For);\n\n    forScope.invasive = true; // \n\n    // init loop\n    if (node.init) {\n      path.evaluate(path.createChild(node.init, forScope));\n    }\n\n    function update(): void {\n      if (node.update) {\n        path.evaluate(path.createChild(node.update, forScope));\n      }\n    }\n\n    function test(): boolean {\n      return node.test\n        ? path.evaluate(path.createChild(node.test, forScope))\n        : true;\n    }\n\n    for (;;) {\n      // every loop will create it's own scope\n      // it should inherit from forScope\n      const loopScope = forScope.fork(ScopeType.ForChild);\n      loopScope.isolated = false;\n\n      if (!test()) {\n        break;\n      }\n\n      const signal = path.evaluate(\n        path.createChild(node.body, loopScope, { labelName: undefined })\n      );\n\n      if (Signal.isBreak(signal)) {\n        if (!signal.value) {\n          break;\n        }\n        if (signal.value === labelName) {\n          break;\n        }\n        return signal;\n      } else if (Signal.isContinue(signal)) {\n        if (!signal.value) {\n          continue;\n        }\n        if (signal.value === labelName) {\n          update();\n          continue;\n        }\n        return signal;\n      } else if (Signal.isReturn(signal)) {\n        return signal;\n      }\n\n      update();\n    }\n  },\n  ForInStatement(path) {\n    const { node, scope, ctx } = path;\n    const kind = (node.left as types.VariableDeclaration).kind;\n    const decl = (node.left as types.VariableDeclaration).declarations[0];\n    const name = (decl.id as types.Identifier).name;\n\n    const labelName: string = ctx.labelName;\n\n    const right = path.evaluate(path.createChild(node.right));\n\n    for (const value in right) {\n      if (Object.hasOwnProperty.call(right, value)) {\n        const forInScope = scope.createChild(ScopeType.ForIn);\n        forInScope.invasive = true;\n        forInScope.isolated = false;\n        forInScope.declare(kind, name, value);\n\n        const signal = path.evaluate(path.createChild(node.body, forInScope));\n\n        if (Signal.isBreak(signal)) {\n          if (!signal.value) {\n            break;\n          }\n          if (signal.value === labelName) {\n            break;\n          }\n          return signal;\n        } else if (Signal.isContinue(signal)) {\n          if (!signal.value) {\n            continue;\n          }\n          if (signal.value === labelName) {\n            continue;\n          }\n          return signal;\n        } else if (Signal.isReturn(signal)) {\n          return signal;\n        }\n      }\n    }\n  },\n  DoWhileStatement(path) {\n    const { node, scope, ctx } = path;\n    const labelName: string | void = ctx.labelName;\n    // do while don't have his own scope\n    do {\n      const doWhileScope = scope.createChild(ScopeType.DoWhile);\n      doWhileScope.invasive = true;\n      doWhileScope.isolated = false;\n      const signal = path.evaluate(path.createChild(node.body, doWhileScope));\n      if (Signal.isBreak(signal)) {\n        if (!signal.value) {\n          break;\n        }\n        if (signal.value === labelName) {\n          break;\n        }\n        return signal;\n      } else if (Signal.isContinue(signal)) {\n        if (!signal.value) {\n          continue;\n        }\n        if (signal.value === labelName) {\n          continue;\n        }\n        return signal;\n      } else if (Signal.isReturn(signal)) {\n        return signal;\n      }\n    } while (path.evaluate(path.createChild(node.test)));\n  },\n  WhileStatement(path) {\n    const { node, scope, ctx } = path;\n    const labelName: string | void = ctx.labelName;\n\n    while (path.evaluate(path.createChild(node.test))) {\n      const whileScope = scope.createChild(ScopeType.While);\n      whileScope.invasive = true;\n      whileScope.isolated = false;\n      const signal = path.evaluate(path.createChild(node.body, whileScope));\n      if (Signal.isBreak(signal)) {\n        if (!signal.value) {\n          break;\n        }\n\n        if (signal.value === labelName) {\n          break;\n        }\n\n        return signal;\n      } else if (Signal.isContinue(signal)) {\n        if (!signal.value) {\n          continue;\n        }\n\n        if (signal.value === labelName) {\n          continue;\n        }\n        return signal;\n      } else if (Signal.isReturn(signal)) {\n        return signal;\n      }\n    }\n  },\n  ThrowStatement(path) {\n    // TODO: rewrite the stack log\n    throw path.evaluate(path.createChild(path.node.argument));\n  },\n  CatchClause(path) {\n    return path.evaluate(path.createChild(path.node.body));\n  },\n  TryStatement(path) {\n    const { node, scope } = path;\n    try {\n      const tryScope = scope.createChild(ScopeType.Try);\n      tryScope.invasive = true;\n      tryScope.isolated = false;\n      return path.evaluate(path.createChild(node.block, tryScope));\n    } catch (err) {\n      const param = node.handler.param as types.Identifier;\n      const catchScope = scope.createChild(ScopeType.Catch);\n      catchScope.invasive = true;\n      catchScope.isolated = false;\n      catchScope.const(param.name, err);\n      return path.evaluate(path.createChild(node.handler, catchScope));\n    } finally {\n      if (node.finalizer) {\n        const finallyScope = scope.createChild(ScopeType.Finally);\n        finallyScope.invasive = true;\n        finallyScope.isolated = false;\n        // tslint:disable-next-line\n        return path.evaluate(path.createChild(node.finalizer, finallyScope));\n      }\n    }\n  },\n  SwitchStatement(path) {\n    const { node, scope } = path;\n    const discriminant = path.evaluate(path.createChild(node.discriminant)); // switch\n    const switchScope = scope.createChild(ScopeType.Switch);\n    switchScope.invasive = true;\n    switchScope.isolated = false;\n\n    let matched = false;\n    for (const $case of node.cases) {\n      //  case\n      if (\n        !matched &&\n        (!$case.test ||\n          discriminant ===\n            path.evaluate(path.createChild($case.test, switchScope)))\n      ) {\n        matched = true;\n      }\n\n      if (matched) {\n        const result = path.evaluate(path.createChild($case, switchScope));\n\n        if (Signal.isBreak(result)) {\n          break;\n        } else if (Signal.isContinue(result)) {\n          // SwitchStatement can not use continue keyword\n          // but it can continue parent loop, like for, for-in, for-of, while\n          return result;\n        } else if (Signal.isReturn(result)) {\n          return result;\n        }\n      }\n    }\n  },\n  SwitchCase(path) {\n    const { node } = path;\n    for (const stmt of node.consequent) {\n      const result = path.evaluate(path.createChild(stmt));\n      if (result instanceof Signal) {\n        return result;\n      }\n    }\n  },\n  UpdateExpression(path) {\n    const { node, scope, stack } = path;\n    const { prefix } = node;\n    let $var: IVar;\n    if (isIdentifier(node.argument)) {\n      const { name } = node.argument;\n      const $$var = scope.hasBinding(name);\n      if (!$$var) {\n        throw overriteStack(ErrNotDefined(name), stack, node.argument);\n      }\n      $var = $$var;\n    } else if (isMemberExpression(node.argument)) {\n      const argument = node.argument;\n      const object = path.evaluate(path.createChild(argument.object));\n      const property = argument.computed\n        ? path.evaluate(path.createChild(argument.property))\n        : (argument.property as types.Identifier).name;\n      $var = {\n        kind: Kind.Const,\n        set(value: any) {\n          object[property] = value;\n        },\n        get value() {\n          return object[property];\n        }\n      };\n    }\n\n    return {\n      \"--\": v => {\n        $var.set(v - 1);\n        return prefix ? --v : v--;\n      },\n      \"++\": v => {\n        $var.set(v + 1);\n        return prefix ? ++v : v++;\n      }\n    }[node.operator](path.evaluate(path.createChild(node.argument)));\n  },\n  ThisExpression(path) {\n    const { scope } = path;\n    // use this in class constructor it it never call super();\n    if (scope.type === ScopeType.Constructor) {\n      if (!scope.hasOwnBinding(THIS)) {\n        throw overriteStack(ErrNoSuper(), path.stack, path.node);\n      }\n    }\n    const thisVar = scope.hasBinding(THIS);\n    return thisVar ? thisVar.value : null;\n  },\n  ArrayExpression(path) {\n    const { node } = path;\n    let newArray: any[] = [];\n    for (const item of node.elements) {\n      if (item === null) {\n        newArray.push(undefined);\n      } else if (isSpreadElement(item)) {\n        const arr = path.evaluate(path.createChild(item));\n        newArray = ([] as any[]).concat(newArray, _toConsumableArray(arr));\n      } else {\n        newArray.push(path.evaluate(path.createChild(item)));\n      }\n    }\n    return newArray;\n  },\n  ObjectExpression(path) {\n    const { node, scope } = path;\n    const object = {};\n    const newScope = scope.createChild(ScopeType.Object);\n    const computedProperties: Array<\n      types.ObjectProperty | types.ObjectMethod\n    > = [];\n\n    for (const property of node.properties) {\n      const tempProperty = property as\n        | types.ObjectMethod\n        | types.ObjectProperty;\n      if (tempProperty.computed === true) {\n        computedProperties.push(tempProperty);\n        continue;\n      }\n      path.evaluate(path.createChild(property, newScope, { object }));\n    }\n\n    // eval the computed properties\n    for (const property of computedProperties) {\n      path.evaluate(path.createChild(property, newScope, { object }));\n    }\n\n    return object;\n  },\n  ObjectProperty(path) {\n    const { node, scope, ctx } = path;\n    const { object } = ctx;\n    const val = path.evaluate(path.createChild(node.value));\n    if (isIdentifier(node.key)) {\n      object[node.key.name] = val;\n      scope.var(node.key.name, val);\n    } else {\n      object[path.evaluate(path.createChild(node.key))] = val;\n    }\n  },\n  ObjectMethod(path) {\n    const { node, scope, stack } = path;\n    const methodName: string = !node.computed\n      ? isIdentifier(node.key)\n        ? node.key.name\n        : path.evaluate(path.createChild(node.key))\n      : path.evaluate(path.createChild(node.key));\n    const method = function() {\n      stack.enter(\"Object.\" + methodName);\n      const args = [].slice.call(arguments);\n      const newScope = scope.createChild(ScopeType.Function);\n      newScope.const(THIS, this);\n      // define arguments\n      node.params.forEach((param, i) => {\n        newScope.const((param as types.Identifier).name, args[i]);\n      });\n      const result = path.evaluate(path.createChild(node.body, newScope));\n      stack.leave();\n      if (Signal.isReturn(result)) {\n        return result.value;\n      }\n    };\n    defineFunctionLength(method, node.params.length);\n    defineFunctionName(method, methodName);\n\n    const objectKindMap = {\n      get() {\n        Object.defineProperty(path.ctx.object, methodName, { get: method });\n        scope.const(methodName, method);\n      },\n      set() {\n        Object.defineProperty(path.ctx.object, methodName, { set: method });\n      },\n      method() {\n        Object.defineProperty(path.ctx.object, methodName, { value: method });\n      }\n    };\n\n    const definer = objectKindMap[node.kind];\n\n    if (definer) {\n      definer();\n    }\n  },\n  FunctionExpression(path) {\n    const { node, scope, stack } = path;\n\n    const functionName = node.id ? node.id.name : \"\";\n    const func = function(...args) {\n      stack.enter(functionName); // enter the stack\n\n      // Is this function is a constructor?\n      // if it's constructor, it should return instance\n      const shouldReturnInstance =\n        args.length &&\n        args[args.length - 1] instanceof This &&\n        args.pop() &&\n        true;\n\n      const funcScope = scope.createChild(ScopeType.Function);\n      for (let i = 0; i < node.params.length; i++) {\n        const param = node.params[i];\n        if (isIdentifier(param)) {\n          funcScope.let(param.name, args[i]);\n        } else if (isAssignmentPattern(param)) {\n          // @es2015 default parameters\n          path.evaluate(path.createChild(param, funcScope, { value: args[i] }));\n        } else if (isRestElement(param)) {\n          // @es2015 rest parameters\n          path.evaluate(\n            path.createChild(param, funcScope, { value: args.slice(i) })\n          );\n        }\n      }\n\n      funcScope.const(THIS, this);\n      // support new.target\n      funcScope.const(NEW, {\n        target:\n          this && this.__proto__ && this.__proto__.constructor\n            ? this.__proto__.constructor\n            : undefined\n      });\n      funcScope.const(ARGUMENTS, arguments);\n      funcScope.isolated = false;\n\n      const result = path.evaluate(path.createChild(node.body, funcScope));\n      stack.leave(); // leave stack\n      if (result instanceof Signal) {\n        return result.value;\n      } else if (shouldReturnInstance) {\n        return this;\n      } else {\n        return result;\n      }\n    };\n\n    defineFunctionLength(func, node.params.length);\n    defineFunctionName(func, node.id ? node.id.name : \"\"); // Anonymous function\n\n    return func;\n  },\n  BinaryExpression(path) {\n    const { node } = path;\n    return BinaryExpressionOperatorEvaluateMap[node.operator](\n      path.evaluate(path.createChild(node.left)),\n      path.evaluate(path.createChild(node.right))\n    );\n  },\n  UnaryExpression(path) {\n    const { node, scope } = path;\n    return {\n      \"-\": () => -path.evaluate(path.createChild(node.argument)),\n      \"+\": () => +path.evaluate(path.createChild(node.argument)),\n      \"!\": () => !path.evaluate(path.createChild(node.argument)),\n      // tslint:disable-next-line\n      \"~\": () => ~path.evaluate(path.createChild(node.argument)),\n      void: () => void path.evaluate(path.createChild(node.argument)),\n      typeof: (): string => {\n        if (isIdentifier(node.argument)) {\n          const $var = scope.hasBinding(node.argument.name);\n          return $var ? typeof $var.value : UNDEFINED;\n        } else {\n          return typeof path.evaluate(path.createChild(node.argument));\n        }\n      },\n      delete: () => {\n        if (isMemberExpression(node.argument)) {\n          const { object, property, computed } = node.argument;\n          if (computed) {\n            return delete path.evaluate(path.createChild(object))[\n              path.evaluate(path.createChild(property))\n            ];\n          } else {\n            return delete path.evaluate(path.createChild(object))[\n              (property as types.Identifier).name\n            ];\n          }\n        } else if (isIdentifier(node.argument)) {\n          const $this = scope.hasBinding(THIS);\n          if ($this) {\n            return $this.value[node.argument.name];\n          }\n        }\n      }\n    }[node.operator]();\n  },\n  CallExpression(path) {\n    const { node, scope, stack } = path;\n\n    const functionName: string = isMemberExpression(node.callee)\n      ? (() => {\n          if (isIdentifier(node.callee.property)) {\n            return (\n              (node.callee.object as any).name + \".\" + node.callee.property.name\n            );\n          } else if (isStringLiteral(node.callee.property)) {\n            return (\n              (node.callee.object as any).name +\n              \".\" +\n              node.callee.property.value\n            );\n          } else {\n            return \"undefined\";\n          }\n        })()\n      : (node.callee as types.Identifier).name;\n\n    const func = path.evaluate(path.createChild(node.callee));\n    const args = node.arguments.map(arg =>\n      path.evaluate(path.createChild(arg))\n    );\n    const isValidFunction = isFunction(func) as boolean;\n\n    let context: any = null;\n\n    if (isMemberExpression(node.callee)) {\n      if (!isValidFunction) {\n        throw overriteStack(\n          ErrIsNotFunction(functionName),\n          stack,\n          node.callee.property\n        );\n      } else {\n        stack.push({\n          filename: ANONYMOUS,\n          stack: stack.currentStackName,\n          location: node.callee.property.loc\n        });\n      }\n      context = path.evaluate(path.createChild(node.callee.object));\n    } else {\n      if (!isValidFunction) {\n        throw overriteStack(ErrIsNotFunction(functionName), stack, node);\n      } else {\n        stack.push({\n          filename: ANONYMOUS,\n          stack: stack.currentStackName,\n          location: node.loc\n        });\n      }\n      const thisVar = scope.hasBinding(THIS);\n      context = thisVar ? thisVar.value : null;\n    }\n\n    const result = func.apply(context, args);\n\n    if (result instanceof Error) {\n      result.stack = result.toString() + \"\\n\" + stack.raw;\n    }\n\n    return result;\n  },\n  MemberExpression(path) {\n    const { node } = path;\n    const { object, property, computed } = node;\n\n    const propertyName: string = computed\n      ? path.evaluate(path.createChild(property))\n      : (property as types.Identifier).name;\n\n    const obj = path.evaluate(path.createChild(object));\n\n    if (obj === undefined) {\n      throw ErrCanNotReadProperty(propertyName, \"undefined\");\n    }\n\n    if (obj === null) {\n      throw ErrCanNotReadProperty(propertyName, \"null\");\n    }\n\n    const isPrototype =\n      propertyName === \"prototype\" && types.isIdentifier(property);\n\n    const target = isPrototype ? new Prototype(obj) : obj[propertyName];\n\n    return target instanceof Prototype\n      ? target\n      : isFunction(target)\n        ? target.bind(obj)\n        : target;\n  },\n  AssignmentExpression(path) {\n    const { node, scope } = path;\n    let $var: IVar = {\n      kind: Kind.Var,\n      set(value: any) {\n        //\n      },\n      get value() {\n        return undefined;\n      }\n    };\n    let rightValue;\n\n    if (isIdentifier(node.left)) {\n      const { name } = node.left;\n      const varOrNot = scope.hasBinding(name);\n      // right first\n      rightValue = path.evaluate(path.createChild(node.right));\n\n      if (!varOrNot) {\n        // here to define global var\n        const globalScope = scope.global;\n        globalScope.var(name, path.evaluate(path.createChild(node.right)));\n        const globalVar = globalScope.hasBinding(name);\n        if (globalVar) {\n          $var = globalVar;\n        } else {\n          throw overriteStack(ErrNotDefined(name), path.stack, node.right);\n        }\n      } else {\n        $var = varOrNot as Var<any>;\n        /**\n         * const test = 123;\n         * test = 321 // it should throw an error\n         */\n        if ($var.kind === Kind.Const) {\n          throw overriteStack(\n            new TypeError(\"Assignment to constant variable.\"),\n            path.stack,\n            node.left\n          );\n        }\n      }\n    } else if (isMemberExpression(node.left)) {\n      const left = node.left;\n      const object: any = path.evaluate(path.createChild(left.object));\n      // left first\n      rightValue = path.evaluate(path.createChild(node.right));\n\n      const property: string = left.computed\n        ? path.evaluate(path.createChild(left.property))\n        : (left.property as types.Identifier).name;\n\n      $var = {\n        kind: Kind.Var,\n        set(value: any) {\n          if (object instanceof Prototype) {\n            const Constructor = object.constructor;\n            Constructor.prototype[property] = value;\n          } else {\n            object[property] = value;\n          }\n        },\n        get value() {\n          return object[property];\n        }\n      };\n    }\n\n    return AssignmentExpressionEvaluateMap[node.operator]($var, rightValue);\n  },\n  LogicalExpression(path) {\n    const { node } = path;\n    return {\n      \"||\": () =>\n        path.evaluate(path.createChild(node.left)) ||\n        path.evaluate(path.createChild(node.right)),\n      \"&&\": () =>\n        path.evaluate(path.createChild(node.left)) &&\n        path.evaluate(path.createChild(node.right))\n    }[node.operator]();\n  },\n  ConditionalExpression(path) {\n    return path.evaluate(path.createChild(path.node.test))\n      ? path.evaluate(path.createChild(path.node.consequent))\n      : path.evaluate(path.createChild(path.node.alternate));\n  },\n  NewExpression(path) {\n    const { node, stack } = path;\n    const func = path.evaluate(path.createChild(node.callee));\n    const args: any[] = node.arguments.map(arg =>\n      path.evaluate(path.createChild(arg))\n    );\n    func.prototype.constructor = func;\n    let entity = /native code/.test(func.toString())\n      ? new func(...args)\n      : new func(...args, new This(null));\n\n    // stack track for Error constructor\n    if (func === Error || entity instanceof Error) {\n      entity = overriteStack(entity, stack, node);\n    }\n    return entity;\n  },\n  SequenceExpression(path) {\n    let result;\n    for (const expression of path.node.expressions) {\n      result = path.evaluate(path.createChild(expression));\n    }\n    return result;\n  }\n};\n","/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    nullTag = '[object Null]',\n    proxyTag = '[object Proxy]',\n    undefinedTag = '[object Undefined]';\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isFunction;\n","/* tslint:disable */\n/* istanbul ignore file */\n\nexport function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nexport const _createClass = (function() {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function(Constructor, protoProps?, staticProps?) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n})();\n\nexport function _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\n      \"this hasn't been initialised - super() hasn't been called\"\n    );\n  }\n  return call && (typeof call === \"object\" || typeof call === \"function\")\n    ? call\n    : self;\n}\n\nexport function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\n      \"Super expression must either be null or a function, not \" +\n        typeof superClass\n    );\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass)\n    Object.setPrototypeOf\n      ? Object.setPrototypeOf(subClass, superClass)\n      : (subClass.__proto__ = superClass);\n}\n\nexport const _extends =\n  Object.assign ||\n  function(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n\nexport function _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nexport function _asyncToGenerator(fn) {\n  return function() {\n    var gen = fn.apply(this, arguments);\n    return new Promise(function(resolve, reject) {\n      function step(key, arg?) {\n        try {\n          var info = gen[key](arg);\n          var value = info.value;\n        } catch (error) {\n          reject(error);\n          return;\n        }\n        if (info.done) {\n          resolve(value);\n        } else {\n          return Promise.resolve(value).then(\n            function(value) {\n              step(\"next\", value);\n            },\n            function(err) {\n              step(\"throw\", err);\n            }\n          );\n        }\n      }\n      return step(\"next\");\n    });\n  };\n}\n\nexport const __generator =\n  (this && this.__generator) ||\n  function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n          if (t[0] & 1) throw t[1];\n          return t[1];\n        },\n        trys: [],\n        ops: []\n      },\n      f,\n      y,\n      t,\n      g;\n    return (\n      (g = { next: verb(0), throw: verb(1), return: verb(2) }),\n      typeof Symbol === \"function\" &&\n        (g[Symbol.iterator] = function() {\n          return this;\n        }),\n      g\n    );\n    function verb(n) {\n      return function(v) {\n        return step([n, v]);\n      };\n    }\n    function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (_)\n        try {\n          if (\n            ((f = 1),\n            y &&\n              (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) &&\n              !(t = t.call(y, op[1])).done)\n          )\n            return t;\n          if (((y = 0), t)) op = [0, t.value];\n          switch (op[0]) {\n            case 0:\n            case 1:\n              t = op;\n              break;\n            case 4:\n              _.label++;\n              return { value: op[1], done: false };\n            case 5:\n              _.label++;\n              y = op[1];\n              op = [0];\n              continue;\n            case 7:\n              op = _.ops.pop();\n              _.trys.pop();\n              continue;\n            default:\n              if (\n                !((t = _.trys), (t = t.length > 0 && t[t.length - 1])) &&\n                (op[0] === 6 || op[0] === 2)\n              ) {\n                (<any>_) = 0;\n                continue;\n              }\n              if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {\n                _.label = op[1];\n                break;\n              }\n              if (op[0] === 6 && _.label < t[1]) {\n                _.label = t[1];\n                t = op;\n                break;\n              }\n              if (t && _.label < t[2]) {\n                _.label = t[2];\n                (<any[]>_.ops).push(op);\n                break;\n              }\n              if (t[2]) _.ops.pop();\n              _.trys.pop();\n              continue;\n          }\n          op = body.call(thisArg, _);\n        } catch (e) {\n          op = [6, e];\n          y = 0;\n        } finally {\n          f = t = 0;\n        }\n      if (op[0] & 5) throw op[1];\n      return { value: op[0] ? op[1] : void 0, done: true };\n    }\n  };\n\nexport function _taggedTemplateLiteral(strings: string[], raw: string[]) {\n  return Object.freeze(\n    Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })\n  );\n}\n\nexport const __awaiter =\n  (this && this.__awaiter) ||\n  function(thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function(resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n      function step(result) {\n        result.done\n          ? resolve(result.value)\n          : new P(function(resolve) {\n              resolve(result.value);\n            }).then(fulfilled, rejected);\n      }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  };\n","export type SignalKind = \"break\" | \"continue\" | \"return\";\n\nexport class Signal {\n  public static is(v: any, type: SignalKind): v is Signal {\n    return v instanceof Signal && v.kind === type;\n  }\n  public static isContinue(v: any): v is Signal {\n    return Signal.is(v, \"continue\");\n  }\n  public static isBreak(v: any): v is Signal {\n    return Signal.is(v, \"break\");\n  }\n  public static isReturn(v: any): v is Signal {\n    return Signal.is(v, \"return\");\n  }\n  constructor(public kind: SignalKind, public value?: any) {}\n}\n","import {\n  ArrayExpression,\n  ArrayPattern,\n  AssignmentPattern,\n  CallExpression,\n  ClassMethod,\n  ClassProperty,\n  FunctionDeclaration,\n  Identifier,\n  ImportDefaultSpecifier,\n  ImportSpecifier,\n  MemberExpression,\n  Node,\n  ObjectExpression,\n  ObjectPattern,\n  ObjectProperty,\n  RestElement,\n  SpreadElement,\n  VariableDeclaration,\n  StringLiteral\n} from \"babel-types\";\n\nfunction is(node: Node, type: string): boolean {\n  return node.type === type;\n}\n\nexport function isStringLiteral(node: Node): node is StringLiteral {\n  return is(node, \"StringLiteral\");\n}\n\nexport function isArrayExpression(node: Node): node is ArrayExpression {\n  return is(node, \"ArrayExpression\");\n}\n\nexport function isObjectExpression(node: Node): node is ObjectExpression {\n  return is(node, \"ObjectExpression\");\n}\n\nexport function isFunctionDeclaration(node: Node): node is FunctionDeclaration {\n  return is(node, \"FunctionDeclaration\");\n}\n\nexport function isVariableDeclaration(node: Node): node is VariableDeclaration {\n  return is(node, \"VariableDeclaration\");\n}\n\nexport function isIdentifier(node: Node): node is Identifier {\n  return is(node, \"Identifier\");\n}\n\nexport function isObjectPattern(node: Node): node is ObjectPattern {\n  return is(node, \"ObjectPattern\");\n}\n\nexport function isObjectProperty(node: Node): node is ObjectProperty {\n  return is(node, \"ObjectProperty\");\n}\n\nexport function isArrayPattern(node: Node): node is ArrayPattern {\n  return is(node, \"ArrayPattern\");\n}\n\nexport function isMemberExpression(node: Node): node is MemberExpression {\n  return is(node, \"MemberExpression\");\n}\n\nexport function isSpreadElement(node: Node): node is SpreadElement {\n  return is(node, \"SpreadElement\");\n}\n\nexport function isAssignmentPattern(node: Node): node is AssignmentPattern {\n  return is(node, \"AssignmentPattern\");\n}\n\nexport function isRestElement(node: Node): node is RestElement {\n  return is(node, \"RestElement\");\n}\n\nexport function isClassMethod(node: Node): node is ClassMethod {\n  return is(node, \"ClassMethod\");\n}\n\nexport function isClassProperty(node: Node): node is ClassProperty {\n  return is(node, \"ClassProperty\");\n}\n\nexport function isCallExpression(node: Node): node is CallExpression {\n  return is(node, \"CallExpression\");\n}\n\nexport function isImportDefaultSpecifier(\n  node: Node\n): node is ImportDefaultSpecifier {\n  return is(node, \"ImportDefaultSpecifier\");\n}\n\nexport function isImportSpecifier(node: Node): node is ImportSpecifier {\n  return is(node, \"ImportSpecifier\");\n}\n","export function defineFunctionName(func, name: string) {\n  Object.defineProperty(func, \"name\", {\n    value: name || \"\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n}\n\nexport function defineFunctionLength(func, length: number) {\n  Object.defineProperty(func, \"length\", {\n    value: length || 0,\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n}\n","import { parse } from \"babylon\";\nimport { Context, ISandBox } from \"./context\";\nimport evaluate from \"./evaluate\";\nimport { Path } from \"./path\";\nimport { Scope } from \"./scope\";\nimport { MODULE, EXPORTS, THIS } from \"./constant\";\nimport { ScopeType, presetMap } from \"./type\";\nimport { Stack } from \"./stack\";\n\n/**\n * Run the code in context\n * @export\n * @param {string} code\n * @param {Context} context\n * @returns\n */\nexport function runInContext(\n  code: string,\n  context: Context,\n  preset: presetMap = presetMap.env\n) {\n  const scope = new Scope(ScopeType.Root, null);\n  scope.level = 0;\n  scope.invasive = true;\n  scope.const(THIS, undefined);\n  scope.setContext(context);\n\n  // define module\n  const $exports = {};\n  const $module = { exports: $exports };\n  scope.const(MODULE, $module);\n  scope.var(EXPORTS, $exports);\n\n  const ast = parse(code, {\n    sourceType: \"module\",\n    plugins: [\n      \"asyncGenerators\",\n      \"classProperties\",\n      \"decorators\",\n      \"doExpressions\",\n      \"exportExtensions\",\n      \"flow\",\n      \"objectRestSpread\"\n    ]\n  });\n\n  const path = new Path(ast, null, scope, {}, new Stack());\n  path.preset = preset;\n  path.evaluate = evaluate;\n\n  evaluate(path);\n\n  // exports\n  const moduleVar = scope.hasBinding(MODULE);\n  return moduleVar ? moduleVar.value.exports : undefined;\n}\n\n/**\n * Create a context\n * @export\n * @param {ISandBox} [sandbox={}]\n * @returns {Context}\n */\nexport function createContext(sandbox: ISandBox = {}): Context {\n  return new Context(sandbox);\n}\n\nexport default { runInContext, createContext };\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/* eslint max-len: 0 */\n\n// This is a trick taken from Esprima. It turns out that, on\n// non-Chrome browsers, to check whether a string is in a set, a\n// predicate containing a big ugly `switch` statement is faster than\n// a regular expression, and on Chrome the two are about on par.\n// This function uses `eval` (non-lexical) to produce such a\n// predicate from a space-separated string of words.\n//\n// It starts by sorting the words by length.\n\nfunction makePredicate(words) {\n  words = words.split(\" \");\n  return function (str) {\n    return words.indexOf(str) >= 0;\n  };\n}\n\n// Reserved word lists for various dialects of the language\n\nvar reservedWords = {\n  6: makePredicate(\"enum await\"),\n  strict: makePredicate(\"implements interface let package private protected public static yield\"),\n  strictBind: makePredicate(\"eval arguments\")\n};\n\n// And the keywords\n\nvar isKeyword = makePredicate(\"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this let const class extends export import yield super\");\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\n\nvar nonASCIIidentifierStartChars = \"\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC\";\nvar nonASCIIidentifierChars = \"\\u200C\\u200D\\xB7\\u0300-\\u036F\\u0387\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u0669\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u06F0-\\u06F9\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07C0-\\u07C9\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D4-\\u08E1\\u08E3-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096F\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u09E6-\\u09EF\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A66-\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B62\\u0B63\\u0B66-\\u0B6F\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0CE6-\\u0CEF\\u0D01-\\u0D03\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D66-\\u0D6F\\u0D82\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0E50-\\u0E59\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1040-\\u1049\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F-\\u109D\\u135D-\\u135F\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u194F\\u19D0-\\u19DA\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AB0-\\u1ABD\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BB0-\\u1BB9\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1C40-\\u1C49\\u1C50-\\u1C59\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF2-\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF5\\u1DFB-\\u1DFF\\u203F\\u2040\\u2054\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA620-\\uA629\\uA66F\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA880\\uA881\\uA8B4-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F1\\uA900-\\uA909\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uA9D0-\\uA9D9\\uA9E5\\uA9F0-\\uA9F9\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA50-\\uAA59\\uAA7B-\\uAA7D\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF10-\\uFF19\\uFF3F\";\n\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by `bin/generate-identifier-regex.js`.\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 785, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 25, 391, 63, 32, 0, 449, 56, 264, 8, 2, 36, 18, 0, 50, 29, 881, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 65, 0, 32, 6124, 20, 754, 9486, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 10591, 541];\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 10, 2, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 87, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 423, 9, 838, 7, 2, 7, 17, 9, 57, 21, 2, 13, 19882, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239];\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000;\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code) {\n  if (code < 65) return code === 36;\n  if (code < 91) return true;\n  if (code < 97) return code === 95;\n  if (code < 123) return true;\n  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code < 91) return true;\n  if (code < 97) return code === 95;\n  if (code < 123) return true;\n  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\n\n// A second optional argument can be given to further configure\nvar defaultOptions = {\n  // Source type (\"script\" or \"module\") for different semantics\n  sourceType: \"script\",\n  // Source filename.\n  sourceFilename: undefined,\n  // Line from which to start counting source. Useful for\n  // integration with other tools.\n  startLine: 1,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // TODO\n  allowSuperOutsideMethod: false,\n  // An array of plugins to enable\n  plugins: [],\n  // TODO\n  strictMode: null\n};\n\n// Interpret and default an options object\n\nfunction getOptions(opts) {\n  var options = {};\n  for (var key in defaultOptions) {\n    options[key] = opts && key in opts ? opts[key] : defaultOptions[key];\n  }\n  return options;\n}\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\n\n\n\n\n\n\n\n\n\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nvar beforeExpr = true;\nvar startsExpr = true;\nvar isLoop = true;\nvar isAssign = true;\nvar prefix = true;\nvar postfix = true;\n\nvar TokenType = function TokenType(label) {\n  var conf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  classCallCheck(this, TokenType);\n\n  this.label = label;\n  this.keyword = conf.keyword;\n  this.beforeExpr = !!conf.beforeExpr;\n  this.startsExpr = !!conf.startsExpr;\n  this.rightAssociative = !!conf.rightAssociative;\n  this.isLoop = !!conf.isLoop;\n  this.isAssign = !!conf.isAssign;\n  this.prefix = !!conf.prefix;\n  this.postfix = !!conf.postfix;\n  this.binop = conf.binop || null;\n  this.updateContext = null;\n};\n\nvar KeywordTokenType = function (_TokenType) {\n  inherits(KeywordTokenType, _TokenType);\n\n  function KeywordTokenType(name) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, KeywordTokenType);\n\n    options.keyword = name;\n\n    return possibleConstructorReturn(this, _TokenType.call(this, name, options));\n  }\n\n  return KeywordTokenType;\n}(TokenType);\n\nvar BinopTokenType = function (_TokenType2) {\n  inherits(BinopTokenType, _TokenType2);\n\n  function BinopTokenType(name, prec) {\n    classCallCheck(this, BinopTokenType);\n    return possibleConstructorReturn(this, _TokenType2.call(this, name, { beforeExpr: beforeExpr, binop: prec }));\n  }\n\n  return BinopTokenType;\n}(TokenType);\n\nvar types = {\n  num: new TokenType(\"num\", { startsExpr: startsExpr }),\n  regexp: new TokenType(\"regexp\", { startsExpr: startsExpr }),\n  string: new TokenType(\"string\", { startsExpr: startsExpr }),\n  name: new TokenType(\"name\", { startsExpr: startsExpr }),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", { beforeExpr: beforeExpr, startsExpr: startsExpr }),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", { beforeExpr: beforeExpr, startsExpr: startsExpr }),\n  braceBarL: new TokenType(\"{|\", { beforeExpr: beforeExpr, startsExpr: startsExpr }),\n  braceR: new TokenType(\"}\"),\n  braceBarR: new TokenType(\"|}\"),\n  parenL: new TokenType(\"(\", { beforeExpr: beforeExpr, startsExpr: startsExpr }),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", { beforeExpr: beforeExpr }),\n  semi: new TokenType(\";\", { beforeExpr: beforeExpr }),\n  colon: new TokenType(\":\", { beforeExpr: beforeExpr }),\n  doubleColon: new TokenType(\"::\", { beforeExpr: beforeExpr }),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", { beforeExpr: beforeExpr }),\n  arrow: new TokenType(\"=>\", { beforeExpr: beforeExpr }),\n  template: new TokenType(\"template\"),\n  ellipsis: new TokenType(\"...\", { beforeExpr: beforeExpr }),\n  backQuote: new TokenType(\"`\", { startsExpr: startsExpr }),\n  dollarBraceL: new TokenType(\"${\", { beforeExpr: beforeExpr, startsExpr: startsExpr }),\n  at: new TokenType(\"@\"),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", { beforeExpr: beforeExpr, isAssign: isAssign }),\n  assign: new TokenType(\"_=\", { beforeExpr: beforeExpr, isAssign: isAssign }),\n  incDec: new TokenType(\"++/--\", { prefix: prefix, postfix: postfix, startsExpr: startsExpr }),\n  prefix: new TokenType(\"prefix\", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr }),\n  logicalOR: new BinopTokenType(\"||\", 1),\n  logicalAND: new BinopTokenType(\"&&\", 2),\n  bitwiseOR: new BinopTokenType(\"|\", 3),\n  bitwiseXOR: new BinopTokenType(\"^\", 4),\n  bitwiseAND: new BinopTokenType(\"&\", 5),\n  equality: new BinopTokenType(\"==/!=\", 6),\n  relational: new BinopTokenType(\"</>\", 7),\n  bitShift: new BinopTokenType(\"<</>>\", 8),\n  plusMin: new TokenType(\"+/-\", { beforeExpr: beforeExpr, binop: 9, prefix: prefix, startsExpr: startsExpr }),\n  modulo: new BinopTokenType(\"%\", 10),\n  star: new BinopTokenType(\"*\", 10),\n  slash: new BinopTokenType(\"/\", 10),\n  exponent: new TokenType(\"**\", { beforeExpr: beforeExpr, binop: 11, rightAssociative: true })\n};\n\nvar keywords = {\n  \"break\": new KeywordTokenType(\"break\"),\n  \"case\": new KeywordTokenType(\"case\", { beforeExpr: beforeExpr }),\n  \"catch\": new KeywordTokenType(\"catch\"),\n  \"continue\": new KeywordTokenType(\"continue\"),\n  \"debugger\": new KeywordTokenType(\"debugger\"),\n  \"default\": new KeywordTokenType(\"default\", { beforeExpr: beforeExpr }),\n  \"do\": new KeywordTokenType(\"do\", { isLoop: isLoop, beforeExpr: beforeExpr }),\n  \"else\": new KeywordTokenType(\"else\", { beforeExpr: beforeExpr }),\n  \"finally\": new KeywordTokenType(\"finally\"),\n  \"for\": new KeywordTokenType(\"for\", { isLoop: isLoop }),\n  \"function\": new KeywordTokenType(\"function\", { startsExpr: startsExpr }),\n  \"if\": new KeywordTokenType(\"if\"),\n  \"return\": new KeywordTokenType(\"return\", { beforeExpr: beforeExpr }),\n  \"switch\": new KeywordTokenType(\"switch\"),\n  \"throw\": new KeywordTokenType(\"throw\", { beforeExpr: beforeExpr }),\n  \"try\": new KeywordTokenType(\"try\"),\n  \"var\": new KeywordTokenType(\"var\"),\n  \"let\": new KeywordTokenType(\"let\"),\n  \"const\": new KeywordTokenType(\"const\"),\n  \"while\": new KeywordTokenType(\"while\", { isLoop: isLoop }),\n  \"with\": new KeywordTokenType(\"with\"),\n  \"new\": new KeywordTokenType(\"new\", { beforeExpr: beforeExpr, startsExpr: startsExpr }),\n  \"this\": new KeywordTokenType(\"this\", { startsExpr: startsExpr }),\n  \"super\": new KeywordTokenType(\"super\", { startsExpr: startsExpr }),\n  \"class\": new KeywordTokenType(\"class\"),\n  \"extends\": new KeywordTokenType(\"extends\", { beforeExpr: beforeExpr }),\n  \"export\": new KeywordTokenType(\"export\"),\n  \"import\": new KeywordTokenType(\"import\", { startsExpr: startsExpr }),\n  \"yield\": new KeywordTokenType(\"yield\", { beforeExpr: beforeExpr, startsExpr: startsExpr }),\n  \"null\": new KeywordTokenType(\"null\", { startsExpr: startsExpr }),\n  \"true\": new KeywordTokenType(\"true\", { startsExpr: startsExpr }),\n  \"false\": new KeywordTokenType(\"false\", { startsExpr: startsExpr }),\n  \"in\": new KeywordTokenType(\"in\", { beforeExpr: beforeExpr, binop: 7 }),\n  \"instanceof\": new KeywordTokenType(\"instanceof\", { beforeExpr: beforeExpr, binop: 7 }),\n  \"typeof\": new KeywordTokenType(\"typeof\", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr }),\n  \"void\": new KeywordTokenType(\"void\", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr }),\n  \"delete\": new KeywordTokenType(\"delete\", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr })\n};\n\n// Map keyword names to token types.\nObject.keys(keywords).forEach(function (name) {\n  types[\"_\" + name] = keywords[name];\n});\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\n\nfunction isNewLine(code) {\n  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029;\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override) {\n  classCallCheck(this, TokContext);\n\n  this.token = token;\n  this.isExpr = !!isExpr;\n  this.preserveSpace = !!preserveSpace;\n  this.override = override;\n};\n\nvar types$1 = {\n  braceStatement: new TokContext(\"{\", false),\n  braceExpression: new TokContext(\"{\", true),\n  templateQuasi: new TokContext(\"${\", true),\n  parenStatement: new TokContext(\"(\", false),\n  parenExpression: new TokContext(\"(\", true),\n  template: new TokContext(\"`\", true, true, function (p) {\n    return p.readTmplToken();\n  }),\n  functionExpression: new TokContext(\"function\", true)\n};\n\n// Token-specific context update code\n\ntypes.parenR.updateContext = types.braceR.updateContext = function () {\n  if (this.state.context.length === 1) {\n    this.state.exprAllowed = true;\n    return;\n  }\n\n  var out = this.state.context.pop();\n  if (out === types$1.braceStatement && this.curContext() === types$1.functionExpression) {\n    this.state.context.pop();\n    this.state.exprAllowed = false;\n  } else if (out === types$1.templateQuasi) {\n    this.state.exprAllowed = true;\n  } else {\n    this.state.exprAllowed = !out.isExpr;\n  }\n};\n\ntypes.name.updateContext = function (prevType) {\n  this.state.exprAllowed = false;\n\n  if (prevType === types._let || prevType === types._const || prevType === types._var) {\n    if (lineBreak.test(this.input.slice(this.state.end))) {\n      this.state.exprAllowed = true;\n    }\n  }\n};\n\ntypes.braceL.updateContext = function (prevType) {\n  this.state.context.push(this.braceIsBlock(prevType) ? types$1.braceStatement : types$1.braceExpression);\n  this.state.exprAllowed = true;\n};\n\ntypes.dollarBraceL.updateContext = function () {\n  this.state.context.push(types$1.templateQuasi);\n  this.state.exprAllowed = true;\n};\n\ntypes.parenL.updateContext = function (prevType) {\n  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n  this.state.context.push(statementParens ? types$1.parenStatement : types$1.parenExpression);\n  this.state.exprAllowed = true;\n};\n\ntypes.incDec.updateContext = function () {\n  // tokExprAllowed stays unchanged\n};\n\ntypes._function.updateContext = function () {\n  if (this.curContext() !== types$1.braceStatement) {\n    this.state.context.push(types$1.functionExpression);\n  }\n\n  this.state.exprAllowed = false;\n};\n\ntypes.backQuote.updateContext = function () {\n  if (this.curContext() === types$1.template) {\n    this.state.context.pop();\n  } else {\n    this.state.context.push(types$1.template);\n  }\n  this.state.exprAllowed = false;\n};\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = function Position(line, col) {\n  classCallCheck(this, Position);\n\n  this.line = line;\n  this.column = col;\n};\n\nvar SourceLocation = function SourceLocation(start, end) {\n  classCallCheck(this, SourceLocation);\n\n  this.start = start;\n  this.end = end;\n};\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur;\n    var match = lineBreakG.exec(input);\n    if (match && match.index < offset) {\n      ++line;\n      cur = match.index + match[0].length;\n    } else {\n      return new Position(line, offset - cur);\n    }\n  }\n}\n\nvar State = function () {\n  function State() {\n    classCallCheck(this, State);\n  }\n\n  State.prototype.init = function init(options, input) {\n    this.strict = options.strictMode === false ? false : options.sourceType === \"module\";\n\n    this.input = input;\n\n    this.potentialArrowAt = -1;\n\n    this.inMethod = this.inFunction = this.inGenerator = this.inAsync = this.inPropertyName = this.inType = this.inClassProperty = this.noAnonFunctionType = false;\n\n    this.labels = [];\n\n    this.decorators = [];\n\n    this.tokens = [];\n\n    this.comments = [];\n\n    this.trailingComments = [];\n    this.leadingComments = [];\n    this.commentStack = [];\n\n    this.pos = this.lineStart = 0;\n    this.curLine = options.startLine;\n\n    this.type = types.eof;\n    this.value = null;\n    this.start = this.end = this.pos;\n    this.startLoc = this.endLoc = this.curPosition();\n\n    this.lastTokEndLoc = this.lastTokStartLoc = null;\n    this.lastTokStart = this.lastTokEnd = this.pos;\n\n    this.context = [types$1.braceStatement];\n    this.exprAllowed = true;\n\n    this.containsEsc = this.containsOctal = false;\n    this.octalPosition = null;\n\n    this.invalidTemplateEscapePosition = null;\n\n    this.exportedIdentifiers = [];\n\n    return this;\n  };\n\n  // TODO\n\n\n  // TODO\n\n\n  // Used to signify the start of a potential arrow function\n\n\n  // Flags to track whether we are in a function, a generator.\n\n\n  // Labels in scope.\n\n\n  // Leading decorators.\n\n\n  // Token store.\n\n\n  // Comment store.\n\n\n  // Comment attachment store\n\n\n  // The current position of the tokenizer in the input.\n\n\n  // Properties of the current token:\n  // Its type\n\n\n  // For tokens that include more information than their type, the value\n\n\n  // Its start and end offset\n\n\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n\n\n  // Position information for the previous token\n\n\n  // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n\n\n  // TODO\n\n\n  // Names of exports store. `default` is stored as a name for both\n  // `export default foo;` and `export { foo as default };`.\n\n\n  State.prototype.curPosition = function curPosition() {\n    return new Position(this.curLine, this.pos - this.lineStart);\n  };\n\n  State.prototype.clone = function clone(skipArrays) {\n    var state = new State();\n    for (var key in this) {\n      var val = this[key];\n\n      if ((!skipArrays || key === \"context\") && Array.isArray(val)) {\n        val = val.slice();\n      }\n\n      state[key] = val;\n    }\n    return state;\n  };\n\n  return State;\n}();\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(state) {\n  classCallCheck(this, Token);\n\n  this.type = state.type;\n  this.value = state.value;\n  this.start = state.start;\n  this.end = state.end;\n  this.loc = new SourceLocation(state.startLoc, state.endLoc);\n};\n\n// ## Tokenizer\n\nfunction codePointToString(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) {\n    return String.fromCharCode(code);\n  } else {\n    return String.fromCharCode((code - 0x10000 >> 10) + 0xD800, (code - 0x10000 & 1023) + 0xDC00);\n  }\n}\n\nvar Tokenizer = function () {\n  function Tokenizer(options, input) {\n    classCallCheck(this, Tokenizer);\n\n    this.state = new State();\n    this.state.init(options, input);\n  }\n\n  // Move to the next token\n\n  Tokenizer.prototype.next = function next() {\n    if (!this.isLookahead) {\n      this.state.tokens.push(new Token(this.state));\n    }\n\n    this.state.lastTokEnd = this.state.end;\n    this.state.lastTokStart = this.state.start;\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  };\n\n  // TODO\n\n  Tokenizer.prototype.eat = function eat(type) {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  // TODO\n\n  Tokenizer.prototype.match = function match(type) {\n    return this.state.type === type;\n  };\n\n  // TODO\n\n  Tokenizer.prototype.isKeyword = function isKeyword$$1(word) {\n    return isKeyword(word);\n  };\n\n  // TODO\n\n  Tokenizer.prototype.lookahead = function lookahead() {\n    var old = this.state;\n    this.state = old.clone(true);\n\n    this.isLookahead = true;\n    this.next();\n    this.isLookahead = false;\n\n    var curr = this.state.clone(true);\n    this.state = old;\n    return curr;\n  };\n\n  // Toggle strict mode. Re-reads the next number or string to please\n  // pedantic tests (`\"use strict\"; 010;` should fail).\n\n  Tokenizer.prototype.setStrict = function setStrict(strict) {\n    this.state.strict = strict;\n    if (!this.match(types.num) && !this.match(types.string)) return;\n    this.state.pos = this.state.start;\n    while (this.state.pos < this.state.lineStart) {\n      this.state.lineStart = this.input.lastIndexOf(\"\\n\", this.state.lineStart - 2) + 1;\n      --this.state.curLine;\n    }\n    this.nextToken();\n  };\n\n  Tokenizer.prototype.curContext = function curContext() {\n    return this.state.context[this.state.context.length - 1];\n  };\n\n  // Read a single token, updating the parser object's token-related\n  // properties.\n\n  Tokenizer.prototype.nextToken = function nextToken() {\n    var curContext = this.curContext();\n    if (!curContext || !curContext.preserveSpace) this.skipSpace();\n\n    this.state.containsOctal = false;\n    this.state.octalPosition = null;\n    this.state.start = this.state.pos;\n    this.state.startLoc = this.state.curPosition();\n    if (this.state.pos >= this.input.length) return this.finishToken(types.eof);\n\n    if (curContext.override) {\n      return curContext.override(this);\n    } else {\n      return this.readToken(this.fullCharCodeAtPos());\n    }\n  };\n\n  Tokenizer.prototype.readToken = function readToken(code) {\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\n    // identifiers, so '\\' also dispatches to that.\n    if (isIdentifierStart(code) || code === 92 /* '\\' */) {\n        return this.readWord();\n      } else {\n      return this.getTokenFromCode(code);\n    }\n  };\n\n  Tokenizer.prototype.fullCharCodeAtPos = function fullCharCodeAtPos() {\n    var code = this.input.charCodeAt(this.state.pos);\n    if (code <= 0xd7ff || code >= 0xe000) return code;\n\n    var next = this.input.charCodeAt(this.state.pos + 1);\n    return (code << 10) + next - 0x35fdc00;\n  };\n\n  Tokenizer.prototype.pushComment = function pushComment(block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? \"CommentBlock\" : \"CommentLine\",\n      value: text,\n      start: start,\n      end: end,\n      loc: new SourceLocation(startLoc, endLoc)\n    };\n\n    if (!this.isLookahead) {\n      this.state.tokens.push(comment);\n      this.state.comments.push(comment);\n      this.addComment(comment);\n    }\n  };\n\n  Tokenizer.prototype.skipBlockComment = function skipBlockComment() {\n    var startLoc = this.state.curPosition();\n    var start = this.state.pos;\n    var end = this.input.indexOf(\"*/\", this.state.pos += 2);\n    if (end === -1) this.raise(this.state.pos - 2, \"Unterminated comment\");\n\n    this.state.pos = end + 2;\n    lineBreakG.lastIndex = start;\n    var match = void 0;\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {\n      ++this.state.curLine;\n      this.state.lineStart = match.index + match[0].length;\n    }\n\n    this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());\n  };\n\n  Tokenizer.prototype.skipLineComment = function skipLineComment(startSkip) {\n    var start = this.state.pos;\n    var startLoc = this.state.curPosition();\n    var ch = this.input.charCodeAt(this.state.pos += startSkip);\n    while (this.state.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {\n      ++this.state.pos;\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n\n    this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());\n  };\n\n  // Called at the start of the parse and after every token. Skips\n  // whitespace and comments, and.\n\n  Tokenizer.prototype.skipSpace = function skipSpace() {\n    loop: while (this.state.pos < this.input.length) {\n      var ch = this.input.charCodeAt(this.state.pos);\n      switch (ch) {\n        case 32:case 160:\n          // ' '\n          ++this.state.pos;\n          break;\n\n        case 13:\n          if (this.input.charCodeAt(this.state.pos + 1) === 10) {\n            ++this.state.pos;\n          }\n\n        case 10:case 8232:case 8233:\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n\n        case 47:\n          // '/'\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case 42:\n              // '*'\n              this.skipBlockComment();\n              break;\n\n            case 47:\n              this.skipLineComment(2);\n              break;\n\n            default:\n              break loop;\n          }\n          break;\n\n        default:\n          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n            ++this.state.pos;\n          } else {\n            break loop;\n          }\n      }\n    }\n  };\n\n  // Called at the end of every token. Sets `end`, `val`, and\n  // maintains `context` and `exprAllowed`, and skips the space after\n  // the token, so that the next one's `start` will point at the\n  // right position.\n\n  Tokenizer.prototype.finishToken = function finishToken(type, val) {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    var prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n\n    this.updateContext(prevType);\n  };\n\n  // ### Token reading\n\n  // This is the function that is called to fetch the next token. It\n  // is somewhat obscure, because it works in character codes rather\n  // than characters, and because operator parsing has been inlined\n  // into it.\n  //\n  // All in the name of speed.\n  //\n\n\n  Tokenizer.prototype.readToken_dot = function readToken_dot() {\n    var next = this.input.charCodeAt(this.state.pos + 1);\n    if (next >= 48 && next <= 57) {\n      return this.readNumber(true);\n    }\n\n    var next2 = this.input.charCodeAt(this.state.pos + 2);\n    if (next === 46 && next2 === 46) {\n      // 46 = dot '.'\n      this.state.pos += 3;\n      return this.finishToken(types.ellipsis);\n    } else {\n      ++this.state.pos;\n      return this.finishToken(types.dot);\n    }\n  };\n\n  Tokenizer.prototype.readToken_slash = function readToken_slash() {\n    // '/'\n    if (this.state.exprAllowed) {\n      ++this.state.pos;\n      return this.readRegexp();\n    }\n\n    var next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61) {\n      return this.finishOp(types.assign, 2);\n    } else {\n      return this.finishOp(types.slash, 1);\n    }\n  };\n\n  Tokenizer.prototype.readToken_mult_modulo = function readToken_mult_modulo(code) {\n    // '%*'\n    var type = code === 42 ? types.star : types.modulo;\n    var width = 1;\n    var next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 42) {\n      // '*'\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = types.exponent;\n    }\n\n    if (next === 61) {\n      width++;\n      type = types.assign;\n    }\n\n    return this.finishOp(type, width);\n  };\n\n  Tokenizer.prototype.readToken_pipe_amp = function readToken_pipe_amp(code) {\n    // '|&'\n    var next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === code) return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);\n    if (next === 61) return this.finishOp(types.assign, 2);\n    if (code === 124 && next === 125 && this.hasPlugin(\"flow\")) return this.finishOp(types.braceBarR, 2);\n    return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);\n  };\n\n  Tokenizer.prototype.readToken_caret = function readToken_caret() {\n    // '^'\n    var next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61) {\n      return this.finishOp(types.assign, 2);\n    } else {\n      return this.finishOp(types.bitwiseXOR, 1);\n    }\n  };\n\n  Tokenizer.prototype.readToken_plus_min = function readToken_plus_min(code) {\n    // '+-'\n    var next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      if (next === 45 && this.input.charCodeAt(this.state.pos + 2) === 62 && lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.pos))) {\n        // A `-->` line comment\n        this.skipLineComment(3);\n        this.skipSpace();\n        return this.nextToken();\n      }\n      return this.finishOp(types.incDec, 2);\n    }\n\n    if (next === 61) {\n      return this.finishOp(types.assign, 2);\n    } else {\n      return this.finishOp(types.plusMin, 1);\n    }\n  };\n\n  Tokenizer.prototype.readToken_lt_gt = function readToken_lt_gt(code) {\n    // '<>'\n    var next = this.input.charCodeAt(this.state.pos + 1);\n    var size = 1;\n\n    if (next === code) {\n      size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;\n      if (this.input.charCodeAt(this.state.pos + size) === 61) return this.finishOp(types.assign, size + 1);\n      return this.finishOp(types.bitShift, size);\n    }\n\n    if (next === 33 && code === 60 && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {\n      if (this.inModule) this.unexpected();\n      // `<!--`, an XML-style comment that should be interpreted as a line comment\n      this.skipLineComment(4);\n      this.skipSpace();\n      return this.nextToken();\n    }\n\n    if (next === 61) {\n      // <= | >=\n      size = 2;\n    }\n\n    return this.finishOp(types.relational, size);\n  };\n\n  Tokenizer.prototype.readToken_eq_excl = function readToken_eq_excl(code) {\n    // '=!'\n    var next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61) return this.finishOp(types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);\n    if (code === 61 && next === 62) {\n      // '=>'\n      this.state.pos += 2;\n      return this.finishToken(types.arrow);\n    }\n    return this.finishOp(code === 61 ? types.eq : types.prefix, 1);\n  };\n\n  Tokenizer.prototype.getTokenFromCode = function getTokenFromCode(code) {\n    switch (code) {\n      // The interpretation of a dot depends on whether it is followed\n      // by a digit or another two dots.\n      case 46:\n        // '.'\n        return this.readToken_dot();\n\n      // Punctuation tokens.\n      case 40:\n        ++this.state.pos;return this.finishToken(types.parenL);\n      case 41:\n        ++this.state.pos;return this.finishToken(types.parenR);\n      case 59:\n        ++this.state.pos;return this.finishToken(types.semi);\n      case 44:\n        ++this.state.pos;return this.finishToken(types.comma);\n      case 91:\n        ++this.state.pos;return this.finishToken(types.bracketL);\n      case 93:\n        ++this.state.pos;return this.finishToken(types.bracketR);\n\n      case 123:\n        if (this.hasPlugin(\"flow\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          return this.finishOp(types.braceBarL, 2);\n        } else {\n          ++this.state.pos;\n          return this.finishToken(types.braceL);\n        }\n\n      case 125:\n        ++this.state.pos;return this.finishToken(types.braceR);\n\n      case 58:\n        if (this.hasPlugin(\"functionBind\") && this.input.charCodeAt(this.state.pos + 1) === 58) {\n          return this.finishOp(types.doubleColon, 2);\n        } else {\n          ++this.state.pos;\n          return this.finishToken(types.colon);\n        }\n\n      case 63:\n        ++this.state.pos;return this.finishToken(types.question);\n      case 64:\n        ++this.state.pos;return this.finishToken(types.at);\n\n      case 96:\n        // '`'\n        ++this.state.pos;\n        return this.finishToken(types.backQuote);\n\n      case 48:\n        // '0'\n        var next = this.input.charCodeAt(this.state.pos + 1);\n        if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number\n        if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number\n        if (next === 98 || next === 66) return this.readRadixNumber(2); // '0b', '0B' - binary number\n      // Anything else beginning with a digit is an integer, octal\n      // number, or float.\n      case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:\n        // 1-9\n        return this.readNumber(false);\n\n      // Quotes produce strings.\n      case 34:case 39:\n        // '\"', \"'\"\n        return this.readString(code);\n\n      // Operators are parsed inline in tiny state machines. '=' (61) is\n      // often referred to. `finishOp` simply skips the amount of\n      // characters it is given as second argument, and returns a token\n      // of the type given by its first argument.\n\n      case 47:\n        // '/'\n        return this.readToken_slash();\n\n      case 37:case 42:\n        // '%*'\n        return this.readToken_mult_modulo(code);\n\n      case 124:case 38:\n        // '|&'\n        return this.readToken_pipe_amp(code);\n\n      case 94:\n        // '^'\n        return this.readToken_caret();\n\n      case 43:case 45:\n        // '+-'\n        return this.readToken_plus_min(code);\n\n      case 60:case 62:\n        // '<>'\n        return this.readToken_lt_gt(code);\n\n      case 61:case 33:\n        // '=!'\n        return this.readToken_eq_excl(code);\n\n      case 126:\n        // '~'\n        return this.finishOp(types.prefix, 1);\n    }\n\n    this.raise(this.state.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n  };\n\n  Tokenizer.prototype.finishOp = function finishOp(type, size) {\n    var str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    return this.finishToken(type, str);\n  };\n\n  Tokenizer.prototype.readRegexp = function readRegexp() {\n    var start = this.state.pos;\n    var escaped = void 0,\n        inClass = void 0;\n    for (;;) {\n      if (this.state.pos >= this.input.length) this.raise(start, \"Unterminated regular expression\");\n      var ch = this.input.charAt(this.state.pos);\n      if (lineBreak.test(ch)) {\n        this.raise(start, \"Unterminated regular expression\");\n      }\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === \"[\") {\n          inClass = true;\n        } else if (ch === \"]\" && inClass) {\n          inClass = false;\n        } else if (ch === \"/\" && !inClass) {\n          break;\n        }\n        escaped = ch === \"\\\\\";\n      }\n      ++this.state.pos;\n    }\n    var content = this.input.slice(start, this.state.pos);\n    ++this.state.pos;\n    // Need to use `readWord1` because '\\uXXXX' sequences are allowed\n    // here (don't ask).\n    var mods = this.readWord1();\n    if (mods) {\n      var validFlags = /^[gmsiyu]*$/;\n      if (!validFlags.test(mods)) this.raise(start, \"Invalid regular expression flag\");\n    }\n    return this.finishToken(types.regexp, {\n      pattern: content,\n      flags: mods\n    });\n  };\n\n  // Read an integer in the given radix. Return null if zero digits\n  // were read, the integer value otherwise. When `len` is given, this\n  // will return `null` unless the integer has exactly `len` digits.\n\n  Tokenizer.prototype.readInt = function readInt(radix, len) {\n    var start = this.state.pos;\n    var total = 0;\n\n    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      var code = this.input.charCodeAt(this.state.pos);\n      var val = void 0;\n      if (code >= 97) {\n        val = code - 97 + 10; // a\n      } else if (code >= 65) {\n        val = code - 65 + 10; // A\n      } else if (code >= 48 && code <= 57) {\n        val = code - 48; // 0-9\n      } else {\n        val = Infinity;\n      }\n      if (val >= radix) break;\n      ++this.state.pos;\n      total = total * radix + val;\n    }\n    if (this.state.pos === start || len != null && this.state.pos - start !== len) return null;\n\n    return total;\n  };\n\n  Tokenizer.prototype.readRadixNumber = function readRadixNumber(radix) {\n    this.state.pos += 2; // 0x\n    var val = this.readInt(radix);\n    if (val == null) this.raise(this.state.start + 2, \"Expected number in radix \" + radix);\n    if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.state.pos, \"Identifier directly after number\");\n    return this.finishToken(types.num, val);\n  };\n\n  // Read an integer, octal integer, or floating-point number.\n\n  Tokenizer.prototype.readNumber = function readNumber(startsWithDot) {\n    var start = this.state.pos;\n    var octal = this.input.charCodeAt(start) === 48; // '0'\n    var isFloat = false;\n\n    if (!startsWithDot && this.readInt(10) === null) this.raise(start, \"Invalid number\");\n    if (octal && this.state.pos == start + 1) octal = false; // number === 0\n\n    var next = this.input.charCodeAt(this.state.pos);\n    if (next === 46 && !octal) {\n      // '.'\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if ((next === 69 || next === 101) && !octal) {\n      // 'eE'\n      next = this.input.charCodeAt(++this.state.pos);\n      if (next === 43 || next === 45) ++this.state.pos; // '+-'\n      if (this.readInt(10) === null) this.raise(start, \"Invalid number\");\n      isFloat = true;\n    }\n\n    if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.state.pos, \"Identifier directly after number\");\n\n    var str = this.input.slice(start, this.state.pos);\n    var val = void 0;\n    if (isFloat) {\n      val = parseFloat(str);\n    } else if (!octal || str.length === 1) {\n      val = parseInt(str, 10);\n    } else if (this.state.strict) {\n      this.raise(start, \"Invalid number\");\n    } else if (/[89]/.test(str)) {\n      val = parseInt(str, 10);\n    } else {\n      val = parseInt(str, 8);\n    }\n    return this.finishToken(types.num, val);\n  };\n\n  // Read a string value, interpreting backslash-escapes.\n\n  Tokenizer.prototype.readCodePoint = function readCodePoint(throwOnInvalid) {\n    var ch = this.input.charCodeAt(this.state.pos);\n    var code = void 0;\n\n    if (ch === 123) {\n      // '{'\n      var codePos = ++this.state.pos;\n      code = this.readHexChar(this.input.indexOf(\"}\", this.state.pos) - this.state.pos, throwOnInvalid);\n      ++this.state.pos;\n      if (code === null) {\n        --this.state.invalidTemplateEscapePosition; // to point to the '\\'' instead of the 'u'\n      } else if (code > 0x10FFFF) {\n        if (throwOnInvalid) {\n          this.raise(codePos, \"Code point out of bounds\");\n        } else {\n          this.state.invalidTemplateEscapePosition = codePos - 2;\n          return null;\n        }\n      }\n    } else {\n      code = this.readHexChar(4, throwOnInvalid);\n    }\n    return code;\n  };\n\n  Tokenizer.prototype.readString = function readString(quote) {\n    var out = \"\",\n        chunkStart = ++this.state.pos;\n    for (;;) {\n      if (this.state.pos >= this.input.length) this.raise(this.state.start, \"Unterminated string constant\");\n      var ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n      if (ch === 92) {\n        // '\\'\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.readEscapedChar(false);\n        chunkStart = this.state.pos;\n      } else {\n        if (isNewLine(ch)) this.raise(this.state.start, \"Unterminated string constant\");\n        ++this.state.pos;\n      }\n    }\n    out += this.input.slice(chunkStart, this.state.pos++);\n    return this.finishToken(types.string, out);\n  };\n\n  // Reads template string tokens.\n\n  Tokenizer.prototype.readTmplToken = function readTmplToken() {\n    var out = \"\",\n        chunkStart = this.state.pos,\n        containsInvalid = false;\n    for (;;) {\n      if (this.state.pos >= this.input.length) this.raise(this.state.start, \"Unterminated template\");\n      var ch = this.input.charCodeAt(this.state.pos);\n      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {\n        // '`', '${'\n        if (this.state.pos === this.state.start && this.match(types.template)) {\n          if (ch === 36) {\n            this.state.pos += 2;\n            return this.finishToken(types.dollarBraceL);\n          } else {\n            ++this.state.pos;\n            return this.finishToken(types.backQuote);\n          }\n        }\n        out += this.input.slice(chunkStart, this.state.pos);\n        return this.finishToken(types.template, containsInvalid ? null : out);\n      }\n      if (ch === 92) {\n        // '\\'\n        out += this.input.slice(chunkStart, this.state.pos);\n        var escaped = this.readEscapedChar(true);\n        if (escaped === null) {\n          containsInvalid = true;\n        } else {\n          out += escaped;\n        }\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        ++this.state.pos;\n        switch (ch) {\n          case 13:\n            if (this.input.charCodeAt(this.state.pos) === 10) ++this.state.pos;\n          case 10:\n            out += \"\\n\";\n            break;\n          default:\n            out += String.fromCharCode(ch);\n            break;\n        }\n        ++this.state.curLine;\n        this.state.lineStart = this.state.pos;\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n  };\n\n  // Used to read escaped characters\n\n  Tokenizer.prototype.readEscapedChar = function readEscapedChar(inTemplate) {\n    var throwOnInvalid = !inTemplate;\n    var ch = this.input.charCodeAt(++this.state.pos);\n    ++this.state.pos;\n    switch (ch) {\n      case 110:\n        return \"\\n\"; // 'n' -> '\\n'\n      case 114:\n        return \"\\r\"; // 'r' -> '\\r'\n      case 120:\n        {\n          // 'x'\n          var code = this.readHexChar(2, throwOnInvalid);\n          return code === null ? null : String.fromCharCode(code);\n        }\n      case 117:\n        {\n          // 'u'\n          var _code = this.readCodePoint(throwOnInvalid);\n          return _code === null ? null : codePointToString(_code);\n        }\n      case 116:\n        return \"\\t\"; // 't' -> '\\t'\n      case 98:\n        return \"\\b\"; // 'b' -> '\\b'\n      case 118:\n        return \"\\x0B\"; // 'v' -> '\\u000b'\n      case 102:\n        return \"\\f\"; // 'f' -> '\\f'\n      case 13:\n        if (this.input.charCodeAt(this.state.pos) === 10) ++this.state.pos; // '\\r\\n'\n      case 10:\n        // ' \\n'\n        this.state.lineStart = this.state.pos;\n        ++this.state.curLine;\n        return \"\";\n      default:\n        if (ch >= 48 && ch <= 55) {\n          var codePos = this.state.pos - 1;\n          var octalStr = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0];\n          var octal = parseInt(octalStr, 8);\n          if (octal > 255) {\n            octalStr = octalStr.slice(0, -1);\n            octal = parseInt(octalStr, 8);\n          }\n          if (octal > 0) {\n            if (inTemplate) {\n              this.state.invalidTemplateEscapePosition = codePos;\n              return null;\n            } else if (this.state.strict) {\n              this.raise(codePos, \"Octal literal in strict mode\");\n            } else if (!this.state.containsOctal) {\n              // These properties are only used to throw an error for an octal which occurs\n              // in a directive which occurs prior to a \"use strict\" directive.\n              this.state.containsOctal = true;\n              this.state.octalPosition = codePos;\n            }\n          }\n          this.state.pos += octalStr.length - 1;\n          return String.fromCharCode(octal);\n        }\n        return String.fromCharCode(ch);\n    }\n  };\n\n  // Used to read character escape sequences ('\\x', '\\u').\n\n  Tokenizer.prototype.readHexChar = function readHexChar(len, throwOnInvalid) {\n    var codePos = this.state.pos;\n    var n = this.readInt(16, len);\n    if (n === null) {\n      if (throwOnInvalid) {\n        this.raise(codePos, \"Bad character escape sequence\");\n      } else {\n        this.state.pos = codePos - 1;\n        this.state.invalidTemplateEscapePosition = codePos - 1;\n      }\n    }\n    return n;\n  };\n\n  // Read an identifier, and return it as a string. Sets `this.state.containsEsc`\n  // to whether the word contained a '\\u' escape.\n  //\n  // Incrementally adds only escaped chars, adding other chunks as-is\n  // as a micro-optimization.\n\n  Tokenizer.prototype.readWord1 = function readWord1() {\n    this.state.containsEsc = false;\n    var word = \"\",\n        first = true,\n        chunkStart = this.state.pos;\n    while (this.state.pos < this.input.length) {\n      var ch = this.fullCharCodeAtPos();\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === 92) {\n        // \"\\\"\n        this.state.containsEsc = true;\n\n        word += this.input.slice(chunkStart, this.state.pos);\n        var escStart = this.state.pos;\n\n        if (this.input.charCodeAt(++this.state.pos) !== 117) {\n          // \"u\"\n          this.raise(this.state.pos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n        }\n\n        ++this.state.pos;\n        var esc = this.readCodePoint(true);\n        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, true)) {\n          this.raise(escStart, \"Invalid Unicode escape\");\n        }\n\n        word += codePointToString(esc);\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n      first = false;\n    }\n    return word + this.input.slice(chunkStart, this.state.pos);\n  };\n\n  // Read an identifier or keyword token. Will check for reserved\n  // words when necessary.\n\n  Tokenizer.prototype.readWord = function readWord() {\n    var word = this.readWord1();\n    var type = types.name;\n    if (!this.state.containsEsc && this.isKeyword(word)) {\n      type = keywords[word];\n    }\n    return this.finishToken(type, word);\n  };\n\n  Tokenizer.prototype.braceIsBlock = function braceIsBlock(prevType) {\n    if (prevType === types.colon) {\n      var parent = this.curContext();\n      if (parent === types$1.braceStatement || parent === types$1.braceExpression) {\n        return !parent.isExpr;\n      }\n    }\n\n    if (prevType === types._return) {\n      return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));\n    }\n\n    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR) {\n      return true;\n    }\n\n    if (prevType === types.braceL) {\n      return this.curContext() === types$1.braceStatement;\n    }\n\n    return !this.state.exprAllowed;\n  };\n\n  Tokenizer.prototype.updateContext = function updateContext(prevType) {\n    var type = this.state.type;\n    var update = void 0;\n\n    if (type.keyword && prevType === types.dot) {\n      this.state.exprAllowed = false;\n    } else if (update = type.updateContext) {\n      update.call(this, prevType);\n    } else {\n      this.state.exprAllowed = type.beforeExpr;\n    }\n  };\n\n  return Tokenizer;\n}();\n\nvar plugins = {};\nvar frozenDeprecatedWildcardPluginList = [\"jsx\", \"doExpressions\", \"objectRestSpread\", \"decorators\", \"classProperties\", \"exportExtensions\", \"asyncGenerators\", \"functionBind\", \"functionSent\", \"dynamicImport\", \"flow\"];\n\nvar Parser = function (_Tokenizer) {\n  inherits(Parser, _Tokenizer);\n\n  function Parser(options, input) {\n    classCallCheck(this, Parser);\n\n    options = getOptions(options);\n\n    var _this = possibleConstructorReturn(this, _Tokenizer.call(this, options, input));\n\n    _this.options = options;\n    _this.inModule = _this.options.sourceType === \"module\";\n    _this.input = input;\n    _this.plugins = _this.loadPlugins(_this.options.plugins);\n    _this.filename = options.sourceFilename;\n\n    // If enabled, skip leading hashbang line.\n    if (_this.state.pos === 0 && _this.input[0] === \"#\" && _this.input[1] === \"!\") {\n      _this.skipLineComment(2);\n    }\n    return _this;\n  }\n\n  Parser.prototype.isReservedWord = function isReservedWord(word) {\n    if (word === \"await\") {\n      return this.inModule;\n    } else {\n      return reservedWords[6](word);\n    }\n  };\n\n  Parser.prototype.hasPlugin = function hasPlugin(name) {\n    if (this.plugins[\"*\"] && frozenDeprecatedWildcardPluginList.indexOf(name) > -1) {\n      return true;\n    }\n\n    return !!this.plugins[name];\n  };\n\n  Parser.prototype.extend = function extend(name, f) {\n    this[name] = f(this[name]);\n  };\n\n  Parser.prototype.loadAllPlugins = function loadAllPlugins() {\n    var _this2 = this;\n\n    // ensure flow plugin loads last, also ensure estree is not loaded with *\n    var pluginNames = Object.keys(plugins).filter(function (name) {\n      return name !== \"flow\" && name !== \"estree\";\n    });\n    pluginNames.push(\"flow\");\n\n    pluginNames.forEach(function (name) {\n      var plugin = plugins[name];\n      if (plugin) plugin(_this2);\n    });\n  };\n\n  Parser.prototype.loadPlugins = function loadPlugins(pluginList) {\n    // TODO: Deprecate \"*\" option in next major version of Babylon\n    if (pluginList.indexOf(\"*\") >= 0) {\n      this.loadAllPlugins();\n\n      return { \"*\": true };\n    }\n\n    var pluginMap = {};\n\n    if (pluginList.indexOf(\"flow\") >= 0) {\n      // ensure flow plugin loads last\n      pluginList = pluginList.filter(function (plugin) {\n        return plugin !== \"flow\";\n      });\n      pluginList.push(\"flow\");\n    }\n\n    if (pluginList.indexOf(\"estree\") >= 0) {\n      // ensure estree plugin loads first\n      pluginList = pluginList.filter(function (plugin) {\n        return plugin !== \"estree\";\n      });\n      pluginList.unshift(\"estree\");\n    }\n\n    for (var _iterator = pluginList, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var name = _ref;\n\n      if (!pluginMap[name]) {\n        pluginMap[name] = true;\n\n        var plugin = plugins[name];\n        if (plugin) plugin(this);\n      }\n    }\n\n    return pluginMap;\n  };\n\n  Parser.prototype.parse = function parse() {\n    var file = this.startNode();\n    var program = this.startNode();\n    this.nextToken();\n    return this.parseTopLevel(file, program);\n  };\n\n  return Parser;\n}(Tokenizer);\n\nvar pp = Parser.prototype;\n\n// ## Parser utilities\n\n// TODO\n\npp.addExtra = function (node, key, val) {\n  if (!node) return;\n\n  var extra = node.extra = node.extra || {};\n  extra[key] = val;\n};\n\n// TODO\n\npp.isRelational = function (op) {\n  return this.match(types.relational) && this.state.value === op;\n};\n\n// TODO\n\npp.expectRelational = function (op) {\n  if (this.isRelational(op)) {\n    this.next();\n  } else {\n    this.unexpected(null, types.relational);\n  }\n};\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function (name) {\n  return this.match(types.name) && this.state.value === name;\n};\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function (name) {\n  return this.state.value === name && this.eat(types.name);\n};\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function (name, message) {\n  if (!this.eatContextual(name)) this.unexpected(null, message);\n};\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function () {\n  return this.match(types.eof) || this.match(types.braceR) || lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));\n};\n\n// TODO\n\npp.isLineTerminator = function () {\n  return this.eat(types.semi) || this.canInsertSemicolon();\n};\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function () {\n  if (!this.isLineTerminator()) this.unexpected(null, types.semi);\n};\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error at given pos.\n\npp.expect = function (type, pos) {\n  return this.eat(type) || this.unexpected(pos, type);\n};\n\n// Raise an unexpected token error. Can take the expected token type\n// instead of a message string.\n\npp.unexpected = function (pos) {\n  var messageOrType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Unexpected token\";\n\n  if (messageOrType && (typeof messageOrType === \"undefined\" ? \"undefined\" : _typeof(messageOrType)) === \"object\" && messageOrType.label) {\n    messageOrType = \"Unexpected token, expected \" + messageOrType.label;\n  }\n  this.raise(pos != null ? pos : this.state.start, messageOrType);\n};\n\n/* eslint max-len: 0 */\n\nvar pp$1 = Parser.prototype;\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$1.parseTopLevel = function (file, program) {\n  program.sourceType = this.options.sourceType;\n\n  this.parseBlockBody(program, true, true, types.eof);\n\n  file.program = this.finishNode(program, \"Program\");\n  file.comments = this.state.comments;\n  file.tokens = this.state.tokens;\n\n  return this.finishNode(file, \"File\");\n};\n\nvar loopLabel = { kind: \"loop\" };\nvar switchLabel = { kind: \"switch\" };\n\n// TODO\n\npp$1.stmtToDirective = function (stmt) {\n  var expr = stmt.expression;\n\n  var directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);\n  var directive = this.startNodeAt(stmt.start, stmt.loc.start);\n\n  var raw = this.input.slice(expr.start, expr.end);\n  var val = directiveLiteral.value = raw.slice(1, -1); // remove quotes\n\n  this.addExtra(directiveLiteral, \"raw\", raw);\n  this.addExtra(directiveLiteral, \"rawValue\", val);\n\n  directive.value = this.finishNodeAt(directiveLiteral, \"DirectiveLiteral\", expr.end, expr.loc.end);\n\n  return this.finishNodeAt(directive, \"Directive\", stmt.end, stmt.loc.end);\n};\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp$1.parseStatement = function (declaration, topLevel) {\n  if (this.match(types.at)) {\n    this.parseDecorators(true);\n  }\n\n  var starttype = this.state.type;\n  var node = this.startNode();\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n    case types._break:case types._continue:\n      return this.parseBreakContinueStatement(node, starttype.keyword);\n    case types._debugger:\n      return this.parseDebuggerStatement(node);\n    case types._do:\n      return this.parseDoStatement(node);\n    case types._for:\n      return this.parseForStatement(node);\n    case types._function:\n      if (!declaration) this.unexpected();\n      return this.parseFunctionStatement(node);\n\n    case types._class:\n      if (!declaration) this.unexpected();\n      return this.parseClass(node, true);\n\n    case types._if:\n      return this.parseIfStatement(node);\n    case types._return:\n      return this.parseReturnStatement(node);\n    case types._switch:\n      return this.parseSwitchStatement(node);\n    case types._throw:\n      return this.parseThrowStatement(node);\n    case types._try:\n      return this.parseTryStatement(node);\n\n    case types._let:\n    case types._const:\n      if (!declaration) this.unexpected(); // NOTE: falls through to _var\n\n    case types._var:\n      return this.parseVarStatement(node, starttype);\n\n    case types._while:\n      return this.parseWhileStatement(node);\n    case types._with:\n      return this.parseWithStatement(node);\n    case types.braceL:\n      return this.parseBlock();\n    case types.semi:\n      return this.parseEmptyStatement(node);\n    case types._export:\n    case types._import:\n      if (this.hasPlugin(\"dynamicImport\") && this.lookahead().type === types.parenL) break;\n\n      if (!this.options.allowImportExportEverywhere) {\n        if (!topLevel) {\n          this.raise(this.state.start, \"'import' and 'export' may only appear at the top level\");\n        }\n\n        if (!this.inModule) {\n          this.raise(this.state.start, \"'import' and 'export' may appear only with 'sourceType: \\\"module\\\"'\");\n        }\n      }\n      return starttype === types._import ? this.parseImport(node) : this.parseExport(node);\n\n    case types.name:\n      if (this.state.value === \"async\") {\n        // peek ahead and see if next token is a function\n        var state = this.state.clone();\n        this.next();\n        if (this.match(types._function) && !this.canInsertSemicolon()) {\n          this.expect(types._function);\n          return this.parseFunction(node, true, false, true);\n        } else {\n          this.state = state;\n        }\n      }\n  }\n\n  // If the statement does not start with a statement keyword or a\n  // brace, it's an ExpressionStatement or LabeledStatement. We\n  // simply start parsing an expression, and afterwards, if the\n  // next token is a colon and the expression was a simple\n  // Identifier node, we switch to interpreting it as a label.\n  var maybeName = this.state.value;\n  var expr = this.parseExpression();\n\n  if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon)) {\n    return this.parseLabeledStatement(node, maybeName, expr);\n  } else {\n    return this.parseExpressionStatement(node, expr);\n  }\n};\n\npp$1.takeDecorators = function (node) {\n  if (this.state.decorators.length) {\n    node.decorators = this.state.decorators;\n    this.state.decorators = [];\n  }\n};\n\npp$1.parseDecorators = function (allowExport) {\n  while (this.match(types.at)) {\n    var decorator = this.parseDecorator();\n    this.state.decorators.push(decorator);\n  }\n\n  if (allowExport && this.match(types._export)) {\n    return;\n  }\n\n  if (!this.match(types._class)) {\n    this.raise(this.state.start, \"Leading decorators must be attached to a class declaration\");\n  }\n};\n\npp$1.parseDecorator = function () {\n  if (!this.hasPlugin(\"decorators\")) {\n    this.unexpected();\n  }\n  var node = this.startNode();\n  this.next();\n  node.expression = this.parseMaybeAssign();\n  return this.finishNode(node, \"Decorator\");\n};\n\npp$1.parseBreakContinueStatement = function (node, keyword) {\n  var isBreak = keyword === \"break\";\n  this.next();\n\n  if (this.isLineTerminator()) {\n    node.label = null;\n  } else if (!this.match(types.name)) {\n    this.unexpected();\n  } else {\n    node.label = this.parseIdentifier();\n    this.semicolon();\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  var i = void 0;\n  for (i = 0; i < this.state.labels.length; ++i) {\n    var lab = this.state.labels[i];\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n      if (node.label && isBreak) break;\n    }\n  }\n  if (i === this.state.labels.length) this.raise(node.start, \"Unsyntactic \" + keyword);\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n};\n\npp$1.parseDebuggerStatement = function (node) {\n  this.next();\n  this.semicolon();\n  return this.finishNode(node, \"DebuggerStatement\");\n};\n\npp$1.parseDoStatement = function (node) {\n  this.next();\n  this.state.labels.push(loopLabel);\n  node.body = this.parseStatement(false);\n  this.state.labels.pop();\n  this.expect(types._while);\n  node.test = this.parseParenExpression();\n  this.eat(types.semi);\n  return this.finishNode(node, \"DoWhileStatement\");\n};\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp$1.parseForStatement = function (node) {\n  this.next();\n  this.state.labels.push(loopLabel);\n\n  var forAwait = false;\n  if (this.hasPlugin(\"asyncGenerators\") && this.state.inAsync && this.isContextual(\"await\")) {\n    forAwait = true;\n    this.next();\n  }\n  this.expect(types.parenL);\n\n  if (this.match(types.semi)) {\n    if (forAwait) {\n      this.unexpected();\n    }\n    return this.parseFor(node, null);\n  }\n\n  if (this.match(types._var) || this.match(types._let) || this.match(types._const)) {\n    var _init = this.startNode();\n    var varKind = this.state.type;\n    this.next();\n    this.parseVar(_init, true, varKind);\n    this.finishNode(_init, \"VariableDeclaration\");\n\n    if (this.match(types._in) || this.isContextual(\"of\")) {\n      if (_init.declarations.length === 1 && !_init.declarations[0].init) {\n        return this.parseForIn(node, _init, forAwait);\n      }\n    }\n    if (forAwait) {\n      this.unexpected();\n    }\n    return this.parseFor(node, _init);\n  }\n\n  var refShorthandDefaultPos = { start: 0 };\n  var init = this.parseExpression(true, refShorthandDefaultPos);\n  if (this.match(types._in) || this.isContextual(\"of\")) {\n    var description = this.isContextual(\"of\") ? \"for-of statement\" : \"for-in statement\";\n    this.toAssignable(init, undefined, description);\n    this.checkLVal(init, undefined, undefined, description);\n    return this.parseForIn(node, init, forAwait);\n  } else if (refShorthandDefaultPos.start) {\n    this.unexpected(refShorthandDefaultPos.start);\n  }\n  if (forAwait) {\n    this.unexpected();\n  }\n  return this.parseFor(node, init);\n};\n\npp$1.parseFunctionStatement = function (node) {\n  this.next();\n  return this.parseFunction(node, true);\n};\n\npp$1.parseIfStatement = function (node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  node.consequent = this.parseStatement(false);\n  node.alternate = this.eat(types._else) ? this.parseStatement(false) : null;\n  return this.finishNode(node, \"IfStatement\");\n};\n\npp$1.parseReturnStatement = function (node) {\n  if (!this.state.inFunction && !this.options.allowReturnOutsideFunction) {\n    this.raise(this.state.start, \"'return' outside of function\");\n  }\n\n  this.next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.isLineTerminator()) {\n    node.argument = null;\n  } else {\n    node.argument = this.parseExpression();\n    this.semicolon();\n  }\n\n  return this.finishNode(node, \"ReturnStatement\");\n};\n\npp$1.parseSwitchStatement = function (node) {\n  this.next();\n  node.discriminant = this.parseParenExpression();\n  node.cases = [];\n  this.expect(types.braceL);\n  this.state.labels.push(switchLabel);\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  var cur = void 0;\n  for (var sawDefault; !this.match(types.braceR);) {\n    if (this.match(types._case) || this.match(types._default)) {\n      var isCase = this.match(types._case);\n      if (cur) this.finishNode(cur, \"SwitchCase\");\n      node.cases.push(cur = this.startNode());\n      cur.consequent = [];\n      this.next();\n      if (isCase) {\n        cur.test = this.parseExpression();\n      } else {\n        if (sawDefault) this.raise(this.state.lastTokStart, \"Multiple default clauses\");\n        sawDefault = true;\n        cur.test = null;\n      }\n      this.expect(types.colon);\n    } else {\n      if (cur) {\n        cur.consequent.push(this.parseStatement(true));\n      } else {\n        this.unexpected();\n      }\n    }\n  }\n  if (cur) this.finishNode(cur, \"SwitchCase\");\n  this.next(); // Closing brace\n  this.state.labels.pop();\n  return this.finishNode(node, \"SwitchStatement\");\n};\n\npp$1.parseThrowStatement = function (node) {\n  this.next();\n  if (lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) this.raise(this.state.lastTokEnd, \"Illegal newline after throw\");\n  node.argument = this.parseExpression();\n  this.semicolon();\n  return this.finishNode(node, \"ThrowStatement\");\n};\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty = [];\n\npp$1.parseTryStatement = function (node) {\n  this.next();\n\n  node.block = this.parseBlock();\n  node.handler = null;\n\n  if (this.match(types._catch)) {\n    var clause = this.startNode();\n    this.next();\n\n    this.expect(types.parenL);\n    clause.param = this.parseBindingAtom();\n    this.checkLVal(clause.param, true, Object.create(null), \"catch clause\");\n    this.expect(types.parenR);\n\n    clause.body = this.parseBlock();\n    node.handler = this.finishNode(clause, \"CatchClause\");\n  }\n\n  node.guardedHandlers = empty;\n  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n\n  if (!node.handler && !node.finalizer) {\n    this.raise(node.start, \"Missing catch or finally clause\");\n  }\n\n  return this.finishNode(node, \"TryStatement\");\n};\n\npp$1.parseVarStatement = function (node, kind) {\n  this.next();\n  this.parseVar(node, false, kind);\n  this.semicolon();\n  return this.finishNode(node, \"VariableDeclaration\");\n};\n\npp$1.parseWhileStatement = function (node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  this.state.labels.push(loopLabel);\n  node.body = this.parseStatement(false);\n  this.state.labels.pop();\n  return this.finishNode(node, \"WhileStatement\");\n};\n\npp$1.parseWithStatement = function (node) {\n  if (this.state.strict) this.raise(this.state.start, \"'with' in strict mode\");\n  this.next();\n  node.object = this.parseParenExpression();\n  node.body = this.parseStatement(false);\n  return this.finishNode(node, \"WithStatement\");\n};\n\npp$1.parseEmptyStatement = function (node) {\n  this.next();\n  return this.finishNode(node, \"EmptyStatement\");\n};\n\npp$1.parseLabeledStatement = function (node, maybeName, expr) {\n  for (var _iterator = this.state.labels, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var _label = _ref;\n\n    if (_label.name === maybeName) {\n      this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n    }\n  }\n\n  var kind = this.state.type.isLoop ? \"loop\" : this.match(types._switch) ? \"switch\" : null;\n  for (var i = this.state.labels.length - 1; i >= 0; i--) {\n    var label = this.state.labels[i];\n    if (label.statementStart === node.start) {\n      label.statementStart = this.state.start;\n      label.kind = kind;\n    } else {\n      break;\n    }\n  }\n\n  this.state.labels.push({ name: maybeName, kind: kind, statementStart: this.state.start });\n  node.body = this.parseStatement(true);\n  this.state.labels.pop();\n  node.label = expr;\n  return this.finishNode(node, \"LabeledStatement\");\n};\n\npp$1.parseExpressionStatement = function (node, expr) {\n  node.expression = expr;\n  this.semicolon();\n  return this.finishNode(node, \"ExpressionStatement\");\n};\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp$1.parseBlock = function (allowDirectives) {\n  var node = this.startNode();\n  this.expect(types.braceL);\n  this.parseBlockBody(node, allowDirectives, false, types.braceR);\n  return this.finishNode(node, \"BlockStatement\");\n};\n\npp$1.isValidDirective = function (stmt) {\n  return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"StringLiteral\" && !stmt.expression.extra.parenthesized;\n};\n\npp$1.parseBlockBody = function (node, allowDirectives, topLevel, end) {\n  node.body = [];\n  node.directives = [];\n\n  var parsedNonDirective = false;\n  var oldStrict = void 0;\n  var octalPosition = void 0;\n\n  while (!this.eat(end)) {\n    if (!parsedNonDirective && this.state.containsOctal && !octalPosition) {\n      octalPosition = this.state.octalPosition;\n    }\n\n    var stmt = this.parseStatement(true, topLevel);\n\n    if (allowDirectives && !parsedNonDirective && this.isValidDirective(stmt)) {\n      var directive = this.stmtToDirective(stmt);\n      node.directives.push(directive);\n\n      if (oldStrict === undefined && directive.value.value === \"use strict\") {\n        oldStrict = this.state.strict;\n        this.setStrict(true);\n\n        if (octalPosition) {\n          this.raise(octalPosition, \"Octal literal in strict mode\");\n        }\n      }\n\n      continue;\n    }\n\n    parsedNonDirective = true;\n    node.body.push(stmt);\n  }\n\n  if (oldStrict === false) {\n    this.setStrict(false);\n  }\n};\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp$1.parseFor = function (node, init) {\n  node.init = init;\n  this.expect(types.semi);\n  node.test = this.match(types.semi) ? null : this.parseExpression();\n  this.expect(types.semi);\n  node.update = this.match(types.parenR) ? null : this.parseExpression();\n  this.expect(types.parenR);\n  node.body = this.parseStatement(false);\n  this.state.labels.pop();\n  return this.finishNode(node, \"ForStatement\");\n};\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp$1.parseForIn = function (node, init, forAwait) {\n  var type = void 0;\n  if (forAwait) {\n    this.eatContextual(\"of\");\n    type = \"ForAwaitStatement\";\n  } else {\n    type = this.match(types._in) ? \"ForInStatement\" : \"ForOfStatement\";\n    this.next();\n  }\n  node.left = init;\n  node.right = this.parseExpression();\n  this.expect(types.parenR);\n  node.body = this.parseStatement(false);\n  this.state.labels.pop();\n  return this.finishNode(node, type);\n};\n\n// Parse a list of variable declarations.\n\npp$1.parseVar = function (node, isFor, kind) {\n  node.declarations = [];\n  node.kind = kind.keyword;\n  for (;;) {\n    var decl = this.startNode();\n    this.parseVarHead(decl);\n    if (this.eat(types.eq)) {\n      decl.init = this.parseMaybeAssign(isFor);\n    } else if (kind === types._const && !(this.match(types._in) || this.isContextual(\"of\"))) {\n      this.unexpected();\n    } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.match(types._in) || this.isContextual(\"of\")))) {\n      this.raise(this.state.lastTokEnd, \"Complex binding patterns require an initialization value\");\n    } else {\n      decl.init = null;\n    }\n    node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n    if (!this.eat(types.comma)) break;\n  }\n  return node;\n};\n\npp$1.parseVarHead = function (decl) {\n  decl.id = this.parseBindingAtom();\n  this.checkLVal(decl.id, true, undefined, \"variable declaration\");\n};\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseFunction = function (node, isStatement, allowExpressionBody, isAsync, optionalId) {\n  var oldInMethod = this.state.inMethod;\n  this.state.inMethod = false;\n\n  this.initFunction(node, isAsync);\n\n  if (this.match(types.star)) {\n    if (node.async && !this.hasPlugin(\"asyncGenerators\")) {\n      this.unexpected();\n    } else {\n      node.generator = true;\n      this.next();\n    }\n  }\n\n  if (isStatement && !optionalId && !this.match(types.name) && !this.match(types._yield)) {\n    this.unexpected();\n  }\n\n  if (this.match(types.name) || this.match(types._yield)) {\n    node.id = this.parseBindingIdentifier();\n  }\n\n  this.parseFunctionParams(node);\n  this.parseFunctionBody(node, allowExpressionBody);\n\n  this.state.inMethod = oldInMethod;\n\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n};\n\npp$1.parseFunctionParams = function (node) {\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR);\n};\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseClass = function (node, isStatement, optionalId) {\n  this.next();\n  this.takeDecorators(node);\n  this.parseClassId(node, isStatement, optionalId);\n  this.parseClassSuper(node);\n  this.parseClassBody(node);\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n};\n\npp$1.isClassProperty = function () {\n  return this.match(types.eq) || this.match(types.semi) || this.match(types.braceR);\n};\n\npp$1.isClassMethod = function () {\n  return this.match(types.parenL);\n};\n\npp$1.isNonstaticConstructor = function (method) {\n  return !method.computed && !method.static && (method.key.name === \"constructor\" || // Identifier\n  method.key.value === \"constructor\" // Literal\n  );\n};\n\npp$1.parseClassBody = function (node) {\n  // class bodies are implicitly strict\n  var oldStrict = this.state.strict;\n  this.state.strict = true;\n\n  var hadConstructorCall = false;\n  var hadConstructor = false;\n  var decorators = [];\n  var classBody = this.startNode();\n\n  classBody.body = [];\n\n  this.expect(types.braceL);\n\n  while (!this.eat(types.braceR)) {\n    if (this.eat(types.semi)) {\n      if (decorators.length > 0) {\n        this.raise(this.state.lastTokEnd, \"Decorators must not be followed by a semicolon\");\n      }\n      continue;\n    }\n\n    if (this.match(types.at)) {\n      decorators.push(this.parseDecorator());\n      continue;\n    }\n\n    var method = this.startNode();\n\n    // steal the decorators if there are any\n    if (decorators.length) {\n      method.decorators = decorators;\n      decorators = [];\n    }\n\n    method.static = false;\n    if (this.match(types.name) && this.state.value === \"static\") {\n      var key = this.parseIdentifier(true); // eats 'static'\n      if (this.isClassMethod()) {\n        // a method named 'static'\n        method.kind = \"method\";\n        method.computed = false;\n        method.key = key;\n        this.parseClassMethod(classBody, method, false, false);\n        continue;\n      } else if (this.isClassProperty()) {\n        // a property named 'static'\n        method.computed = false;\n        method.key = key;\n        classBody.body.push(this.parseClassProperty(method));\n        continue;\n      }\n      // otherwise something static\n      method.static = true;\n    }\n\n    if (this.eat(types.star)) {\n      // a generator\n      method.kind = \"method\";\n      this.parsePropertyName(method);\n      if (this.isNonstaticConstructor(method)) {\n        this.raise(method.key.start, \"Constructor can't be a generator\");\n      }\n      if (!method.computed && method.static && (method.key.name === \"prototype\" || method.key.value === \"prototype\")) {\n        this.raise(method.key.start, \"Classes may not have static property named prototype\");\n      }\n      this.parseClassMethod(classBody, method, true, false);\n    } else {\n      var isSimple = this.match(types.name);\n      var _key = this.parsePropertyName(method);\n      if (!method.computed && method.static && (method.key.name === \"prototype\" || method.key.value === \"prototype\")) {\n        this.raise(method.key.start, \"Classes may not have static property named prototype\");\n      }\n      if (this.isClassMethod()) {\n        // a normal method\n        if (this.isNonstaticConstructor(method)) {\n          if (hadConstructor) {\n            this.raise(_key.start, \"Duplicate constructor in the same class\");\n          } else if (method.decorators) {\n            this.raise(method.start, \"You can't attach decorators to a class constructor\");\n          }\n          hadConstructor = true;\n          method.kind = \"constructor\";\n        } else {\n          method.kind = \"method\";\n        }\n        this.parseClassMethod(classBody, method, false, false);\n      } else if (this.isClassProperty()) {\n        // a normal property\n        if (this.isNonstaticConstructor(method)) {\n          this.raise(method.key.start, \"Classes may not have a non-static field named 'constructor'\");\n        }\n        classBody.body.push(this.parseClassProperty(method));\n      } else if (isSimple && _key.name === \"async\" && !this.isLineTerminator()) {\n        // an async method\n        var isGenerator = this.hasPlugin(\"asyncGenerators\") && this.eat(types.star);\n        method.kind = \"method\";\n        this.parsePropertyName(method);\n        if (this.isNonstaticConstructor(method)) {\n          this.raise(method.key.start, \"Constructor can't be an async function\");\n        }\n        this.parseClassMethod(classBody, method, isGenerator, true);\n      } else if (isSimple && (_key.name === \"get\" || _key.name === \"set\") && !(this.isLineTerminator() && this.match(types.star))) {\n        // `get\\n*` is an uninitialized property named 'get' followed by a generator.\n        // a getter or setter\n        method.kind = _key.name;\n        this.parsePropertyName(method);\n        if (this.isNonstaticConstructor(method)) {\n          this.raise(method.key.start, \"Constructor can't have get/set modifier\");\n        }\n        this.parseClassMethod(classBody, method, false, false);\n        this.checkGetterSetterParamCount(method);\n      } else if (this.hasPlugin(\"classConstructorCall\") && isSimple && _key.name === \"call\" && this.match(types.name) && this.state.value === \"constructor\") {\n        // a (deprecated) call constructor\n        if (hadConstructorCall) {\n          this.raise(method.start, \"Duplicate constructor call in the same class\");\n        } else if (method.decorators) {\n          this.raise(method.start, \"You can't attach decorators to a class constructor\");\n        }\n        hadConstructorCall = true;\n        method.kind = \"constructorCall\";\n        this.parsePropertyName(method); // consume \"constructor\" and make it the method's name\n        this.parseClassMethod(classBody, method, false, false);\n      } else if (this.isLineTerminator()) {\n        // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)\n        if (this.isNonstaticConstructor(method)) {\n          this.raise(method.key.start, \"Classes may not have a non-static field named 'constructor'\");\n        }\n        classBody.body.push(this.parseClassProperty(method));\n      } else {\n        this.unexpected();\n      }\n    }\n  }\n\n  if (decorators.length) {\n    this.raise(this.state.start, \"You have trailing decorators with no method\");\n  }\n\n  node.body = this.finishNode(classBody, \"ClassBody\");\n\n  this.state.strict = oldStrict;\n};\n\npp$1.parseClassProperty = function (node) {\n  this.state.inClassProperty = true;\n  if (this.match(types.eq)) {\n    if (!this.hasPlugin(\"classProperties\")) this.unexpected();\n    this.next();\n    node.value = this.parseMaybeAssign();\n  } else {\n    node.value = null;\n  }\n  this.semicolon();\n  this.state.inClassProperty = false;\n  return this.finishNode(node, \"ClassProperty\");\n};\n\npp$1.parseClassMethod = function (classBody, method, isGenerator, isAsync) {\n  this.parseMethod(method, isGenerator, isAsync);\n  classBody.body.push(this.finishNode(method, \"ClassMethod\"));\n};\n\npp$1.parseClassId = function (node, isStatement, optionalId) {\n  if (this.match(types.name)) {\n    node.id = this.parseIdentifier();\n  } else {\n    if (optionalId || !isStatement) {\n      node.id = null;\n    } else {\n      this.unexpected();\n    }\n  }\n};\n\npp$1.parseClassSuper = function (node) {\n  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n};\n\n// Parses module export declaration.\n\npp$1.parseExport = function (node) {\n  this.next();\n  // export * from '...'\n  if (this.match(types.star)) {\n    var specifier = this.startNode();\n    this.next();\n    if (this.hasPlugin(\"exportExtensions\") && this.eatContextual(\"as\")) {\n      specifier.exported = this.parseIdentifier();\n      node.specifiers = [this.finishNode(specifier, \"ExportNamespaceSpecifier\")];\n      this.parseExportSpecifiersMaybe(node);\n      this.parseExportFrom(node, true);\n    } else {\n      this.parseExportFrom(node, true);\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n  } else if (this.hasPlugin(\"exportExtensions\") && this.isExportDefaultSpecifier()) {\n    var _specifier = this.startNode();\n    _specifier.exported = this.parseIdentifier(true);\n    node.specifiers = [this.finishNode(_specifier, \"ExportDefaultSpecifier\")];\n    if (this.match(types.comma) && this.lookahead().type === types.star) {\n      this.expect(types.comma);\n      var _specifier2 = this.startNode();\n      this.expect(types.star);\n      this.expectContextual(\"as\");\n      _specifier2.exported = this.parseIdentifier();\n      node.specifiers.push(this.finishNode(_specifier2, \"ExportNamespaceSpecifier\"));\n    } else {\n      this.parseExportSpecifiersMaybe(node);\n    }\n    this.parseExportFrom(node, true);\n  } else if (this.eat(types._default)) {\n    // export default ...\n    var expr = this.startNode();\n    var needsSemi = false;\n    if (this.eat(types._function)) {\n      expr = this.parseFunction(expr, true, false, false, true);\n    } else if (this.match(types._class)) {\n      expr = this.parseClass(expr, true, true);\n    } else {\n      needsSemi = true;\n      expr = this.parseMaybeAssign();\n    }\n    node.declaration = expr;\n    if (needsSemi) this.semicolon();\n    this.checkExport(node, true, true);\n    return this.finishNode(node, \"ExportDefaultDeclaration\");\n  } else if (this.shouldParseExportDeclaration()) {\n    node.specifiers = [];\n    node.source = null;\n    node.declaration = this.parseExportDeclaration(node);\n  } else {\n    // export { x, y as z } [from '...']\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifiers();\n    this.parseExportFrom(node);\n  }\n  this.checkExport(node, true);\n  return this.finishNode(node, \"ExportNamedDeclaration\");\n};\n\npp$1.parseExportDeclaration = function () {\n  return this.parseStatement(true);\n};\n\npp$1.isExportDefaultSpecifier = function () {\n  if (this.match(types.name)) {\n    return this.state.value !== \"async\";\n  }\n\n  if (!this.match(types._default)) {\n    return false;\n  }\n\n  var lookahead = this.lookahead();\n  return lookahead.type === types.comma || lookahead.type === types.name && lookahead.value === \"from\";\n};\n\npp$1.parseExportSpecifiersMaybe = function (node) {\n  if (this.eat(types.comma)) {\n    node.specifiers = node.specifiers.concat(this.parseExportSpecifiers());\n  }\n};\n\npp$1.parseExportFrom = function (node, expect) {\n  if (this.eatContextual(\"from\")) {\n    node.source = this.match(types.string) ? this.parseExprAtom() : this.unexpected();\n    this.checkExport(node);\n  } else {\n    if (expect) {\n      this.unexpected();\n    } else {\n      node.source = null;\n    }\n  }\n\n  this.semicolon();\n};\n\npp$1.shouldParseExportDeclaration = function () {\n  return this.state.type.keyword === \"var\" || this.state.type.keyword === \"const\" || this.state.type.keyword === \"let\" || this.state.type.keyword === \"function\" || this.state.type.keyword === \"class\" || this.isContextual(\"async\");\n};\n\npp$1.checkExport = function (node, checkNames, isDefault) {\n  if (checkNames) {\n    // Check for duplicate exports\n    if (isDefault) {\n      // Default exports\n      this.checkDuplicateExports(node, \"default\");\n    } else if (node.specifiers && node.specifiers.length) {\n      // Named exports\n      for (var _iterator2 = node.specifiers, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n        var _ref2;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref2 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref2 = _i2.value;\n        }\n\n        var specifier = _ref2;\n\n        this.checkDuplicateExports(specifier, specifier.exported.name);\n      }\n    } else if (node.declaration) {\n      // Exported declarations\n      if (node.declaration.type === \"FunctionDeclaration\" || node.declaration.type === \"ClassDeclaration\") {\n        this.checkDuplicateExports(node, node.declaration.id.name);\n      } else if (node.declaration.type === \"VariableDeclaration\") {\n        for (var _iterator3 = node.declaration.declarations, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n          var _ref3;\n\n          if (_isArray3) {\n            if (_i3 >= _iterator3.length) break;\n            _ref3 = _iterator3[_i3++];\n          } else {\n            _i3 = _iterator3.next();\n            if (_i3.done) break;\n            _ref3 = _i3.value;\n          }\n\n          var declaration = _ref3;\n\n          this.checkDeclaration(declaration.id);\n        }\n      }\n    }\n  }\n\n  if (this.state.decorators.length) {\n    var isClass = node.declaration && (node.declaration.type === \"ClassDeclaration\" || node.declaration.type === \"ClassExpression\");\n    if (!node.declaration || !isClass) {\n      this.raise(node.start, \"You can only use decorators on an export when exporting a class\");\n    }\n    this.takeDecorators(node.declaration);\n  }\n};\n\npp$1.checkDeclaration = function (node) {\n  if (node.type === \"ObjectPattern\") {\n    for (var _iterator4 = node.properties, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\n      var _ref4;\n\n      if (_isArray4) {\n        if (_i4 >= _iterator4.length) break;\n        _ref4 = _iterator4[_i4++];\n      } else {\n        _i4 = _iterator4.next();\n        if (_i4.done) break;\n        _ref4 = _i4.value;\n      }\n\n      var prop = _ref4;\n\n      this.checkDeclaration(prop);\n    }\n  } else if (node.type === \"ArrayPattern\") {\n    for (var _iterator5 = node.elements, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {\n      var _ref5;\n\n      if (_isArray5) {\n        if (_i5 >= _iterator5.length) break;\n        _ref5 = _iterator5[_i5++];\n      } else {\n        _i5 = _iterator5.next();\n        if (_i5.done) break;\n        _ref5 = _i5.value;\n      }\n\n      var elem = _ref5;\n\n      if (elem) {\n        this.checkDeclaration(elem);\n      }\n    }\n  } else if (node.type === \"ObjectProperty\") {\n    this.checkDeclaration(node.value);\n  } else if (node.type === \"RestElement\" || node.type === \"RestProperty\") {\n    this.checkDeclaration(node.argument);\n  } else if (node.type === \"Identifier\") {\n    this.checkDuplicateExports(node, node.name);\n  }\n};\n\npp$1.checkDuplicateExports = function (node, name) {\n  if (this.state.exportedIdentifiers.indexOf(name) > -1) {\n    this.raiseDuplicateExportError(node, name);\n  }\n  this.state.exportedIdentifiers.push(name);\n};\n\npp$1.raiseDuplicateExportError = function (node, name) {\n  this.raise(node.start, name === \"default\" ? \"Only one default export allowed per module.\" : \"`\" + name + \"` has already been exported. Exported identifiers must be unique.\");\n};\n\n// Parses a comma-separated list of module exports.\n\npp$1.parseExportSpecifiers = function () {\n  var nodes = [];\n  var first = true;\n  var needsFrom = void 0;\n\n  // export { x, y as z } [from '...']\n  this.expect(types.braceL);\n\n  while (!this.eat(types.braceR)) {\n    if (first) {\n      first = false;\n    } else {\n      this.expect(types.comma);\n      if (this.eat(types.braceR)) break;\n    }\n\n    var isDefault = this.match(types._default);\n    if (isDefault && !needsFrom) needsFrom = true;\n\n    var node = this.startNode();\n    node.local = this.parseIdentifier(isDefault);\n    node.exported = this.eatContextual(\"as\") ? this.parseIdentifier(true) : node.local.__clone();\n    nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n  }\n\n  // https://github.com/ember-cli/ember-cli/pull/3739\n  if (needsFrom && !this.isContextual(\"from\")) {\n    this.unexpected();\n  }\n\n  return nodes;\n};\n\n// Parses import declaration.\n\npp$1.parseImport = function (node) {\n  this.eat(types._import);\n\n  // import '...'\n  if (this.match(types.string)) {\n    node.specifiers = [];\n    node.source = this.parseExprAtom();\n  } else {\n    node.specifiers = [];\n    this.parseImportSpecifiers(node);\n    this.expectContextual(\"from\");\n    node.source = this.match(types.string) ? this.parseExprAtom() : this.unexpected();\n  }\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\");\n};\n\n// Parses a comma-separated list of module imports.\n\npp$1.parseImportSpecifiers = function (node) {\n  var first = true;\n  if (this.match(types.name)) {\n    // import defaultObj, { x, y as z } from '...'\n    var startPos = this.state.start;\n    var startLoc = this.state.startLoc;\n    node.specifiers.push(this.parseImportSpecifierDefault(this.parseIdentifier(), startPos, startLoc));\n    if (!this.eat(types.comma)) return;\n  }\n\n  if (this.match(types.star)) {\n    var specifier = this.startNode();\n    this.next();\n    this.expectContextual(\"as\");\n    specifier.local = this.parseIdentifier();\n    this.checkLVal(specifier.local, true, undefined, \"import namespace specifier\");\n    node.specifiers.push(this.finishNode(specifier, \"ImportNamespaceSpecifier\"));\n    return;\n  }\n\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (first) {\n      first = false;\n    } else {\n      // Detect an attempt to deep destructure\n      if (this.eat(types.colon)) {\n        this.unexpected(null, \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\");\n      }\n\n      this.expect(types.comma);\n      if (this.eat(types.braceR)) break;\n    }\n\n    this.parseImportSpecifier(node);\n  }\n};\n\npp$1.parseImportSpecifier = function (node) {\n  var specifier = this.startNode();\n  specifier.imported = this.parseIdentifier(true);\n  if (this.eatContextual(\"as\")) {\n    specifier.local = this.parseIdentifier();\n  } else {\n    this.checkReservedWord(specifier.imported.name, specifier.start, true, true);\n    specifier.local = specifier.imported.__clone();\n  }\n  this.checkLVal(specifier.local, true, undefined, \"import specifier\");\n  node.specifiers.push(this.finishNode(specifier, \"ImportSpecifier\"));\n};\n\npp$1.parseImportSpecifierDefault = function (id, startPos, startLoc) {\n  var node = this.startNodeAt(startPos, startLoc);\n  node.local = id;\n  this.checkLVal(node.local, true, undefined, \"default import specifier\");\n  return this.finishNode(node, \"ImportDefaultSpecifier\");\n};\n\nvar pp$2 = Parser.prototype;\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp$2.toAssignable = function (node, isBinding, contextDescription) {\n  if (node) {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n        break;\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n        for (var _iterator = node.properties, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n          var _ref;\n\n          if (_isArray) {\n            if (_i >= _iterator.length) break;\n            _ref = _iterator[_i++];\n          } else {\n            _i = _iterator.next();\n            if (_i.done) break;\n            _ref = _i.value;\n          }\n\n          var prop = _ref;\n\n          if (prop.type === \"ObjectMethod\") {\n            if (prop.kind === \"get\" || prop.kind === \"set\") {\n              this.raise(prop.key.start, \"Object pattern can't contain getter or setter\");\n            } else {\n              this.raise(prop.key.start, \"Object pattern can't contain methods\");\n            }\n          } else {\n            this.toAssignable(prop, isBinding, \"object destructuring pattern\");\n          }\n        }\n        break;\n\n      case \"ObjectProperty\":\n        this.toAssignable(node.value, isBinding, contextDescription);\n        break;\n\n      case \"SpreadProperty\":\n        node.type = \"RestProperty\";\n        var arg = node.argument;\n        this.toAssignable(arg, isBinding, contextDescription);\n        break;\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        this.toAssignableList(node.elements, isBinding, contextDescription);\n        break;\n\n      case \"AssignmentExpression\":\n        if (node.operator === \"=\") {\n          node.type = \"AssignmentPattern\";\n          delete node.operator;\n        } else {\n          this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\");\n        }\n        break;\n\n      case \"MemberExpression\":\n        if (!isBinding) break;\n\n      default:\n        {\n          var message = \"Invalid left-hand side\" + (contextDescription ? \" in \" + contextDescription : /* istanbul ignore next */\"expression\");\n          this.raise(node.start, message);\n        }\n    }\n  }\n  return node;\n};\n\n// Convert list of expression atoms to binding list.\n\npp$2.toAssignableList = function (exprList, isBinding, contextDescription) {\n  var end = exprList.length;\n  if (end) {\n    var last = exprList[end - 1];\n    if (last && last.type === \"RestElement\") {\n      --end;\n    } else if (last && last.type === \"SpreadElement\") {\n      last.type = \"RestElement\";\n      var arg = last.argument;\n      this.toAssignable(arg, isBinding, contextDescription);\n      if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\") {\n        this.unexpected(arg.start);\n      }\n      --end;\n    }\n  }\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i];\n    if (elt) this.toAssignable(elt, isBinding, contextDescription);\n  }\n  return exprList;\n};\n\n// Convert list of expression atoms to a list of\n\npp$2.toReferencedList = function (exprList) {\n  return exprList;\n};\n\n// Parses spread element.\n\npp$2.parseSpread = function (refShorthandDefaultPos) {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeAssign(false, refShorthandDefaultPos);\n  return this.finishNode(node, \"SpreadElement\");\n};\n\npp$2.parseRest = function () {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseBindingIdentifier();\n  return this.finishNode(node, \"RestElement\");\n};\n\npp$2.shouldAllowYieldIdentifier = function () {\n  return this.match(types._yield) && !this.state.strict && !this.state.inGenerator;\n};\n\npp$2.parseBindingIdentifier = function () {\n  return this.parseIdentifier(this.shouldAllowYieldIdentifier());\n};\n\n// Parses lvalue (assignable) atom.\n\npp$2.parseBindingAtom = function () {\n  switch (this.state.type) {\n    case types._yield:\n      if (this.state.strict || this.state.inGenerator) this.unexpected();\n    // fall-through\n    case types.name:\n      return this.parseIdentifier(true);\n\n    case types.bracketL:\n      var node = this.startNode();\n      this.next();\n      node.elements = this.parseBindingList(types.bracketR, true);\n      return this.finishNode(node, \"ArrayPattern\");\n\n    case types.braceL:\n      return this.parseObj(true);\n\n    default:\n      this.unexpected();\n  }\n};\n\npp$2.parseBindingList = function (close, allowEmpty) {\n  var elts = [];\n  var first = true;\n  while (!this.eat(close)) {\n    if (first) {\n      first = false;\n    } else {\n      this.expect(types.comma);\n    }\n    if (allowEmpty && this.match(types.comma)) {\n      elts.push(null);\n    } else if (this.eat(close)) {\n      break;\n    } else if (this.match(types.ellipsis)) {\n      elts.push(this.parseAssignableListItemTypes(this.parseRest()));\n      this.expect(close);\n      break;\n    } else {\n      var decorators = [];\n      while (this.match(types.at)) {\n        decorators.push(this.parseDecorator());\n      }\n      var left = this.parseMaybeDefault();\n      if (decorators.length) {\n        left.decorators = decorators;\n      }\n      this.parseAssignableListItemTypes(left);\n      elts.push(this.parseMaybeDefault(left.start, left.loc.start, left));\n    }\n  }\n  return elts;\n};\n\npp$2.parseAssignableListItemTypes = function (param) {\n  return param;\n};\n\n// Parses assignment pattern around given atom if possible.\n\npp$2.parseMaybeDefault = function (startPos, startLoc, left) {\n  startLoc = startLoc || this.state.startLoc;\n  startPos = startPos || this.state.start;\n  left = left || this.parseBindingAtom();\n  if (!this.eat(types.eq)) return left;\n\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.right = this.parseMaybeAssign();\n  return this.finishNode(node, \"AssignmentPattern\");\n};\n\n// Verify that a node is an lval  something that can be assigned\n// to.\n\npp$2.checkLVal = function (expr, isBinding, checkClashes, contextDescription) {\n  switch (expr.type) {\n    case \"Identifier\":\n      this.checkReservedWord(expr.name, expr.start, false, true);\n\n      if (checkClashes) {\n        // we need to prefix this with an underscore for the cases where we have a key of\n        // `__proto__`. there's a bug in old V8 where the following wouldn't work:\n        //\n        //   > var obj = Object.create(null);\n        //   undefined\n        //   > obj.__proto__\n        //   null\n        //   > obj.__proto__ = true;\n        //   true\n        //   > obj.__proto__\n        //   null\n        var key = \"_\" + expr.name;\n\n        if (checkClashes[key]) {\n          this.raise(expr.start, \"Argument name clash in strict mode\");\n        } else {\n          checkClashes[key] = true;\n        }\n      }\n      break;\n\n    case \"MemberExpression\":\n      if (isBinding) this.raise(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" member expression\");\n      break;\n\n    case \"ObjectPattern\":\n      for (var _iterator2 = expr.properties, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n        var _ref2;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref2 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref2 = _i2.value;\n        }\n\n        var prop = _ref2;\n\n        if (prop.type === \"ObjectProperty\") prop = prop.value;\n        this.checkLVal(prop, isBinding, checkClashes, \"object destructuring pattern\");\n      }\n      break;\n\n    case \"ArrayPattern\":\n      for (var _iterator3 = expr.elements, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n        var _ref3;\n\n        if (_isArray3) {\n          if (_i3 >= _iterator3.length) break;\n          _ref3 = _iterator3[_i3++];\n        } else {\n          _i3 = _iterator3.next();\n          if (_i3.done) break;\n          _ref3 = _i3.value;\n        }\n\n        var elem = _ref3;\n\n        if (elem) this.checkLVal(elem, isBinding, checkClashes, \"array destructuring pattern\");\n      }\n      break;\n\n    case \"AssignmentPattern\":\n      this.checkLVal(expr.left, isBinding, checkClashes, \"assignment pattern\");\n      break;\n\n    case \"RestProperty\":\n      this.checkLVal(expr.argument, isBinding, checkClashes, \"rest property\");\n      break;\n\n    case \"RestElement\":\n      this.checkLVal(expr.argument, isBinding, checkClashes, \"rest element\");\n      break;\n\n    default:\n      {\n        var message = (isBinding ? /* istanbul ignore next */\"Binding invalid\" : \"Invalid\") + \" left-hand side\" + (contextDescription ? \" in \" + contextDescription : /* istanbul ignore next */\"expression\");\n        this.raise(expr.start, message);\n      }\n  }\n};\n\n/* eslint max-len: 0 */\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts  that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nvar pp$3 = Parser.prototype;\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash \n// either with each other or with an init property  and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$3.checkPropClash = function (prop, propHash) {\n  if (prop.computed || prop.kind) return;\n\n  var key = prop.key;\n  // It is either an Identifier or a String/NumericLiteral\n  var name = key.type === \"Identifier\" ? key.name : String(key.value);\n\n  if (name === \"__proto__\") {\n    if (propHash.proto) this.raise(key.start, \"Redefinition of __proto__ property\");\n    propHash.proto = true;\n  }\n};\n\n// Convenience method to parse an Expression only\npp$3.getExpression = function () {\n  this.nextToken();\n  var expr = this.parseExpression();\n  if (!this.match(types.eof)) {\n    this.unexpected();\n  }\n  return expr;\n};\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function (s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initialization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp$3.parseExpression = function (noIn, refShorthandDefaultPos) {\n  var startPos = this.state.start;\n  var startLoc = this.state.startLoc;\n  var expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);\n  if (this.match(types.comma)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.expressions = [expr];\n    while (this.eat(types.comma)) {\n      node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos));\n    }\n    this.toReferencedList(node.expressions);\n    return this.finishNode(node, \"SequenceExpression\");\n  }\n  return expr;\n};\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp$3.parseMaybeAssign = function (noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {\n  var startPos = this.state.start;\n  var startLoc = this.state.startLoc;\n\n  if (this.match(types._yield) && this.state.inGenerator) {\n    var _left = this.parseYield();\n    if (afterLeftParse) _left = afterLeftParse.call(this, _left, startPos, startLoc);\n    return _left;\n  }\n\n  var failOnShorthandAssign = void 0;\n  if (refShorthandDefaultPos) {\n    failOnShorthandAssign = false;\n  } else {\n    refShorthandDefaultPos = { start: 0 };\n    failOnShorthandAssign = true;\n  }\n\n  if (this.match(types.parenL) || this.match(types.name)) {\n    this.state.potentialArrowAt = this.state.start;\n  }\n\n  var left = this.parseMaybeConditional(noIn, refShorthandDefaultPos, refNeedsArrowPos);\n  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);\n  if (this.state.type.isAssign) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.operator = this.state.value;\n    node.left = this.match(types.eq) ? this.toAssignable(left, undefined, \"assignment expression\") : left;\n    refShorthandDefaultPos.start = 0; // reset because shorthand default was used correctly\n\n    this.checkLVal(left, undefined, undefined, \"assignment expression\");\n\n    if (left.extra && left.extra.parenthesized) {\n      var errorMsg = void 0;\n      if (left.type === \"ObjectPattern\") {\n        errorMsg = \"`({a}) = 0` use `({a} = 0)`\";\n      } else if (left.type === \"ArrayPattern\") {\n        errorMsg = \"`([a]) = 0` use `([a] = 0)`\";\n      }\n      if (errorMsg) {\n        this.raise(left.start, \"You're trying to assign to a parenthesized expression, eg. instead of \" + errorMsg);\n      }\n    }\n\n    this.next();\n    node.right = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"AssignmentExpression\");\n  } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {\n    this.unexpected(refShorthandDefaultPos.start);\n  }\n\n  return left;\n};\n\n// Parse a ternary conditional (`?:`) operator.\n\npp$3.parseMaybeConditional = function (noIn, refShorthandDefaultPos, refNeedsArrowPos) {\n  var startPos = this.state.start;\n  var startLoc = this.state.startLoc;\n  var expr = this.parseExprOps(noIn, refShorthandDefaultPos);\n  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;\n\n  return this.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);\n};\n\npp$3.parseConditional = function (expr, noIn, startPos, startLoc) {\n  if (this.eat(types.question)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    this.expect(types.colon);\n    node.alternate = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"ConditionalExpression\");\n  }\n  return expr;\n};\n\n// Start the precedence parser.\n\npp$3.parseExprOps = function (noIn, refShorthandDefaultPos) {\n  var startPos = this.state.start;\n  var startLoc = this.state.startLoc;\n  var expr = this.parseMaybeUnary(refShorthandDefaultPos);\n  if (refShorthandDefaultPos && refShorthandDefaultPos.start) {\n    return expr;\n  } else {\n    return this.parseExprOp(expr, startPos, startLoc, -1, noIn);\n  }\n};\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp$3.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  var prec = this.state.type.binop;\n  if (prec != null && (!noIn || !this.match(types._in))) {\n    if (prec > minPrec) {\n      var node = this.startNodeAt(leftStartPos, leftStartLoc);\n      node.left = left;\n      node.operator = this.state.value;\n\n      if (node.operator === \"**\" && left.type === \"UnaryExpression\" && left.extra && !left.extra.parenthesizedArgument && !left.extra.parenthesized) {\n        this.raise(left.argument.start, \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\");\n      }\n\n      var op = this.state.type;\n      this.next();\n\n      var startPos = this.state.start;\n      var startLoc = this.state.startLoc;\n      node.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec, noIn);\n\n      this.finishNode(node, op === types.logicalOR || op === types.logicalAND ? \"LogicalExpression\" : \"BinaryExpression\");\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);\n    }\n  }\n  return left;\n};\n\n// Parse unary operators, both prefix and postfix.\n\npp$3.parseMaybeUnary = function (refShorthandDefaultPos) {\n  if (this.state.type.prefix) {\n    var node = this.startNode();\n    var update = this.match(types.incDec);\n    node.operator = this.state.value;\n    node.prefix = true;\n    this.next();\n\n    var argType = this.state.type;\n    node.argument = this.parseMaybeUnary();\n\n    this.addExtra(node, \"parenthesizedArgument\", argType === types.parenL && (!node.argument.extra || !node.argument.extra.parenthesized));\n\n    if (refShorthandDefaultPos && refShorthandDefaultPos.start) {\n      this.unexpected(refShorthandDefaultPos.start);\n    }\n\n    if (update) {\n      this.checkLVal(node.argument, undefined, undefined, \"prefix operation\");\n    } else if (this.state.strict && node.operator === \"delete\" && node.argument.type === \"Identifier\") {\n      this.raise(node.start, \"Deleting local variable in strict mode\");\n    }\n\n    return this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  }\n\n  var startPos = this.state.start;\n  var startLoc = this.state.startLoc;\n  var expr = this.parseExprSubscripts(refShorthandDefaultPos);\n  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;\n  while (this.state.type.postfix && !this.canInsertSemicolon()) {\n    var _node = this.startNodeAt(startPos, startLoc);\n    _node.operator = this.state.value;\n    _node.prefix = false;\n    _node.argument = expr;\n    this.checkLVal(expr, undefined, undefined, \"postfix operation\");\n    this.next();\n    expr = this.finishNode(_node, \"UpdateExpression\");\n  }\n  return expr;\n};\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp$3.parseExprSubscripts = function (refShorthandDefaultPos) {\n  var startPos = this.state.start;\n  var startLoc = this.state.startLoc;\n  var potentialArrowAt = this.state.potentialArrowAt;\n  var expr = this.parseExprAtom(refShorthandDefaultPos);\n\n  if (expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt) {\n    return expr;\n  }\n\n  if (refShorthandDefaultPos && refShorthandDefaultPos.start) {\n    return expr;\n  }\n\n  return this.parseSubscripts(expr, startPos, startLoc);\n};\n\npp$3.parseSubscripts = function (base, startPos, startLoc, noCalls) {\n  for (;;) {\n    if (!noCalls && this.eat(types.doubleColon)) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.callee = this.parseNoCallExpr();\n      return this.parseSubscripts(this.finishNode(node, \"BindExpression\"), startPos, startLoc, noCalls);\n    } else if (this.eat(types.dot)) {\n      var _node2 = this.startNodeAt(startPos, startLoc);\n      _node2.object = base;\n      _node2.property = this.parseIdentifier(true);\n      _node2.computed = false;\n      base = this.finishNode(_node2, \"MemberExpression\");\n    } else if (this.eat(types.bracketL)) {\n      var _node3 = this.startNodeAt(startPos, startLoc);\n      _node3.object = base;\n      _node3.property = this.parseExpression();\n      _node3.computed = true;\n      this.expect(types.bracketR);\n      base = this.finishNode(_node3, \"MemberExpression\");\n    } else if (!noCalls && this.match(types.parenL)) {\n      var possibleAsync = this.state.potentialArrowAt === base.start && base.type === \"Identifier\" && base.name === \"async\" && !this.canInsertSemicolon();\n      this.next();\n\n      var _node4 = this.startNodeAt(startPos, startLoc);\n      _node4.callee = base;\n      _node4.arguments = this.parseCallExpressionArguments(types.parenR, possibleAsync);\n      if (_node4.callee.type === \"Import\" && _node4.arguments.length !== 1) {\n        this.raise(_node4.start, \"import() requires exactly one argument\");\n      }\n      base = this.finishNode(_node4, \"CallExpression\");\n\n      if (possibleAsync && this.shouldParseAsyncArrow()) {\n        return this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), _node4);\n      } else {\n        this.toReferencedList(_node4.arguments);\n      }\n    } else if (this.match(types.backQuote)) {\n      var _node5 = this.startNodeAt(startPos, startLoc);\n      _node5.tag = base;\n      _node5.quasi = this.parseTemplate(true);\n      base = this.finishNode(_node5, \"TaggedTemplateExpression\");\n    } else {\n      return base;\n    }\n  }\n};\n\npp$3.parseCallExpressionArguments = function (close, possibleAsyncArrow) {\n  var elts = [];\n  var innerParenStart = void 0;\n  var first = true;\n\n  while (!this.eat(close)) {\n    if (first) {\n      first = false;\n    } else {\n      this.expect(types.comma);\n      if (this.eat(close)) break;\n    }\n\n    // we need to make sure that if this is an async arrow functions, that we don't allow inner parens inside the params\n    if (this.match(types.parenL) && !innerParenStart) {\n      innerParenStart = this.state.start;\n    }\n\n    elts.push(this.parseExprListItem(false, possibleAsyncArrow ? { start: 0 } : undefined, possibleAsyncArrow ? { start: 0 } : undefined));\n  }\n\n  // we found an async arrow function so let's not allow any inner parens\n  if (possibleAsyncArrow && innerParenStart && this.shouldParseAsyncArrow()) {\n    this.unexpected();\n  }\n\n  return elts;\n};\n\npp$3.shouldParseAsyncArrow = function () {\n  return this.match(types.arrow);\n};\n\npp$3.parseAsyncArrowFromCallExpression = function (node, call) {\n  this.expect(types.arrow);\n  return this.parseArrowExpression(node, call.arguments, true);\n};\n\n// Parse a no-call expression (like argument of `new` or `::` operators).\n\npp$3.parseNoCallExpr = function () {\n  var startPos = this.state.start;\n  var startLoc = this.state.startLoc;\n  return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n};\n\n// Parse an atomic expression  either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp$3.parseExprAtom = function (refShorthandDefaultPos) {\n  var canBeArrow = this.state.potentialArrowAt === this.state.start;\n  var node = void 0;\n\n  switch (this.state.type) {\n    case types._super:\n      if (!this.state.inMethod && !this.state.inClassProperty && !this.options.allowSuperOutsideMethod) {\n        this.raise(this.state.start, \"'super' outside of function or class\");\n      }\n\n      node = this.startNode();\n      this.next();\n      if (!this.match(types.parenL) && !this.match(types.bracketL) && !this.match(types.dot)) {\n        this.unexpected();\n      }\n      if (this.match(types.parenL) && this.state.inMethod !== \"constructor\" && !this.options.allowSuperOutsideMethod) {\n        this.raise(node.start, \"super() outside of class constructor\");\n      }\n      return this.finishNode(node, \"Super\");\n\n    case types._import:\n      if (!this.hasPlugin(\"dynamicImport\")) this.unexpected();\n\n      node = this.startNode();\n      this.next();\n      if (!this.match(types.parenL)) {\n        this.unexpected(null, types.parenL);\n      }\n      return this.finishNode(node, \"Import\");\n\n    case types._this:\n      node = this.startNode();\n      this.next();\n      return this.finishNode(node, \"ThisExpression\");\n\n    case types._yield:\n      if (this.state.inGenerator) this.unexpected();\n\n    case types.name:\n      node = this.startNode();\n      var allowAwait = this.state.value === \"await\" && this.state.inAsync;\n      var allowYield = this.shouldAllowYieldIdentifier();\n      var id = this.parseIdentifier(allowAwait || allowYield);\n\n      if (id.name === \"await\") {\n        if (this.state.inAsync || this.inModule) {\n          return this.parseAwait(node);\n        }\n      } else if (id.name === \"async\" && this.match(types._function) && !this.canInsertSemicolon()) {\n        this.next();\n        return this.parseFunction(node, false, false, true);\n      } else if (canBeArrow && id.name === \"async\" && this.match(types.name)) {\n        var params = [this.parseIdentifier()];\n        this.expect(types.arrow);\n        // let foo = bar => {};\n        return this.parseArrowExpression(node, params, true);\n      }\n\n      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n        return this.parseArrowExpression(node, [id]);\n      }\n\n      return id;\n\n    case types._do:\n      if (this.hasPlugin(\"doExpressions\")) {\n        var _node6 = this.startNode();\n        this.next();\n        var oldInFunction = this.state.inFunction;\n        var oldLabels = this.state.labels;\n        this.state.labels = [];\n        this.state.inFunction = false;\n        _node6.body = this.parseBlock(false, true);\n        this.state.inFunction = oldInFunction;\n        this.state.labels = oldLabels;\n        return this.finishNode(_node6, \"DoExpression\");\n      }\n\n    case types.regexp:\n      var value = this.state.value;\n      node = this.parseLiteral(value.value, \"RegExpLiteral\");\n      node.pattern = value.pattern;\n      node.flags = value.flags;\n      return node;\n\n    case types.num:\n      return this.parseLiteral(this.state.value, \"NumericLiteral\");\n\n    case types.string:\n      return this.parseLiteral(this.state.value, \"StringLiteral\");\n\n    case types._null:\n      node = this.startNode();\n      this.next();\n      return this.finishNode(node, \"NullLiteral\");\n\n    case types._true:case types._false:\n      node = this.startNode();\n      node.value = this.match(types._true);\n      this.next();\n      return this.finishNode(node, \"BooleanLiteral\");\n\n    case types.parenL:\n      return this.parseParenAndDistinguishExpression(null, null, canBeArrow);\n\n    case types.bracketL:\n      node = this.startNode();\n      this.next();\n      node.elements = this.parseExprList(types.bracketR, true, refShorthandDefaultPos);\n      this.toReferencedList(node.elements);\n      return this.finishNode(node, \"ArrayExpression\");\n\n    case types.braceL:\n      return this.parseObj(false, refShorthandDefaultPos);\n\n    case types._function:\n      return this.parseFunctionExpression();\n\n    case types.at:\n      this.parseDecorators();\n\n    case types._class:\n      node = this.startNode();\n      this.takeDecorators(node);\n      return this.parseClass(node, false);\n\n    case types._new:\n      return this.parseNew();\n\n    case types.backQuote:\n      return this.parseTemplate(false);\n\n    case types.doubleColon:\n      node = this.startNode();\n      this.next();\n      node.object = null;\n      var callee = node.callee = this.parseNoCallExpr();\n      if (callee.type === \"MemberExpression\") {\n        return this.finishNode(node, \"BindExpression\");\n      } else {\n        this.raise(callee.start, \"Binding should be performed on object property.\");\n      }\n\n    default:\n      this.unexpected();\n  }\n};\n\npp$3.parseFunctionExpression = function () {\n  var node = this.startNode();\n  var meta = this.parseIdentifier(true);\n  if (this.state.inGenerator && this.eat(types.dot) && this.hasPlugin(\"functionSent\")) {\n    return this.parseMetaProperty(node, meta, \"sent\");\n  } else {\n    return this.parseFunction(node, false);\n  }\n};\n\npp$3.parseMetaProperty = function (node, meta, propertyName) {\n  node.meta = meta;\n  node.property = this.parseIdentifier(true);\n\n  if (node.property.name !== propertyName) {\n    this.raise(node.property.start, \"The only valid meta property for new is \" + meta.name + \".\" + propertyName);\n  }\n\n  return this.finishNode(node, \"MetaProperty\");\n};\n\npp$3.parseLiteral = function (value, type, startPos, startLoc) {\n  startPos = startPos || this.state.start;\n  startLoc = startLoc || this.state.startLoc;\n\n  var node = this.startNodeAt(startPos, startLoc);\n  this.addExtra(node, \"rawValue\", value);\n  this.addExtra(node, \"raw\", this.input.slice(startPos, this.state.end));\n  node.value = value;\n  this.next();\n  return this.finishNode(node, type);\n};\n\npp$3.parseParenExpression = function () {\n  this.expect(types.parenL);\n  var val = this.parseExpression();\n  this.expect(types.parenR);\n  return val;\n};\n\npp$3.parseParenAndDistinguishExpression = function (startPos, startLoc, canBeArrow) {\n  startPos = startPos || this.state.start;\n  startLoc = startLoc || this.state.startLoc;\n\n  var val = void 0;\n  this.expect(types.parenL);\n\n  var innerStartPos = this.state.start;\n  var innerStartLoc = this.state.startLoc;\n  var exprList = [];\n  var refShorthandDefaultPos = { start: 0 };\n  var refNeedsArrowPos = { start: 0 };\n  var first = true;\n  var spreadStart = void 0;\n  var optionalCommaStart = void 0;\n\n  while (!this.match(types.parenR)) {\n    if (first) {\n      first = false;\n    } else {\n      this.expect(types.comma, refNeedsArrowPos.start || null);\n      if (this.match(types.parenR)) {\n        optionalCommaStart = this.state.start;\n        break;\n      }\n    }\n\n    if (this.match(types.ellipsis)) {\n      var spreadNodeStartPos = this.state.start;\n      var spreadNodeStartLoc = this.state.startLoc;\n      spreadStart = this.state.start;\n      exprList.push(this.parseParenItem(this.parseRest(), spreadNodeStartPos, spreadNodeStartLoc));\n      break;\n    } else {\n      exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos));\n    }\n  }\n\n  var innerEndPos = this.state.start;\n  var innerEndLoc = this.state.startLoc;\n  this.expect(types.parenR);\n\n  var arrowNode = this.startNodeAt(startPos, startLoc);\n  if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {\n    for (var _iterator = exprList, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var param = _ref;\n\n      if (param.extra && param.extra.parenthesized) this.unexpected(param.extra.parenStart);\n    }\n\n    return this.parseArrowExpression(arrowNode, exprList);\n  }\n\n  if (!exprList.length) {\n    this.unexpected(this.state.lastTokStart);\n  }\n  if (optionalCommaStart) this.unexpected(optionalCommaStart);\n  if (spreadStart) this.unexpected(spreadStart);\n  if (refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start);\n  if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);\n\n  if (exprList.length > 1) {\n    val = this.startNodeAt(innerStartPos, innerStartLoc);\n    val.expressions = exprList;\n    this.toReferencedList(val.expressions);\n    this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n  } else {\n    val = exprList[0];\n  }\n\n  this.addExtra(val, \"parenthesized\", true);\n  this.addExtra(val, \"parenStart\", startPos);\n\n  return val;\n};\n\npp$3.shouldParseArrow = function () {\n  return !this.canInsertSemicolon();\n};\n\npp$3.parseArrow = function (node) {\n  if (this.eat(types.arrow)) {\n    return node;\n  }\n};\n\npp$3.parseParenItem = function (node) {\n  return node;\n};\n\n// New's precedence is slightly tricky. It must allow its argument\n// to be a `[]` or dot subscript expression, but not a call  at\n// least, not without wrapping it in parentheses. Thus, it uses the\n\npp$3.parseNew = function () {\n  var node = this.startNode();\n  var meta = this.parseIdentifier(true);\n\n  if (this.eat(types.dot)) {\n    var metaProp = this.parseMetaProperty(node, meta, \"target\");\n\n    if (!this.state.inFunction) {\n      this.raise(metaProp.property.start, \"new.target can only be used in functions\");\n    }\n\n    return metaProp;\n  }\n\n  node.callee = this.parseNoCallExpr();\n\n  if (this.eat(types.parenL)) {\n    node.arguments = this.parseExprList(types.parenR);\n    this.toReferencedList(node.arguments);\n  } else {\n    node.arguments = [];\n  }\n\n  return this.finishNode(node, \"NewExpression\");\n};\n\n// Parse template expression.\n\npp$3.parseTemplateElement = function (isTagged) {\n  var elem = this.startNode();\n  if (this.state.value === null) {\n    if (!isTagged || !this.hasPlugin(\"templateInvalidEscapes\")) {\n      this.raise(this.state.invalidTemplateEscapePosition, \"Invalid escape sequence in template\");\n    } else {\n      this.state.invalidTemplateEscapePosition = null;\n    }\n  }\n  elem.value = {\n    raw: this.input.slice(this.state.start, this.state.end).replace(/\\r\\n?/g, \"\\n\"),\n    cooked: this.state.value\n  };\n  this.next();\n  elem.tail = this.match(types.backQuote);\n  return this.finishNode(elem, \"TemplateElement\");\n};\n\npp$3.parseTemplate = function (isTagged) {\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement(isTagged);\n  node.quasis = [curElt];\n  while (!curElt.tail) {\n    this.expect(types.dollarBraceL);\n    node.expressions.push(this.parseExpression());\n    this.expect(types.braceR);\n    node.quasis.push(curElt = this.parseTemplateElement(isTagged));\n  }\n  this.next();\n  return this.finishNode(node, \"TemplateLiteral\");\n};\n\n// Parse an object literal or binding pattern.\n\npp$3.parseObj = function (isPattern, refShorthandDefaultPos) {\n  var decorators = [];\n  var propHash = Object.create(null);\n  var first = true;\n  var node = this.startNode();\n\n  node.properties = [];\n  this.next();\n\n  var firstRestLocation = null;\n\n  while (!this.eat(types.braceR)) {\n    if (first) {\n      first = false;\n    } else {\n      this.expect(types.comma);\n      if (this.eat(types.braceR)) break;\n    }\n\n    while (this.match(types.at)) {\n      decorators.push(this.parseDecorator());\n    }\n\n    var prop = this.startNode(),\n        isGenerator = false,\n        isAsync = false,\n        startPos = void 0,\n        startLoc = void 0;\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n\n    if (this.hasPlugin(\"objectRestSpread\") && this.match(types.ellipsis)) {\n      prop = this.parseSpread(isPattern ? { start: 0 } : undefined);\n      prop.type = isPattern ? \"RestProperty\" : \"SpreadProperty\";\n      if (isPattern) this.toAssignable(prop.argument, true, \"object pattern\");\n      node.properties.push(prop);\n      if (isPattern) {\n        var position = this.state.start;\n        if (firstRestLocation !== null) {\n          this.unexpected(firstRestLocation, \"Cannot have multiple rest elements when destructuring\");\n        } else if (this.eat(types.braceR)) {\n          break;\n        } else if (this.match(types.comma) && this.lookahead().type === types.braceR) {\n          // TODO: temporary rollback\n          // this.unexpected(position, \"A trailing comma is not permitted after the rest element\");\n          continue;\n        } else {\n          firstRestLocation = position;\n          continue;\n        }\n      } else {\n        continue;\n      }\n    }\n\n    prop.method = false;\n    prop.shorthand = false;\n\n    if (isPattern || refShorthandDefaultPos) {\n      startPos = this.state.start;\n      startLoc = this.state.startLoc;\n    }\n\n    if (!isPattern) {\n      isGenerator = this.eat(types.star);\n    }\n\n    if (!isPattern && this.isContextual(\"async\")) {\n      if (isGenerator) this.unexpected();\n\n      var asyncId = this.parseIdentifier();\n      if (this.match(types.colon) || this.match(types.parenL) || this.match(types.braceR) || this.match(types.eq) || this.match(types.comma)) {\n        prop.key = asyncId;\n        prop.computed = false;\n      } else {\n        isAsync = true;\n        if (this.hasPlugin(\"asyncGenerators\")) isGenerator = this.eat(types.star);\n        this.parsePropertyName(prop);\n      }\n    } else {\n      this.parsePropertyName(prop);\n    }\n\n    this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos);\n    this.checkPropClash(prop, propHash);\n\n    if (prop.shorthand) {\n      this.addExtra(prop, \"shorthand\", true);\n    }\n\n    node.properties.push(prop);\n  }\n\n  if (firstRestLocation !== null) {\n    this.unexpected(firstRestLocation, \"The rest element has to be the last element when destructuring\");\n  }\n\n  if (decorators.length) {\n    this.raise(this.state.start, \"You have trailing decorators with no property\");\n  }\n\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\");\n};\n\npp$3.isGetterOrSetterMethod = function (prop, isPattern) {\n  return !isPattern && !prop.computed && prop.key.type === \"Identifier\" && (prop.key.name === \"get\" || prop.key.name === \"set\") && (this.match(types.string) || // get \"string\"() {}\n  this.match(types.num) || // get 1() {}\n  this.match(types.bracketL) || // get [\"string\"]() {}\n  this.match(types.name) || // get foo() {}\n  this.state.type.keyword // get debugger() {}\n  );\n};\n\n// get methods aren't allowed to have any parameters\n// set methods must have exactly 1 parameter\npp$3.checkGetterSetterParamCount = function (method) {\n  var paramCount = method.kind === \"get\" ? 0 : 1;\n  if (method.params.length !== paramCount) {\n    var start = method.start;\n    if (method.kind === \"get\") {\n      this.raise(start, \"getter should have no params\");\n    } else {\n      this.raise(start, \"setter should have exactly one param\");\n    }\n  }\n};\n\npp$3.parseObjectMethod = function (prop, isGenerator, isAsync, isPattern) {\n  if (isAsync || isGenerator || this.match(types.parenL)) {\n    if (isPattern) this.unexpected();\n    prop.kind = \"method\";\n    prop.method = true;\n    this.parseMethod(prop, isGenerator, isAsync);\n\n    return this.finishNode(prop, \"ObjectMethod\");\n  }\n\n  if (this.isGetterOrSetterMethod(prop, isPattern)) {\n    if (isGenerator || isAsync) this.unexpected();\n    prop.kind = prop.key.name;\n    this.parsePropertyName(prop);\n    this.parseMethod(prop);\n    this.checkGetterSetterParamCount(prop);\n\n    return this.finishNode(prop, \"ObjectMethod\");\n  }\n};\n\npp$3.parseObjectProperty = function (prop, startPos, startLoc, isPattern, refShorthandDefaultPos) {\n  if (this.eat(types.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(false, refShorthandDefaultPos);\n\n    return this.finishNode(prop, \"ObjectProperty\");\n  }\n\n  if (!prop.computed && prop.key.type === \"Identifier\") {\n    this.checkReservedWord(prop.key.name, prop.key.start, true, true);\n\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());\n    } else if (this.match(types.eq) && refShorthandDefaultPos) {\n      if (!refShorthandDefaultPos.start) {\n        refShorthandDefaultPos.start = this.state.start;\n      }\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());\n    } else {\n      prop.value = prop.key.__clone();\n    }\n    prop.shorthand = true;\n\n    return this.finishNode(prop, \"ObjectProperty\");\n  }\n};\n\npp$3.parseObjPropValue = function (prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos) {\n  var node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos);\n\n  if (!node) this.unexpected();\n\n  return node;\n};\n\npp$3.parsePropertyName = function (prop) {\n  if (this.eat(types.bracketL)) {\n    prop.computed = true;\n    prop.key = this.parseMaybeAssign();\n    this.expect(types.bracketR);\n  } else {\n    prop.computed = false;\n    var oldInPropertyName = this.state.inPropertyName;\n    this.state.inPropertyName = true;\n    prop.key = this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);\n    this.state.inPropertyName = oldInPropertyName;\n  }\n  return prop.key;\n};\n\n// Initialize empty function node.\n\npp$3.initFunction = function (node, isAsync) {\n  node.id = null;\n  node.generator = false;\n  node.expression = false;\n  node.async = !!isAsync;\n};\n\n// Parse object or class method.\n\npp$3.parseMethod = function (node, isGenerator, isAsync) {\n  var oldInMethod = this.state.inMethod;\n  this.state.inMethod = node.kind || true;\n  this.initFunction(node, isAsync);\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR);\n  node.generator = !!isGenerator;\n  this.parseFunctionBody(node);\n  this.state.inMethod = oldInMethod;\n  return node;\n};\n\n// Parse arrow function expression with given parameters.\n\npp$3.parseArrowExpression = function (node, params, isAsync) {\n  this.initFunction(node, isAsync);\n  node.params = this.toAssignableList(params, true, \"arrow function parameters\");\n  this.parseFunctionBody(node, true);\n  return this.finishNode(node, \"ArrowFunctionExpression\");\n};\n\npp$3.isStrictBody = function (node, isExpression) {\n  if (!isExpression && node.body.directives.length) {\n    for (var _iterator2 = node.body.directives, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var directive = _ref2;\n\n      if (directive.value.value === \"use strict\") {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n// Parse function body and check parameters.\npp$3.parseFunctionBody = function (node, allowExpression) {\n  var isExpression = allowExpression && !this.match(types.braceL);\n\n  var oldInAsync = this.state.inAsync;\n  this.state.inAsync = node.async;\n  if (isExpression) {\n    node.body = this.parseMaybeAssign();\n    node.expression = true;\n  } else {\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldInFunc = this.state.inFunction;\n    var oldInGen = this.state.inGenerator;\n    var oldLabels = this.state.labels;\n    this.state.inFunction = true;this.state.inGenerator = node.generator;this.state.labels = [];\n    node.body = this.parseBlock(true);\n    node.expression = false;\n    this.state.inFunction = oldInFunc;this.state.inGenerator = oldInGen;this.state.labels = oldLabels;\n  }\n  this.state.inAsync = oldInAsync;\n\n  // If this is a strict mode function, verify that argument names\n  // are not repeated, and it does not try to bind the words `eval`\n  // or `arguments`.\n  var isStrict = this.isStrictBody(node, isExpression);\n  // Also check when allowExpression === true for arrow functions\n  var checkLVal = this.state.strict || allowExpression || isStrict;\n\n  if (isStrict && node.id && node.id.type === \"Identifier\" && node.id.name === \"yield\") {\n    this.raise(node.id.start, \"Binding yield in strict mode\");\n  }\n\n  if (checkLVal) {\n    var nameHash = Object.create(null);\n    var oldStrict = this.state.strict;\n    if (isStrict) this.state.strict = true;\n    if (node.id) {\n      this.checkLVal(node.id, true, undefined, \"function name\");\n    }\n    for (var _iterator3 = node.params, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n      var _ref3;\n\n      if (_isArray3) {\n        if (_i3 >= _iterator3.length) break;\n        _ref3 = _iterator3[_i3++];\n      } else {\n        _i3 = _iterator3.next();\n        if (_i3.done) break;\n        _ref3 = _i3.value;\n      }\n\n      var param = _ref3;\n\n      if (isStrict && param.type !== \"Identifier\") {\n        this.raise(param.start, \"Non-simple parameter in strict mode\");\n      }\n      this.checkLVal(param, true, nameHash, \"function parameter list\");\n    }\n    this.state.strict = oldStrict;\n  }\n};\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp$3.parseExprList = function (close, allowEmpty, refShorthandDefaultPos) {\n  var elts = [];\n  var first = true;\n\n  while (!this.eat(close)) {\n    if (first) {\n      first = false;\n    } else {\n      this.expect(types.comma);\n      if (this.eat(close)) break;\n    }\n\n    elts.push(this.parseExprListItem(allowEmpty, refShorthandDefaultPos));\n  }\n  return elts;\n};\n\npp$3.parseExprListItem = function (allowEmpty, refShorthandDefaultPos, refNeedsArrowPos) {\n  var elt = void 0;\n  if (allowEmpty && this.match(types.comma)) {\n    elt = null;\n  } else if (this.match(types.ellipsis)) {\n    elt = this.parseSpread(refShorthandDefaultPos);\n  } else {\n    elt = this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos);\n  }\n  return elt;\n};\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp$3.parseIdentifier = function (liberal) {\n  var node = this.startNode();\n  if (!liberal) {\n    this.checkReservedWord(this.state.value, this.state.start, !!this.state.type.keyword, false);\n  }\n\n  if (this.match(types.name)) {\n    node.name = this.state.value;\n  } else if (this.state.type.keyword) {\n    node.name = this.state.type.keyword;\n  } else {\n    this.unexpected();\n  }\n\n  if (!liberal && node.name === \"await\" && this.state.inAsync) {\n    this.raise(node.start, \"invalid use of await inside of an async function\");\n  }\n\n  node.loc.identifierName = node.name;\n\n  this.next();\n  return this.finishNode(node, \"Identifier\");\n};\n\npp$3.checkReservedWord = function (word, startLoc, checkKeywords, isBinding) {\n  if (this.isReservedWord(word) || checkKeywords && this.isKeyword(word)) {\n    this.raise(startLoc, word + \" is a reserved word\");\n  }\n\n  if (this.state.strict && (reservedWords.strict(word) || isBinding && reservedWords.strictBind(word))) {\n    this.raise(startLoc, word + \" is a reserved word in strict mode\");\n  }\n};\n\n// Parses await expression inside async function.\n\npp$3.parseAwait = function (node) {\n  // istanbul ignore next: this condition is checked at the call site so won't be hit here\n  if (!this.state.inAsync) {\n    this.unexpected();\n  }\n  if (this.match(types.star)) {\n    this.raise(node.start, \"await* has been removed from the async functions proposal. Use Promise.all() instead.\");\n  }\n  node.argument = this.parseMaybeUnary();\n  return this.finishNode(node, \"AwaitExpression\");\n};\n\n// Parses yield expression inside generator.\n\npp$3.parseYield = function () {\n  var node = this.startNode();\n  this.next();\n  if (this.match(types.semi) || this.canInsertSemicolon() || !this.match(types.star) && !this.state.type.startsExpr) {\n    node.delegate = false;\n    node.argument = null;\n  } else {\n    node.delegate = this.eat(types.star);\n    node.argument = this.parseMaybeAssign();\n  }\n  return this.finishNode(node, \"YieldExpression\");\n};\n\n// Start an AST node, attaching a start offset.\n\nvar pp$4 = Parser.prototype;\nvar commentKeys = [\"leadingComments\", \"trailingComments\", \"innerComments\"];\n\nvar Node = function () {\n  function Node(pos, loc, filename) {\n    classCallCheck(this, Node);\n\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if (filename) this.loc.filename = filename;\n  }\n\n  Node.prototype.__clone = function __clone() {\n    var node2 = new Node();\n    for (var key in this) {\n      // Do not clone comments that are already attached to the node\n      if (commentKeys.indexOf(key) < 0) {\n        node2[key] = this[key];\n      }\n    }\n\n    return node2;\n  };\n\n  return Node;\n}();\n\npp$4.startNode = function () {\n  return new Node(this.state.start, this.state.startLoc, this.filename);\n};\n\npp$4.startNodeAt = function (pos, loc) {\n  return new Node(pos, loc, this.filename);\n};\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type;\n  node.end = pos;\n  node.loc.end = loc;\n  this.processComment(node);\n  return node;\n}\n\n// Finish an AST node, adding `type` and `end` properties.\n\npp$4.finishNode = function (node, type) {\n  return finishNodeAt.call(this, node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);\n};\n\n// Finish node at given position\n\npp$4.finishNodeAt = function (node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc);\n};\n\nvar pp$5 = Parser.prototype;\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$5.raise = function (pos, message) {\n  var loc = getLineInfo(this.input, pos);\n  message += \" (\" + loc.line + \":\" + loc.column + \")\";\n  var err = new SyntaxError(message);\n  err.pos = pos;\n  err.loc = loc;\n  throw err;\n};\n\n/* eslint max-len: 0 */\n\n/**\n * Based on the comment attachment algorithm used in espree and estraverse.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright\n *   notice, this list of conditions and the following disclaimer.\n * * Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nfunction last(stack) {\n  return stack[stack.length - 1];\n}\n\nvar pp$6 = Parser.prototype;\n\npp$6.addComment = function (comment) {\n  if (this.filename) comment.loc.filename = this.filename;\n  this.state.trailingComments.push(comment);\n  this.state.leadingComments.push(comment);\n};\n\npp$6.processComment = function (node) {\n  if (node.type === \"Program\" && node.body.length > 0) return;\n\n  var stack = this.state.commentStack;\n\n  var firstChild = void 0,\n      lastChild = void 0,\n      trailingComments = void 0,\n      i = void 0,\n      j = void 0;\n\n  if (this.state.trailingComments.length > 0) {\n    // If the first comment in trailingComments comes after the\n    // current node, then we're good - all comments in the array will\n    // come after the node and so it's safe to add them as official\n    // trailingComments.\n    if (this.state.trailingComments[0].start >= node.end) {\n      trailingComments = this.state.trailingComments;\n      this.state.trailingComments = [];\n    } else {\n      // Otherwise, if the first comment doesn't come after the\n      // current node, that means we have a mix of leading and trailing\n      // comments in the array and that leadingComments contains the\n      // same items as trailingComments. Reset trailingComments to\n      // zero items and we'll handle this by evaluating leadingComments\n      // later.\n      this.state.trailingComments.length = 0;\n    }\n  } else {\n    var lastInStack = last(stack);\n    if (stack.length > 0 && lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {\n      trailingComments = lastInStack.trailingComments;\n      lastInStack.trailingComments = null;\n    }\n  }\n\n  // Eating the stack.\n  if (stack.length > 0 && last(stack).start >= node.start) {\n    firstChild = stack.pop();\n  }\n\n  while (stack.length > 0 && last(stack).start >= node.start) {\n    lastChild = stack.pop();\n  }\n\n  if (!lastChild && firstChild) lastChild = firstChild;\n\n  // Attach comments that follow a trailing comma on the last\n  // property in an object literal or a trailing comma in function arguments\n  // as trailing comments\n  if (firstChild && this.state.leadingComments.length > 0) {\n    var lastComment = last(this.state.leadingComments);\n\n    if (firstChild.type === \"ObjectProperty\") {\n      if (lastComment.start >= node.start) {\n        if (this.state.commentPreviousNode) {\n          for (j = 0; j < this.state.leadingComments.length; j++) {\n            if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {\n              this.state.leadingComments.splice(j, 1);\n              j--;\n            }\n          }\n\n          if (this.state.leadingComments.length > 0) {\n            firstChild.trailingComments = this.state.leadingComments;\n            this.state.leadingComments = [];\n          }\n        }\n      }\n    } else if (node.type === \"CallExpression\" && node.arguments && node.arguments.length) {\n      var lastArg = last(node.arguments);\n\n      if (lastArg && lastComment.start >= lastArg.start && lastComment.end <= node.end) {\n        if (this.state.commentPreviousNode) {\n          if (this.state.leadingComments.length > 0) {\n            lastArg.trailingComments = this.state.leadingComments;\n            this.state.leadingComments = [];\n          }\n        }\n      }\n    }\n  }\n\n  if (lastChild) {\n    if (lastChild.leadingComments) {\n      if (lastChild !== node && last(lastChild.leadingComments).end <= node.start) {\n        node.leadingComments = lastChild.leadingComments;\n        lastChild.leadingComments = null;\n      } else {\n        // A leading comment for an anonymous class had been stolen by its first ClassMethod,\n        // so this takes back the leading comment.\n        // See also: https://github.com/eslint/espree/issues/158\n        for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {\n          if (lastChild.leadingComments[i].end <= node.start) {\n            node.leadingComments = lastChild.leadingComments.splice(0, i + 1);\n            break;\n          }\n        }\n      }\n    }\n  } else if (this.state.leadingComments.length > 0) {\n    if (last(this.state.leadingComments).end <= node.start) {\n      if (this.state.commentPreviousNode) {\n        for (j = 0; j < this.state.leadingComments.length; j++) {\n          if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {\n            this.state.leadingComments.splice(j, 1);\n            j--;\n          }\n        }\n      }\n      if (this.state.leadingComments.length > 0) {\n        node.leadingComments = this.state.leadingComments;\n        this.state.leadingComments = [];\n      }\n    } else {\n      // https://github.com/eslint/espree/issues/2\n      //\n      // In special cases, such as return (without a value) and\n      // debugger, all comments will end up as leadingComments and\n      // will otherwise be eliminated. This step runs when the\n      // commentStack is empty and there are comments left\n      // in leadingComments.\n      //\n      // This loop figures out the stopping point between the actual\n      // leading and trailing comments by finding the location of the\n      // first comment that comes after the given node.\n      for (i = 0; i < this.state.leadingComments.length; i++) {\n        if (this.state.leadingComments[i].end > node.start) {\n          break;\n        }\n      }\n\n      // Split the array based on the location of the first comment\n      // that comes after the node. Keep in mind that this could\n      // result in an empty array, and if so, the array must be\n      // deleted.\n      node.leadingComments = this.state.leadingComments.slice(0, i);\n      if (node.leadingComments.length === 0) {\n        node.leadingComments = null;\n      }\n\n      // Similarly, trailing comments are attached later. The variable\n      // must be reset to null if there are no trailing comments.\n      trailingComments = this.state.leadingComments.slice(i);\n      if (trailingComments.length === 0) {\n        trailingComments = null;\n      }\n    }\n  }\n\n  this.state.commentPreviousNode = node;\n\n  if (trailingComments) {\n    if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {\n      node.innerComments = trailingComments;\n    } else {\n      node.trailingComments = trailingComments;\n    }\n  }\n\n  stack.push(node);\n};\n\nvar pp$7 = Parser.prototype;\n\npp$7.estreeParseRegExpLiteral = function (_ref) {\n  var pattern = _ref.pattern,\n      flags = _ref.flags;\n\n  var regex = null;\n  try {\n    regex = new RegExp(pattern, flags);\n  } catch (e) {\n    // In environments that don't support these flags value will\n    // be null as the regex can't be represented natively.\n  }\n  var node = this.estreeParseLiteral(regex);\n  node.regex = { pattern: pattern, flags: flags };\n\n  return node;\n};\n\npp$7.estreeParseLiteral = function (value) {\n  return this.parseLiteral(value, \"Literal\");\n};\n\npp$7.directiveToStmt = function (directive) {\n  var directiveLiteral = directive.value;\n\n  var stmt = this.startNodeAt(directive.start, directive.loc.start);\n  var expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);\n\n  expression.value = directiveLiteral.value;\n  expression.raw = directiveLiteral.extra.raw;\n\n  stmt.expression = this.finishNodeAt(expression, \"Literal\", directiveLiteral.end, directiveLiteral.loc.end);\n  stmt.directive = directiveLiteral.extra.raw.slice(1, -1);\n\n  return this.finishNodeAt(stmt, \"ExpressionStatement\", directive.end, directive.loc.end);\n};\n\nfunction isSimpleProperty(node) {\n  return node && node.type === \"Property\" && node.kind === \"init\" && node.method === false;\n}\n\nvar estreePlugin = function (instance) {\n  instance.extend(\"checkDeclaration\", function (inner) {\n    return function (node) {\n      if (isSimpleProperty(node)) {\n        this.checkDeclaration(node.value);\n      } else {\n        inner.call(this, node);\n      }\n    };\n  });\n\n  instance.extend(\"checkGetterSetterParamCount\", function () {\n    return function (prop) {\n      var paramCount = prop.kind === \"get\" ? 0 : 1;\n      if (prop.value.params.length !== paramCount) {\n        var start = prop.start;\n        if (prop.kind === \"get\") {\n          this.raise(start, \"getter should have no params\");\n        } else {\n          this.raise(start, \"setter should have exactly one param\");\n        }\n      }\n    };\n  });\n\n  instance.extend(\"checkLVal\", function (inner) {\n    return function (expr, isBinding, checkClashes) {\n      var _this = this;\n\n      switch (expr.type) {\n        case \"ObjectPattern\":\n          expr.properties.forEach(function (prop) {\n            _this.checkLVal(prop.type === \"Property\" ? prop.value : prop, isBinding, checkClashes, \"object destructuring pattern\");\n          });\n          break;\n        default:\n          for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n            args[_key - 3] = arguments[_key];\n          }\n\n          inner.call.apply(inner, [this, expr, isBinding, checkClashes].concat(args));\n      }\n    };\n  });\n\n  instance.extend(\"checkPropClash\", function () {\n    return function (prop, propHash) {\n      if (prop.computed || !isSimpleProperty(prop)) return;\n\n      var key = prop.key;\n      // It is either an Identifier or a String/NumericLiteral\n      var name = key.type === \"Identifier\" ? key.name : String(key.value);\n\n      if (name === \"__proto__\") {\n        if (propHash.proto) this.raise(key.start, \"Redefinition of __proto__ property\");\n        propHash.proto = true;\n      }\n    };\n  });\n\n  instance.extend(\"isStrictBody\", function () {\n    return function (node, isExpression) {\n      if (!isExpression && node.body.body.length > 0) {\n        for (var _iterator = node.body.body, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n          var _ref2;\n\n          if (_isArray) {\n            if (_i >= _iterator.length) break;\n            _ref2 = _iterator[_i++];\n          } else {\n            _i = _iterator.next();\n            if (_i.done) break;\n            _ref2 = _i.value;\n          }\n\n          var directive = _ref2;\n\n          if (directive.type === \"ExpressionStatement\" && directive.expression.type === \"Literal\") {\n            if (directive.expression.value === \"use strict\") return true;\n          } else {\n            // Break for the first non literal expression\n            break;\n          }\n        }\n      }\n\n      return false;\n    };\n  });\n\n  instance.extend(\"isValidDirective\", function () {\n    return function (stmt) {\n      return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && typeof stmt.expression.value === \"string\" && (!stmt.expression.extra || !stmt.expression.extra.parenthesized);\n    };\n  });\n\n  instance.extend(\"stmtToDirective\", function (inner) {\n    return function (stmt) {\n      var directive = inner.call(this, stmt);\n      var value = stmt.expression.value;\n\n      // Reset value to the actual value as in estree mode we want\n      // the stmt to have the real value and not the raw value\n      directive.value.value = value;\n\n      return directive;\n    };\n  });\n\n  instance.extend(\"parseBlockBody\", function (inner) {\n    return function (node) {\n      var _this2 = this;\n\n      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      inner.call.apply(inner, [this, node].concat(args));\n\n      node.directives.reverse().forEach(function (directive) {\n        node.body.unshift(_this2.directiveToStmt(directive));\n      });\n      delete node.directives;\n    };\n  });\n\n  instance.extend(\"parseClassMethod\", function () {\n    return function (classBody, method, isGenerator, isAsync) {\n      this.parseMethod(method, isGenerator, isAsync);\n      if (method.typeParameters) {\n        method.value.typeParameters = method.typeParameters;\n        delete method.typeParameters;\n      }\n      classBody.body.push(this.finishNode(method, \"MethodDefinition\"));\n    };\n  });\n\n  instance.extend(\"parseExprAtom\", function (inner) {\n    return function () {\n      switch (this.state.type) {\n        case types.regexp:\n          return this.estreeParseRegExpLiteral(this.state.value);\n\n        case types.num:\n        case types.string:\n          return this.estreeParseLiteral(this.state.value);\n\n        case types._null:\n          return this.estreeParseLiteral(null);\n\n        case types._true:\n          return this.estreeParseLiteral(true);\n\n        case types._false:\n          return this.estreeParseLiteral(false);\n\n        default:\n          for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n            args[_key3] = arguments[_key3];\n          }\n\n          return inner.call.apply(inner, [this].concat(args));\n      }\n    };\n  });\n\n  instance.extend(\"parseLiteral\", function (inner) {\n    return function () {\n      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      var node = inner.call.apply(inner, [this].concat(args));\n      node.raw = node.extra.raw;\n      delete node.extra;\n\n      return node;\n    };\n  });\n\n  instance.extend(\"parseMethod\", function (inner) {\n    return function (node) {\n      var funcNode = this.startNode();\n      funcNode.kind = node.kind; // provide kind, so inner method correctly sets state\n\n      for (var _len5 = arguments.length, args = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        args[_key5 - 1] = arguments[_key5];\n      }\n\n      funcNode = inner.call.apply(inner, [this, funcNode].concat(args));\n      delete funcNode.kind;\n      node.value = this.finishNode(funcNode, \"FunctionExpression\");\n\n      return node;\n    };\n  });\n\n  instance.extend(\"parseObjectMethod\", function (inner) {\n    return function () {\n      for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n\n      var node = inner.call.apply(inner, [this].concat(args));\n\n      if (node) {\n        if (node.kind === \"method\") node.kind = \"init\";\n        node.type = \"Property\";\n      }\n\n      return node;\n    };\n  });\n\n  instance.extend(\"parseObjectProperty\", function (inner) {\n    return function () {\n      for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n\n      var node = inner.call.apply(inner, [this].concat(args));\n\n      if (node) {\n        node.kind = \"init\";\n        node.type = \"Property\";\n      }\n\n      return node;\n    };\n  });\n\n  instance.extend(\"toAssignable\", function (inner) {\n    return function (node, isBinding) {\n      for (var _len8 = arguments.length, args = Array(_len8 > 2 ? _len8 - 2 : 0), _key8 = 2; _key8 < _len8; _key8++) {\n        args[_key8 - 2] = arguments[_key8];\n      }\n\n      if (isSimpleProperty(node)) {\n        this.toAssignable.apply(this, [node.value, isBinding].concat(args));\n\n        return node;\n      } else if (node.type === \"ObjectExpression\") {\n        node.type = \"ObjectPattern\";\n        for (var _iterator2 = node.properties, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n          var _ref3;\n\n          if (_isArray2) {\n            if (_i2 >= _iterator2.length) break;\n            _ref3 = _iterator2[_i2++];\n          } else {\n            _i2 = _iterator2.next();\n            if (_i2.done) break;\n            _ref3 = _i2.value;\n          }\n\n          var prop = _ref3;\n\n          if (prop.kind === \"get\" || prop.kind === \"set\") {\n            this.raise(prop.key.start, \"Object pattern can't contain getter or setter\");\n          } else if (prop.method) {\n            this.raise(prop.key.start, \"Object pattern can't contain methods\");\n          } else {\n            this.toAssignable(prop, isBinding, \"object destructuring pattern\");\n          }\n        }\n\n        return node;\n      }\n\n      return inner.call.apply(inner, [this, node, isBinding].concat(args));\n    };\n  });\n};\n\n/* eslint max-len: 0 */\n\nvar primitiveTypes = [\"any\", \"mixed\", \"empty\", \"bool\", \"boolean\", \"number\", \"string\", \"void\", \"null\"];\n\nvar pp$8 = Parser.prototype;\n\npp$8.flowParseTypeInitialiser = function (tok) {\n  var oldInType = this.state.inType;\n  this.state.inType = true;\n  this.expect(tok || types.colon);\n\n  var type = this.flowParseType();\n  this.state.inType = oldInType;\n  return type;\n};\n\npp$8.flowParsePredicate = function () {\n  var node = this.startNode();\n  var moduloLoc = this.state.startLoc;\n  var moduloPos = this.state.start;\n  this.expect(types.modulo);\n  var checksLoc = this.state.startLoc;\n  this.expectContextual(\"checks\");\n  // Force '%' and 'checks' to be adjacent\n  if (moduloLoc.line !== checksLoc.line || moduloLoc.column !== checksLoc.column - 1) {\n    this.raise(moduloPos, \"Spaces between % and checks are not allowed here.\");\n  }\n  if (this.eat(types.parenL)) {\n    node.expression = this.parseExpression();\n    this.expect(types.parenR);\n    return this.finishNode(node, \"DeclaredPredicate\");\n  } else {\n    return this.finishNode(node, \"InferredPredicate\");\n  }\n};\n\npp$8.flowParseTypeAndPredicateInitialiser = function () {\n  var oldInType = this.state.inType;\n  this.state.inType = true;\n  this.expect(types.colon);\n  var type = null;\n  var predicate = null;\n  if (this.match(types.modulo)) {\n    this.state.inType = oldInType;\n    predicate = this.flowParsePredicate();\n  } else {\n    type = this.flowParseType();\n    this.state.inType = oldInType;\n    if (this.match(types.modulo)) {\n      predicate = this.flowParsePredicate();\n    }\n  }\n  return [type, predicate];\n};\n\npp$8.flowParseDeclareClass = function (node) {\n  this.next();\n  this.flowParseInterfaceish(node, true);\n  return this.finishNode(node, \"DeclareClass\");\n};\n\npp$8.flowParseDeclareFunction = function (node) {\n  this.next();\n\n  var id = node.id = this.parseIdentifier();\n\n  var typeNode = this.startNode();\n  var typeContainer = this.startNode();\n\n  if (this.isRelational(\"<\")) {\n    typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n  } else {\n    typeNode.typeParameters = null;\n  }\n\n  this.expect(types.parenL);\n  var tmp = this.flowParseFunctionTypeParams();\n  typeNode.params = tmp.params;\n  typeNode.rest = tmp.rest;\n  this.expect(types.parenR);\n  var predicate = null;\n\n  var _flowParseTypeAndPred = this.flowParseTypeAndPredicateInitialiser();\n\n  typeNode.returnType = _flowParseTypeAndPred[0];\n  predicate = _flowParseTypeAndPred[1];\n\n  typeContainer.typeAnnotation = this.finishNode(typeNode, \"FunctionTypeAnnotation\");\n  typeContainer.predicate = predicate;\n  id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n\n  this.finishNode(id, id.type);\n\n  this.semicolon();\n\n  return this.finishNode(node, \"DeclareFunction\");\n};\n\npp$8.flowParseDeclare = function (node) {\n  if (this.match(types._class)) {\n    return this.flowParseDeclareClass(node);\n  } else if (this.match(types._function)) {\n    return this.flowParseDeclareFunction(node);\n  } else if (this.match(types._var)) {\n    return this.flowParseDeclareVariable(node);\n  } else if (this.isContextual(\"module\")) {\n    if (this.lookahead().type === types.dot) {\n      return this.flowParseDeclareModuleExports(node);\n    } else {\n      return this.flowParseDeclareModule(node);\n    }\n  } else if (this.isContextual(\"type\")) {\n    return this.flowParseDeclareTypeAlias(node);\n  } else if (this.isContextual(\"opaque\")) {\n    return this.flowParseDeclareOpaqueType(node);\n  } else if (this.isContextual(\"interface\")) {\n    return this.flowParseDeclareInterface(node);\n  } else if (this.match(types._export)) {\n    return this.flowParseDeclareExportDeclaration(node);\n  } else {\n    this.unexpected();\n  }\n};\n\npp$8.flowParseDeclareExportDeclaration = function (node) {\n  this.expect(types._export);\n  if (this.isContextual(\"opaque\") // declare export opaque ...\n  ) {\n      node.declaration = this.flowParseDeclare(this.startNode());\n      node.default = false;\n\n      return this.finishNode(node, \"DeclareExportDeclaration\");\n    }\n\n  throw this.unexpected();\n};\n\npp$8.flowParseDeclareVariable = function (node) {\n  this.next();\n  node.id = this.flowParseTypeAnnotatableIdentifier();\n  this.semicolon();\n  return this.finishNode(node, \"DeclareVariable\");\n};\n\npp$8.flowParseDeclareModule = function (node) {\n  this.next();\n\n  if (this.match(types.string)) {\n    node.id = this.parseExprAtom();\n  } else {\n    node.id = this.parseIdentifier();\n  }\n\n  var bodyNode = node.body = this.startNode();\n  var body = bodyNode.body = [];\n  this.expect(types.braceL);\n  while (!this.match(types.braceR)) {\n    var _bodyNode = this.startNode();\n\n    if (this.match(types._import)) {\n      var lookahead = this.lookahead();\n      if (lookahead.value !== \"type\" && lookahead.value !== \"typeof\") {\n        this.unexpected(null, \"Imports within a `declare module` body must always be `import type` or `import typeof`\");\n      }\n\n      this.parseImport(_bodyNode);\n    } else {\n      this.expectContextual(\"declare\", \"Only declares and type imports are allowed inside declare module\");\n\n      _bodyNode = this.flowParseDeclare(_bodyNode, true);\n    }\n\n    body.push(_bodyNode);\n  }\n  this.expect(types.braceR);\n\n  this.finishNode(bodyNode, \"BlockStatement\");\n  return this.finishNode(node, \"DeclareModule\");\n};\n\npp$8.flowParseDeclareModuleExports = function (node) {\n  this.expectContextual(\"module\");\n  this.expect(types.dot);\n  this.expectContextual(\"exports\");\n  node.typeAnnotation = this.flowParseTypeAnnotation();\n  this.semicolon();\n\n  return this.finishNode(node, \"DeclareModuleExports\");\n};\n\npp$8.flowParseDeclareTypeAlias = function (node) {\n  this.next();\n  this.flowParseTypeAlias(node);\n  return this.finishNode(node, \"DeclareTypeAlias\");\n};\n\npp$8.flowParseDeclareOpaqueType = function (node) {\n  this.next();\n  this.flowParseOpaqueType(node, true);\n  return this.finishNode(node, \"DeclareOpaqueType\");\n};\n\npp$8.flowParseDeclareInterface = function (node) {\n  this.next();\n  this.flowParseInterfaceish(node);\n  return this.finishNode(node, \"DeclareInterface\");\n};\n\n// Interfaces\n\npp$8.flowParseInterfaceish = function (node) {\n  node.id = this.parseIdentifier();\n\n  if (this.isRelational(\"<\")) {\n    node.typeParameters = this.flowParseTypeParameterDeclaration();\n  } else {\n    node.typeParameters = null;\n  }\n\n  node.extends = [];\n  node.mixins = [];\n\n  if (this.eat(types._extends)) {\n    do {\n      node.extends.push(this.flowParseInterfaceExtends());\n    } while (this.eat(types.comma));\n  }\n\n  if (this.isContextual(\"mixins\")) {\n    this.next();\n    do {\n      node.mixins.push(this.flowParseInterfaceExtends());\n    } while (this.eat(types.comma));\n  }\n\n  node.body = this.flowParseObjectType(true, false, false);\n};\n\npp$8.flowParseInterfaceExtends = function () {\n  var node = this.startNode();\n\n  node.id = this.flowParseQualifiedTypeIdentifier();\n  if (this.isRelational(\"<\")) {\n    node.typeParameters = this.flowParseTypeParameterInstantiation();\n  } else {\n    node.typeParameters = null;\n  }\n\n  return this.finishNode(node, \"InterfaceExtends\");\n};\n\npp$8.flowParseInterface = function (node) {\n  this.flowParseInterfaceish(node, false);\n  return this.finishNode(node, \"InterfaceDeclaration\");\n};\n\npp$8.flowParseRestrictedIdentifier = function (liberal) {\n  if (primitiveTypes.indexOf(this.state.value) > -1) {\n    this.raise(this.state.start, \"Cannot overwrite primitive type \" + this.state.value);\n  }\n\n  return this.parseIdentifier(liberal);\n};\n\n// Type aliases\n\npp$8.flowParseTypeAlias = function (node) {\n  node.id = this.flowParseRestrictedIdentifier();\n\n  if (this.isRelational(\"<\")) {\n    node.typeParameters = this.flowParseTypeParameterDeclaration();\n  } else {\n    node.typeParameters = null;\n  }\n\n  node.right = this.flowParseTypeInitialiser(types.eq);\n  this.semicolon();\n\n  return this.finishNode(node, \"TypeAlias\");\n};\n\n// Opaque type aliases\n\npp$8.flowParseOpaqueType = function (node, declare) {\n  this.expectContextual(\"type\");\n  node.id = this.flowParseRestrictedIdentifier();\n\n  if (this.isRelational(\"<\")) {\n    node.typeParameters = this.flowParseTypeParameterDeclaration();\n  } else {\n    node.typeParameters = null;\n  }\n\n  // Parse the supertype\n  node.supertype = null;\n  if (this.match(types.colon)) {\n    node.supertype = this.flowParseTypeInitialiser(types.colon);\n  }\n\n  node.impltype = null;\n  if (!declare) {\n    node.impltype = this.flowParseTypeInitialiser(types.eq);\n  }\n  this.semicolon();\n\n  return this.finishNode(node, \"OpaqueType\");\n};\n\n// Type annotations\n\npp$8.flowParseTypeParameter = function () {\n  var node = this.startNode();\n\n  var variance = this.flowParseVariance();\n\n  var ident = this.flowParseTypeAnnotatableIdentifier();\n  node.name = ident.name;\n  node.variance = variance;\n  node.bound = ident.typeAnnotation;\n\n  if (this.match(types.eq)) {\n    this.eat(types.eq);\n    node.default = this.flowParseType();\n  }\n\n  return this.finishNode(node, \"TypeParameter\");\n};\n\npp$8.flowParseTypeParameterDeclaration = function () {\n  var oldInType = this.state.inType;\n  var node = this.startNode();\n  node.params = [];\n\n  this.state.inType = true;\n\n  // istanbul ignore else: this condition is already checked at all call sites\n  if (this.isRelational(\"<\") || this.match(types.jsxTagStart)) {\n    this.next();\n  } else {\n    this.unexpected();\n  }\n\n  do {\n    node.params.push(this.flowParseTypeParameter());\n    if (!this.isRelational(\">\")) {\n      this.expect(types.comma);\n    }\n  } while (!this.isRelational(\">\"));\n  this.expectRelational(\">\");\n\n  this.state.inType = oldInType;\n\n  return this.finishNode(node, \"TypeParameterDeclaration\");\n};\n\npp$8.flowParseTypeParameterInstantiation = function () {\n  var node = this.startNode();\n  var oldInType = this.state.inType;\n  node.params = [];\n\n  this.state.inType = true;\n\n  this.expectRelational(\"<\");\n  while (!this.isRelational(\">\")) {\n    node.params.push(this.flowParseType());\n    if (!this.isRelational(\">\")) {\n      this.expect(types.comma);\n    }\n  }\n  this.expectRelational(\">\");\n\n  this.state.inType = oldInType;\n\n  return this.finishNode(node, \"TypeParameterInstantiation\");\n};\n\npp$8.flowParseObjectPropertyKey = function () {\n  return this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);\n};\n\npp$8.flowParseObjectTypeIndexer = function (node, isStatic, variance) {\n  node.static = isStatic;\n\n  this.expect(types.bracketL);\n  if (this.lookahead().type === types.colon) {\n    node.id = this.flowParseObjectPropertyKey();\n    node.key = this.flowParseTypeInitialiser();\n  } else {\n    node.id = null;\n    node.key = this.flowParseType();\n  }\n  this.expect(types.bracketR);\n  node.value = this.flowParseTypeInitialiser();\n  node.variance = variance;\n\n  this.flowObjectTypeSemicolon();\n  return this.finishNode(node, \"ObjectTypeIndexer\");\n};\n\npp$8.flowParseObjectTypeMethodish = function (node) {\n  node.params = [];\n  node.rest = null;\n  node.typeParameters = null;\n\n  if (this.isRelational(\"<\")) {\n    node.typeParameters = this.flowParseTypeParameterDeclaration();\n  }\n\n  this.expect(types.parenL);\n  while (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n    node.params.push(this.flowParseFunctionTypeParam());\n    if (!this.match(types.parenR)) {\n      this.expect(types.comma);\n    }\n  }\n\n  if (this.eat(types.ellipsis)) {\n    node.rest = this.flowParseFunctionTypeParam();\n  }\n  this.expect(types.parenR);\n  node.returnType = this.flowParseTypeInitialiser();\n\n  return this.finishNode(node, \"FunctionTypeAnnotation\");\n};\n\npp$8.flowParseObjectTypeMethod = function (startPos, startLoc, isStatic, key) {\n  var node = this.startNodeAt(startPos, startLoc);\n  node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(startPos, startLoc));\n  node.static = isStatic;\n  node.key = key;\n  node.optional = false;\n  this.flowObjectTypeSemicolon();\n  return this.finishNode(node, \"ObjectTypeProperty\");\n};\n\npp$8.flowParseObjectTypeCallProperty = function (node, isStatic) {\n  var valueNode = this.startNode();\n  node.static = isStatic;\n  node.value = this.flowParseObjectTypeMethodish(valueNode);\n  this.flowObjectTypeSemicolon();\n  return this.finishNode(node, \"ObjectTypeCallProperty\");\n};\n\npp$8.flowParseObjectType = function (allowStatic, allowExact, allowSpread) {\n  var oldInType = this.state.inType;\n  this.state.inType = true;\n\n  var nodeStart = this.startNode();\n  var node = void 0;\n  var propertyKey = void 0;\n  var isStatic = false;\n\n  nodeStart.callProperties = [];\n  nodeStart.properties = [];\n  nodeStart.indexers = [];\n\n  var endDelim = void 0;\n  var exact = void 0;\n  if (allowExact && this.match(types.braceBarL)) {\n    this.expect(types.braceBarL);\n    endDelim = types.braceBarR;\n    exact = true;\n  } else {\n    this.expect(types.braceL);\n    endDelim = types.braceR;\n    exact = false;\n  }\n\n  nodeStart.exact = exact;\n\n  while (!this.match(endDelim)) {\n    var optional = false;\n    var startPos = this.state.start;\n    var startLoc = this.state.startLoc;\n    node = this.startNode();\n    if (allowStatic && this.isContextual(\"static\") && this.lookahead().type !== types.colon) {\n      this.next();\n      isStatic = true;\n    }\n\n    var variancePos = this.state.start;\n    var variance = this.flowParseVariance();\n\n    if (this.match(types.bracketL)) {\n      nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));\n    } else if (this.match(types.parenL) || this.isRelational(\"<\")) {\n      if (variance) {\n        this.unexpected(variancePos);\n      }\n      nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));\n    } else {\n      if (this.match(types.ellipsis)) {\n        if (!allowSpread) {\n          this.unexpected(null, \"Spread operator cannot appear in class or interface definitions\");\n        }\n        if (variance) {\n          this.unexpected(variance.start, \"Spread properties cannot have variance\");\n        }\n        this.expect(types.ellipsis);\n        node.argument = this.flowParseType();\n        this.flowObjectTypeSemicolon();\n        nodeStart.properties.push(this.finishNode(node, \"ObjectTypeSpreadProperty\"));\n      } else {\n        propertyKey = this.flowParseObjectPropertyKey();\n        if (this.isRelational(\"<\") || this.match(types.parenL)) {\n          // This is a method property\n          if (variance) {\n            this.unexpected(variance.start);\n          }\n          nodeStart.properties.push(this.flowParseObjectTypeMethod(startPos, startLoc, isStatic, propertyKey));\n        } else {\n          if (this.eat(types.question)) {\n            optional = true;\n          }\n          node.key = propertyKey;\n          node.value = this.flowParseTypeInitialiser();\n          node.optional = optional;\n          node.static = isStatic;\n          node.variance = variance;\n          this.flowObjectTypeSemicolon();\n          nodeStart.properties.push(this.finishNode(node, \"ObjectTypeProperty\"));\n        }\n      }\n    }\n\n    isStatic = false;\n  }\n\n  this.expect(endDelim);\n\n  var out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n\n  this.state.inType = oldInType;\n\n  return out;\n};\n\npp$8.flowObjectTypeSemicolon = function () {\n  if (!this.eat(types.semi) && !this.eat(types.comma) && !this.match(types.braceR) && !this.match(types.braceBarR)) {\n    this.unexpected();\n  }\n};\n\npp$8.flowParseQualifiedTypeIdentifier = function (startPos, startLoc, id) {\n  startPos = startPos || this.state.start;\n  startLoc = startLoc || this.state.startLoc;\n  var node = id || this.parseIdentifier();\n\n  while (this.eat(types.dot)) {\n    var node2 = this.startNodeAt(startPos, startLoc);\n    node2.qualification = node;\n    node2.id = this.parseIdentifier();\n    node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n  }\n\n  return node;\n};\n\npp$8.flowParseGenericType = function (startPos, startLoc, id) {\n  var node = this.startNodeAt(startPos, startLoc);\n\n  node.typeParameters = null;\n  node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);\n\n  if (this.isRelational(\"<\")) {\n    node.typeParameters = this.flowParseTypeParameterInstantiation();\n  }\n\n  return this.finishNode(node, \"GenericTypeAnnotation\");\n};\n\npp$8.flowParseTypeofType = function () {\n  var node = this.startNode();\n  this.expect(types._typeof);\n  node.argument = this.flowParsePrimaryType();\n  return this.finishNode(node, \"TypeofTypeAnnotation\");\n};\n\npp$8.flowParseTupleType = function () {\n  var node = this.startNode();\n  node.types = [];\n  this.expect(types.bracketL);\n  // We allow trailing commas\n  while (this.state.pos < this.input.length && !this.match(types.bracketR)) {\n    node.types.push(this.flowParseType());\n    if (this.match(types.bracketR)) break;\n    this.expect(types.comma);\n  }\n  this.expect(types.bracketR);\n  return this.finishNode(node, \"TupleTypeAnnotation\");\n};\n\npp$8.flowParseFunctionTypeParam = function () {\n  var name = null;\n  var optional = false;\n  var typeAnnotation = null;\n  var node = this.startNode();\n  var lh = this.lookahead();\n  if (lh.type === types.colon || lh.type === types.question) {\n    name = this.parseIdentifier();\n    if (this.eat(types.question)) {\n      optional = true;\n    }\n    typeAnnotation = this.flowParseTypeInitialiser();\n  } else {\n    typeAnnotation = this.flowParseType();\n  }\n  node.name = name;\n  node.optional = optional;\n  node.typeAnnotation = typeAnnotation;\n  return this.finishNode(node, \"FunctionTypeParam\");\n};\n\npp$8.reinterpretTypeAsFunctionTypeParam = function (type) {\n  var node = this.startNodeAt(type.start, type.loc.start);\n  node.name = null;\n  node.optional = false;\n  node.typeAnnotation = type;\n  return this.finishNode(node, \"FunctionTypeParam\");\n};\n\npp$8.flowParseFunctionTypeParams = function () {\n  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  var ret = { params: params, rest: null };\n  while (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n    ret.params.push(this.flowParseFunctionTypeParam());\n    if (!this.match(types.parenR)) {\n      this.expect(types.comma);\n    }\n  }\n  if (this.eat(types.ellipsis)) {\n    ret.rest = this.flowParseFunctionTypeParam();\n  }\n  return ret;\n};\n\npp$8.flowIdentToTypeAnnotation = function (startPos, startLoc, node, id) {\n  switch (id.name) {\n    case \"any\":\n      return this.finishNode(node, \"AnyTypeAnnotation\");\n\n    case \"void\":\n      return this.finishNode(node, \"VoidTypeAnnotation\");\n\n    case \"bool\":\n    case \"boolean\":\n      return this.finishNode(node, \"BooleanTypeAnnotation\");\n\n    case \"mixed\":\n      return this.finishNode(node, \"MixedTypeAnnotation\");\n\n    case \"empty\":\n      return this.finishNode(node, \"EmptyTypeAnnotation\");\n\n    case \"number\":\n      return this.finishNode(node, \"NumberTypeAnnotation\");\n\n    case \"string\":\n      return this.finishNode(node, \"StringTypeAnnotation\");\n\n    default:\n      return this.flowParseGenericType(startPos, startLoc, id);\n  }\n};\n\n// The parsing of types roughly parallels the parsing of expressions, and\n// primary types are kind of like primary expressions...they're the\n// primitives with which other types are constructed.\npp$8.flowParsePrimaryType = function () {\n  var startPos = this.state.start;\n  var startLoc = this.state.startLoc;\n  var node = this.startNode();\n  var tmp = void 0;\n  var type = void 0;\n  var isGroupedType = false;\n  var oldNoAnonFunctionType = this.state.noAnonFunctionType;\n\n  switch (this.state.type) {\n    case types.name:\n      return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());\n\n    case types.braceL:\n      return this.flowParseObjectType(false, false, true);\n\n    case types.braceBarL:\n      return this.flowParseObjectType(false, true, true);\n\n    case types.bracketL:\n      return this.flowParseTupleType();\n\n    case types.relational:\n      if (this.state.value === \"<\") {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n        this.expect(types.parenL);\n        tmp = this.flowParseFunctionTypeParams();\n        node.params = tmp.params;\n        node.rest = tmp.rest;\n        this.expect(types.parenR);\n\n        this.expect(types.arrow);\n\n        node.returnType = this.flowParseType();\n\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n      }\n      break;\n\n    case types.parenL:\n      this.next();\n\n      // Check to see if this is actually a grouped type\n      if (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n        if (this.match(types.name)) {\n          var token = this.lookahead().type;\n          isGroupedType = token !== types.question && token !== types.colon;\n        } else {\n          isGroupedType = true;\n        }\n      }\n\n      if (isGroupedType) {\n        this.state.noAnonFunctionType = false;\n        type = this.flowParseType();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n        // A `,` or a `) =>` means this is an anonymous function type\n        if (this.state.noAnonFunctionType || !(this.match(types.comma) || this.match(types.parenR) && this.lookahead().type === types.arrow)) {\n          this.expect(types.parenR);\n          return type;\n        } else {\n          // Eat a comma if there is one\n          this.eat(types.comma);\n        }\n      }\n\n      if (type) {\n        tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);\n      } else {\n        tmp = this.flowParseFunctionTypeParams();\n      }\n\n      node.params = tmp.params;\n      node.rest = tmp.rest;\n\n      this.expect(types.parenR);\n\n      this.expect(types.arrow);\n\n      node.returnType = this.flowParseType();\n\n      node.typeParameters = null;\n\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n\n    case types.string:\n      return this.parseLiteral(this.state.value, \"StringLiteralTypeAnnotation\");\n\n    case types._true:case types._false:\n      node.value = this.match(types._true);\n      this.next();\n      return this.finishNode(node, \"BooleanLiteralTypeAnnotation\");\n\n    case types.plusMin:\n      if (this.state.value === \"-\") {\n        this.next();\n        if (!this.match(types.num)) this.unexpected(null, \"Unexpected token, expected number\");\n\n        return this.parseLiteral(-this.state.value, \"NumericLiteralTypeAnnotation\", node.start, node.loc.start);\n      }\n\n      this.unexpected();\n    case types.num:\n      return this.parseLiteral(this.state.value, \"NumericLiteralTypeAnnotation\");\n\n    case types._null:\n      node.value = this.match(types._null);\n      this.next();\n      return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n\n    case types._this:\n      node.value = this.match(types._this);\n      this.next();\n      return this.finishNode(node, \"ThisTypeAnnotation\");\n\n    case types.star:\n      this.next();\n      return this.finishNode(node, \"ExistentialTypeParam\");\n\n    default:\n      if (this.state.type.keyword === \"typeof\") {\n        return this.flowParseTypeofType();\n      }\n  }\n\n  this.unexpected();\n};\n\npp$8.flowParsePostfixType = function () {\n  var startPos = this.state.start,\n      startLoc = this.state.startLoc;\n  var type = this.flowParsePrimaryType();\n  while (!this.canInsertSemicolon() && this.match(types.bracketL)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.elementType = type;\n    this.expect(types.bracketL);\n    this.expect(types.bracketR);\n    type = this.finishNode(node, \"ArrayTypeAnnotation\");\n  }\n  return type;\n};\n\npp$8.flowParsePrefixType = function () {\n  var node = this.startNode();\n  if (this.eat(types.question)) {\n    node.typeAnnotation = this.flowParsePrefixType();\n    return this.finishNode(node, \"NullableTypeAnnotation\");\n  } else {\n    return this.flowParsePostfixType();\n  }\n};\n\npp$8.flowParseAnonFunctionWithoutParens = function () {\n  var param = this.flowParsePrefixType();\n  if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {\n    var node = this.startNodeAt(param.start, param.loc.start);\n    node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n    node.rest = null;\n    node.returnType = this.flowParseType();\n    node.typeParameters = null;\n    return this.finishNode(node, \"FunctionTypeAnnotation\");\n  }\n  return param;\n};\n\npp$8.flowParseIntersectionType = function () {\n  var node = this.startNode();\n  this.eat(types.bitwiseAND);\n  var type = this.flowParseAnonFunctionWithoutParens();\n  node.types = [type];\n  while (this.eat(types.bitwiseAND)) {\n    node.types.push(this.flowParseAnonFunctionWithoutParens());\n  }\n  return node.types.length === 1 ? type : this.finishNode(node, \"IntersectionTypeAnnotation\");\n};\n\npp$8.flowParseUnionType = function () {\n  var node = this.startNode();\n  this.eat(types.bitwiseOR);\n  var type = this.flowParseIntersectionType();\n  node.types = [type];\n  while (this.eat(types.bitwiseOR)) {\n    node.types.push(this.flowParseIntersectionType());\n  }\n  return node.types.length === 1 ? type : this.finishNode(node, \"UnionTypeAnnotation\");\n};\n\npp$8.flowParseType = function () {\n  var oldInType = this.state.inType;\n  this.state.inType = true;\n  var type = this.flowParseUnionType();\n  this.state.inType = oldInType;\n  return type;\n};\n\npp$8.flowParseTypeAnnotation = function () {\n  var node = this.startNode();\n  node.typeAnnotation = this.flowParseTypeInitialiser();\n  return this.finishNode(node, \"TypeAnnotation\");\n};\n\npp$8.flowParseTypeAndPredicateAnnotation = function () {\n  var node = this.startNode();\n\n  var _flowParseTypeAndPred2 = this.flowParseTypeAndPredicateInitialiser();\n\n  node.typeAnnotation = _flowParseTypeAndPred2[0];\n  node.predicate = _flowParseTypeAndPred2[1];\n\n  return this.finishNode(node, \"TypeAnnotation\");\n};\n\npp$8.flowParseTypeAnnotatableIdentifier = function () {\n  var ident = this.flowParseRestrictedIdentifier();\n  if (this.match(types.colon)) {\n    ident.typeAnnotation = this.flowParseTypeAnnotation();\n    this.finishNode(ident, ident.type);\n  }\n  return ident;\n};\n\npp$8.typeCastToParameter = function (node) {\n  node.expression.typeAnnotation = node.typeAnnotation;\n\n  return this.finishNodeAt(node.expression, node.expression.type, node.typeAnnotation.end, node.typeAnnotation.loc.end);\n};\n\npp$8.flowParseVariance = function () {\n  var variance = null;\n  if (this.match(types.plusMin)) {\n    if (this.state.value === \"+\") {\n      variance = \"plus\";\n    } else if (this.state.value === \"-\") {\n      variance = \"minus\";\n    }\n    this.next();\n  }\n  return variance;\n};\n\nvar flowPlugin = function (instance) {\n  // plain function return types: function name(): string {}\n  instance.extend(\"parseFunctionBody\", function (inner) {\n    return function (node, allowExpression) {\n      if (this.match(types.colon) && !allowExpression) {\n        // if allowExpression is true then we're parsing an arrow function and if\n        // there's a return type then it's been handled elsewhere\n        node.returnType = this.flowParseTypeAndPredicateAnnotation();\n      }\n\n      return inner.call(this, node, allowExpression);\n    };\n  });\n\n  // interfaces\n  instance.extend(\"parseStatement\", function (inner) {\n    return function (declaration, topLevel) {\n      // strict mode handling of `interface` since it's a reserved word\n      if (this.state.strict && this.match(types.name) && this.state.value === \"interface\") {\n        var node = this.startNode();\n        this.next();\n        return this.flowParseInterface(node);\n      } else {\n        return inner.call(this, declaration, topLevel);\n      }\n    };\n  });\n\n  // declares, interfaces and type aliases\n  instance.extend(\"parseExpressionStatement\", function (inner) {\n    return function (node, expr) {\n      if (expr.type === \"Identifier\") {\n        if (expr.name === \"declare\") {\n          if (this.match(types._class) || this.match(types.name) || this.match(types._function) || this.match(types._var) || this.match(types._export)) {\n            return this.flowParseDeclare(node);\n          }\n        } else if (this.match(types.name)) {\n          if (expr.name === \"interface\") {\n            return this.flowParseInterface(node);\n          } else if (expr.name === \"type\") {\n            return this.flowParseTypeAlias(node);\n          } else if (expr.name === \"opaque\") {\n            return this.flowParseOpaqueType(node, false);\n          }\n        }\n      }\n\n      return inner.call(this, node, expr);\n    };\n  });\n\n  // export type\n  instance.extend(\"shouldParseExportDeclaration\", function (inner) {\n    return function () {\n      return this.isContextual(\"type\") || this.isContextual(\"interface\") || this.isContextual(\"opaque\") || inner.call(this);\n    };\n  });\n\n  instance.extend(\"isExportDefaultSpecifier\", function (inner) {\n    return function () {\n      if (this.match(types.name) && (this.state.value === \"type\" || this.state.value === \"interface\" || this.state.value === \"opaque\")) {\n        return false;\n      }\n\n      return inner.call(this);\n    };\n  });\n\n  instance.extend(\"parseConditional\", function (inner) {\n    return function (expr, noIn, startPos, startLoc, refNeedsArrowPos) {\n      // only do the expensive clone if there is a question mark\n      // and if we come from inside parens\n      if (refNeedsArrowPos && this.match(types.question)) {\n        var state = this.state.clone();\n        try {\n          return inner.call(this, expr, noIn, startPos, startLoc);\n        } catch (err) {\n          if (err instanceof SyntaxError) {\n            this.state = state;\n            refNeedsArrowPos.start = err.pos || this.state.start;\n            return expr;\n          } else {\n            // istanbul ignore next: no such error is expected\n            throw err;\n          }\n        }\n      }\n\n      return inner.call(this, expr, noIn, startPos, startLoc);\n    };\n  });\n\n  instance.extend(\"parseParenItem\", function (inner) {\n    return function (node, startPos, startLoc) {\n      node = inner.call(this, node, startPos, startLoc);\n      if (this.eat(types.question)) {\n        node.optional = true;\n      }\n\n      if (this.match(types.colon)) {\n        var typeCastNode = this.startNodeAt(startPos, startLoc);\n        typeCastNode.expression = node;\n        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n\n        return this.finishNode(typeCastNode, \"TypeCastExpression\");\n      }\n\n      return node;\n    };\n  });\n\n  instance.extend(\"parseExport\", function (inner) {\n    return function (node) {\n      node = inner.call(this, node);\n      if (node.type === \"ExportNamedDeclaration\") {\n        node.exportKind = node.exportKind || \"value\";\n      }\n      return node;\n    };\n  });\n\n  instance.extend(\"parseExportDeclaration\", function (inner) {\n    return function (node) {\n      if (this.isContextual(\"type\")) {\n        node.exportKind = \"type\";\n\n        var declarationNode = this.startNode();\n        this.next();\n\n        if (this.match(types.braceL)) {\n          // export type { foo, bar };\n          node.specifiers = this.parseExportSpecifiers();\n          this.parseExportFrom(node);\n          return null;\n        } else {\n          // export type Foo = Bar;\n          return this.flowParseTypeAlias(declarationNode);\n        }\n      } else if (this.isContextual(\"opaque\")) {\n        node.exportKind = \"type\";\n\n        var _declarationNode = this.startNode();\n        this.next();\n        // export opaque type Foo = Bar;\n        return this.flowParseOpaqueType(_declarationNode, false);\n      } else if (this.isContextual(\"interface\")) {\n        node.exportKind = \"type\";\n        var _declarationNode2 = this.startNode();\n        this.next();\n        return this.flowParseInterface(_declarationNode2);\n      } else {\n        return inner.call(this, node);\n      }\n    };\n  });\n\n  instance.extend(\"parseClassId\", function (inner) {\n    return function (node) {\n      inner.apply(this, arguments);\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n    };\n  });\n\n  // don't consider `void` to be a keyword as then it'll use the void token type\n  // and set startExpr\n  instance.extend(\"isKeyword\", function (inner) {\n    return function (name) {\n      if (this.state.inType && name === \"void\") {\n        return false;\n      } else {\n        return inner.call(this, name);\n      }\n    };\n  });\n\n  // ensure that inside flow types, we bypass the jsx parser plugin\n  instance.extend(\"readToken\", function (inner) {\n    return function (code) {\n      if (this.state.inType && (code === 62 || code === 60)) {\n        return this.finishOp(types.relational, 1);\n      } else {\n        return inner.call(this, code);\n      }\n    };\n  });\n\n  // don't lex any token as a jsx one inside a flow type\n  instance.extend(\"jsx_readToken\", function (inner) {\n    return function () {\n      if (!this.state.inType) return inner.call(this);\n    };\n  });\n\n  instance.extend(\"toAssignable\", function (inner) {\n    return function (node, isBinding, contextDescription) {\n      if (node.type === \"TypeCastExpression\") {\n        return inner.call(this, this.typeCastToParameter(node), isBinding, contextDescription);\n      } else {\n        return inner.call(this, node, isBinding, contextDescription);\n      }\n    };\n  });\n\n  // turn type casts that we found in function parameter head into type annotated params\n  instance.extend(\"toAssignableList\", function (inner) {\n    return function (exprList, isBinding, contextDescription) {\n      for (var i = 0; i < exprList.length; i++) {\n        var expr = exprList[i];\n        if (expr && expr.type === \"TypeCastExpression\") {\n          exprList[i] = this.typeCastToParameter(expr);\n        }\n      }\n      return inner.call(this, exprList, isBinding, contextDescription);\n    };\n  });\n\n  // this is a list of nodes, from something like a call expression, we need to filter the\n  // type casts that we've found that are illegal in this context\n  instance.extend(\"toReferencedList\", function () {\n    return function (exprList) {\n      for (var i = 0; i < exprList.length; i++) {\n        var expr = exprList[i];\n        if (expr && expr._exprListItem && expr.type === \"TypeCastExpression\") {\n          this.raise(expr.start, \"Unexpected type cast\");\n        }\n      }\n\n      return exprList;\n    };\n  });\n\n  // parse an item inside a expression list eg. `(NODE, NODE)` where NODE represents\n  // the position where this function is called\n  instance.extend(\"parseExprListItem\", function (inner) {\n    return function () {\n      var container = this.startNode();\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var node = inner.call.apply(inner, [this].concat(args));\n      if (this.match(types.colon)) {\n        container._exprListItem = true;\n        container.expression = node;\n        container.typeAnnotation = this.flowParseTypeAnnotation();\n        return this.finishNode(container, \"TypeCastExpression\");\n      } else {\n        return node;\n      }\n    };\n  });\n\n  instance.extend(\"checkLVal\", function (inner) {\n    return function (node) {\n      if (node.type !== \"TypeCastExpression\") {\n        return inner.apply(this, arguments);\n      }\n    };\n  });\n\n  // parse class property type annotations\n  instance.extend(\"parseClassProperty\", function (inner) {\n    return function (node) {\n      delete node.variancePos;\n      if (this.match(types.colon)) {\n        node.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n      return inner.call(this, node);\n    };\n  });\n\n  // determine whether or not we're currently in the position where a class method would appear\n  instance.extend(\"isClassMethod\", function (inner) {\n    return function () {\n      return this.isRelational(\"<\") || inner.call(this);\n    };\n  });\n\n  // determine whether or not we're currently in the position where a class property would appear\n  instance.extend(\"isClassProperty\", function (inner) {\n    return function () {\n      return this.match(types.colon) || inner.call(this);\n    };\n  });\n\n  instance.extend(\"isNonstaticConstructor\", function (inner) {\n    return function (method) {\n      return !this.match(types.colon) && inner.call(this, method);\n    };\n  });\n\n  // parse type parameters for class methods\n  instance.extend(\"parseClassMethod\", function (inner) {\n    return function (classBody, method) {\n      if (method.variance) {\n        this.unexpected(method.variancePos);\n      }\n      delete method.variance;\n      delete method.variancePos;\n      if (this.isRelational(\"<\")) {\n        method.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      inner.call.apply(inner, [this, classBody, method].concat(args));\n    };\n  });\n\n  // parse a the super class type parameters and implements\n  instance.extend(\"parseClassSuper\", function (inner) {\n    return function (node, isStatement) {\n      inner.call(this, node, isStatement);\n      if (node.superClass && this.isRelational(\"<\")) {\n        node.superTypeParameters = this.flowParseTypeParameterInstantiation();\n      }\n      if (this.isContextual(\"implements\")) {\n        this.next();\n        var implemented = node.implements = [];\n        do {\n          var _node = this.startNode();\n          _node.id = this.parseIdentifier();\n          if (this.isRelational(\"<\")) {\n            _node.typeParameters = this.flowParseTypeParameterInstantiation();\n          } else {\n            _node.typeParameters = null;\n          }\n          implemented.push(this.finishNode(_node, \"ClassImplements\"));\n        } while (this.eat(types.comma));\n      }\n    };\n  });\n\n  instance.extend(\"parsePropertyName\", function (inner) {\n    return function (node) {\n      var variancePos = this.state.start;\n      var variance = this.flowParseVariance();\n      var key = inner.call(this, node);\n      node.variance = variance;\n      node.variancePos = variancePos;\n      return key;\n    };\n  });\n\n  // parse type parameters for object method shorthand\n  instance.extend(\"parseObjPropValue\", function (inner) {\n    return function (prop) {\n      if (prop.variance) {\n        this.unexpected(prop.variancePos);\n      }\n      delete prop.variance;\n      delete prop.variancePos;\n\n      var typeParameters = void 0;\n\n      // method shorthand\n      if (this.isRelational(\"<\")) {\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        if (!this.match(types.parenL)) this.unexpected();\n      }\n\n      inner.apply(this, arguments);\n\n      // add typeParameters if we found them\n      if (typeParameters) {\n        (prop.value || prop).typeParameters = typeParameters;\n      }\n    };\n  });\n\n  instance.extend(\"parseAssignableListItemTypes\", function () {\n    return function (param) {\n      if (this.eat(types.question)) {\n        param.optional = true;\n      }\n      if (this.match(types.colon)) {\n        param.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n      this.finishNode(param, param.type);\n      return param;\n    };\n  });\n\n  instance.extend(\"parseMaybeDefault\", function (inner) {\n    return function () {\n      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      var node = inner.apply(this, args);\n\n      if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n        this.raise(node.typeAnnotation.start, \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\");\n      }\n\n      return node;\n    };\n  });\n\n  // parse typeof and type imports\n  instance.extend(\"parseImportSpecifiers\", function (inner) {\n    return function (node) {\n      node.importKind = \"value\";\n\n      var kind = null;\n      if (this.match(types._typeof)) {\n        kind = \"typeof\";\n      } else if (this.isContextual(\"type\")) {\n        kind = \"type\";\n      }\n      if (kind) {\n        var lh = this.lookahead();\n        if (lh.type === types.name && lh.value !== \"from\" || lh.type === types.braceL || lh.type === types.star) {\n          this.next();\n          node.importKind = kind;\n        }\n      }\n\n      inner.call(this, node);\n    };\n  });\n\n  // parse import-type/typeof shorthand\n  instance.extend(\"parseImportSpecifier\", function () {\n    return function (node) {\n      var specifier = this.startNode();\n      var firstIdentLoc = this.state.start;\n      var firstIdent = this.parseIdentifier(true);\n\n      var specifierTypeKind = null;\n      if (firstIdent.name === \"type\") {\n        specifierTypeKind = \"type\";\n      } else if (firstIdent.name === \"typeof\") {\n        specifierTypeKind = \"typeof\";\n      }\n\n      var isBinding = false;\n      if (this.isContextual(\"as\")) {\n        var as_ident = this.parseIdentifier(true);\n        if (specifierTypeKind !== null && !this.match(types.name) && !this.state.type.keyword) {\n          // `import {type as ,` or `import {type as }`\n          specifier.imported = as_ident;\n          specifier.importKind = specifierTypeKind;\n          specifier.local = as_ident.__clone();\n        } else {\n          // `import {type as foo`\n          specifier.imported = firstIdent;\n          specifier.importKind = null;\n          specifier.local = this.parseIdentifier();\n        }\n      } else if (specifierTypeKind !== null && (this.match(types.name) || this.state.type.keyword)) {\n        // `import {type foo`\n        specifier.imported = this.parseIdentifier(true);\n        specifier.importKind = specifierTypeKind;\n        if (this.eatContextual(\"as\")) {\n          specifier.local = this.parseIdentifier();\n        } else {\n          isBinding = true;\n          specifier.local = specifier.imported.__clone();\n        }\n      } else {\n        isBinding = true;\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n        specifier.local = specifier.imported.__clone();\n      }\n\n      if ((node.importKind === \"type\" || node.importKind === \"typeof\") && (specifier.importKind === \"type\" || specifier.importKind === \"typeof\")) {\n        this.raise(firstIdentLoc, \"`The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements`\");\n      }\n\n      if (isBinding) this.checkReservedWord(specifier.local.name, specifier.start, true, true);\n\n      this.checkLVal(specifier.local, true, undefined, \"import specifier\");\n      node.specifiers.push(this.finishNode(specifier, \"ImportSpecifier\"));\n    };\n  });\n\n  // parse function type parameters - function foo<T>() {}\n  instance.extend(\"parseFunctionParams\", function (inner) {\n    return function (node) {\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n      inner.call(this, node);\n    };\n  });\n\n  // parse flow type annotations on variable declarator heads - let foo: string = bar\n  instance.extend(\"parseVarHead\", function (inner) {\n    return function (decl) {\n      inner.call(this, decl);\n      if (this.match(types.colon)) {\n        decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n        this.finishNode(decl.id, decl.id.type);\n      }\n    };\n  });\n\n  // parse the return type of an async arrow function - let foo = (async (): number => {});\n  instance.extend(\"parseAsyncArrowFromCallExpression\", function (inner) {\n    return function (node, call) {\n      if (this.match(types.colon)) {\n        var oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        node.returnType = this.flowParseTypeAnnotation();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n      }\n\n      return inner.call(this, node, call);\n    };\n  });\n\n  // todo description\n  instance.extend(\"shouldParseAsyncArrow\", function (inner) {\n    return function () {\n      return this.match(types.colon) || inner.call(this);\n    };\n  });\n\n  // We need to support type parameter declarations for arrow functions. This\n  // is tricky. There are three situations we need to handle\n  //\n  // 1. This is either JSX or an arrow function. We'll try JSX first. If that\n  //    fails, we'll try an arrow function. If that fails, we'll throw the JSX\n  //    error.\n  // 2. This is an arrow function. We'll parse the type parameter declaration,\n  //    parse the rest, make sure the rest is an arrow function, and go from\n  //    there\n  // 3. This is neither. Just call the inner function\n  instance.extend(\"parseMaybeAssign\", function (inner) {\n    return function () {\n      var jsxError = null;\n\n      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      if (types.jsxTagStart && this.match(types.jsxTagStart)) {\n        var state = this.state.clone();\n        try {\n          return inner.apply(this, args);\n        } catch (err) {\n          if (err instanceof SyntaxError) {\n            this.state = state;\n\n            // Remove `tc.j_expr` and `tc.j_oTag` from context added\n            // by parsing `jsxTagStart` to stop the JSX plugin from\n            // messing with the tokens\n            this.state.context.length -= 2;\n\n            jsxError = err;\n          } else {\n            // istanbul ignore next: no such error is expected\n            throw err;\n          }\n        }\n      }\n\n      if (jsxError != null || this.isRelational(\"<\")) {\n        var arrowExpression = void 0;\n        var typeParameters = void 0;\n        try {\n          typeParameters = this.flowParseTypeParameterDeclaration();\n\n          arrowExpression = inner.apply(this, args);\n          arrowExpression.typeParameters = typeParameters;\n          arrowExpression.start = typeParameters.start;\n          arrowExpression.loc.start = typeParameters.loc.start;\n        } catch (err) {\n          throw jsxError || err;\n        }\n\n        if (arrowExpression.type === \"ArrowFunctionExpression\") {\n          return arrowExpression;\n        } else if (jsxError != null) {\n          throw jsxError;\n        } else {\n          this.raise(typeParameters.start, \"Expected an arrow function after this type parameter declaration\");\n        }\n      }\n\n      return inner.apply(this, args);\n    };\n  });\n\n  // handle return types for arrow functions\n  instance.extend(\"parseArrow\", function (inner) {\n    return function (node) {\n      if (this.match(types.colon)) {\n        var state = this.state.clone();\n        try {\n          var oldNoAnonFunctionType = this.state.noAnonFunctionType;\n          this.state.noAnonFunctionType = true;\n          var returnType = this.flowParseTypeAndPredicateAnnotation();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n          if (this.canInsertSemicolon()) this.unexpected();\n          if (!this.match(types.arrow)) this.unexpected();\n          // assign after it is clear it is an arrow\n          node.returnType = returnType;\n        } catch (err) {\n          if (err instanceof SyntaxError) {\n            this.state = state;\n          } else {\n            // istanbul ignore next: no such error is expected\n            throw err;\n          }\n        }\n      }\n\n      return inner.call(this, node);\n    };\n  });\n\n  instance.extend(\"shouldParseArrow\", function (inner) {\n    return function () {\n      return this.match(types.colon) || inner.call(this);\n    };\n  });\n};\n\n// Adapted from String.fromcodepoint to export the function without modifying String\n/*! https://mths.be/fromcodepoint v0.2.1 by @mathias */\n\n// The MIT License (MIT)\n// Copyright (c) Mathias Bynens\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and\n// associated documentation files (the \"Software\"), to deal in the Software without restriction,\n// including without limitation the rights to use, copy, modify, merge, publish, distribute,\n// sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all copies or\n// substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT\n// NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar fromCodePoint = String.fromCodePoint;\n\nif (!fromCodePoint) {\n  var stringFromCharCode = String.fromCharCode;\n  var floor = Math.floor;\n  fromCodePoint = function fromCodePoint() {\n    var MAX_SIZE = 0x4000;\n    var codeUnits = [];\n    var highSurrogate = void 0;\n    var lowSurrogate = void 0;\n    var index = -1;\n    var length = arguments.length;\n    if (!length) {\n      return \"\";\n    }\n    var result = \"\";\n    while (++index < length) {\n      var codePoint = Number(arguments[index]);\n      if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n      codePoint < 0 || // not a valid Unicode code point\n      codePoint > 0x10FFFF || // not a valid Unicode code point\n      floor(codePoint) != codePoint // not an integer\n      ) {\n          throw RangeError(\"Invalid code point: \" + codePoint);\n        }\n      if (codePoint <= 0xFFFF) {\n        // BMP code point\n        codeUnits.push(codePoint);\n      } else {\n        // Astral code point; split in surrogate halves\n        // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        codePoint -= 0x10000;\n        highSurrogate = (codePoint >> 10) + 0xD800;\n        lowSurrogate = codePoint % 0x400 + 0xDC00;\n        codeUnits.push(highSurrogate, lowSurrogate);\n      }\n      if (index + 1 == length || codeUnits.length > MAX_SIZE) {\n        result += stringFromCharCode.apply(null, codeUnits);\n        codeUnits.length = 0;\n      }\n    }\n    return result;\n  };\n}\n\nvar fromCodePoint$1 = fromCodePoint;\n\nvar XHTMLEntities = {\n  quot: \"\\\"\",\n  amp: \"&\",\n  apos: \"'\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\xA0\",\n  iexcl: \"\\xA1\",\n  cent: \"\\xA2\",\n  pound: \"\\xA3\",\n  curren: \"\\xA4\",\n  yen: \"\\xA5\",\n  brvbar: \"\\xA6\",\n  sect: \"\\xA7\",\n  uml: \"\\xA8\",\n  copy: \"\\xA9\",\n  ordf: \"\\xAA\",\n  laquo: \"\\xAB\",\n  not: \"\\xAC\",\n  shy: \"\\xAD\",\n  reg: \"\\xAE\",\n  macr: \"\\xAF\",\n  deg: \"\\xB0\",\n  plusmn: \"\\xB1\",\n  sup2: \"\\xB2\",\n  sup3: \"\\xB3\",\n  acute: \"\\xB4\",\n  micro: \"\\xB5\",\n  para: \"\\xB6\",\n  middot: \"\\xB7\",\n  cedil: \"\\xB8\",\n  sup1: \"\\xB9\",\n  ordm: \"\\xBA\",\n  raquo: \"\\xBB\",\n  frac14: \"\\xBC\",\n  frac12: \"\\xBD\",\n  frac34: \"\\xBE\",\n  iquest: \"\\xBF\",\n  Agrave: \"\\xC0\",\n  Aacute: \"\\xC1\",\n  Acirc: \"\\xC2\",\n  Atilde: \"\\xC3\",\n  Auml: \"\\xC4\",\n  Aring: \"\\xC5\",\n  AElig: \"\\xC6\",\n  Ccedil: \"\\xC7\",\n  Egrave: \"\\xC8\",\n  Eacute: \"\\xC9\",\n  Ecirc: \"\\xCA\",\n  Euml: \"\\xCB\",\n  Igrave: \"\\xCC\",\n  Iacute: \"\\xCD\",\n  Icirc: \"\\xCE\",\n  Iuml: \"\\xCF\",\n  ETH: \"\\xD0\",\n  Ntilde: \"\\xD1\",\n  Ograve: \"\\xD2\",\n  Oacute: \"\\xD3\",\n  Ocirc: \"\\xD4\",\n  Otilde: \"\\xD5\",\n  Ouml: \"\\xD6\",\n  times: \"\\xD7\",\n  Oslash: \"\\xD8\",\n  Ugrave: \"\\xD9\",\n  Uacute: \"\\xDA\",\n  Ucirc: \"\\xDB\",\n  Uuml: \"\\xDC\",\n  Yacute: \"\\xDD\",\n  THORN: \"\\xDE\",\n  szlig: \"\\xDF\",\n  agrave: \"\\xE0\",\n  aacute: \"\\xE1\",\n  acirc: \"\\xE2\",\n  atilde: \"\\xE3\",\n  auml: \"\\xE4\",\n  aring: \"\\xE5\",\n  aelig: \"\\xE6\",\n  ccedil: \"\\xE7\",\n  egrave: \"\\xE8\",\n  eacute: \"\\xE9\",\n  ecirc: \"\\xEA\",\n  euml: \"\\xEB\",\n  igrave: \"\\xEC\",\n  iacute: \"\\xED\",\n  icirc: \"\\xEE\",\n  iuml: \"\\xEF\",\n  eth: \"\\xF0\",\n  ntilde: \"\\xF1\",\n  ograve: \"\\xF2\",\n  oacute: \"\\xF3\",\n  ocirc: \"\\xF4\",\n  otilde: \"\\xF5\",\n  ouml: \"\\xF6\",\n  divide: \"\\xF7\",\n  oslash: \"\\xF8\",\n  ugrave: \"\\xF9\",\n  uacute: \"\\xFA\",\n  ucirc: \"\\xFB\",\n  uuml: \"\\xFC\",\n  yacute: \"\\xFD\",\n  thorn: \"\\xFE\",\n  yuml: \"\\xFF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  \"int\": \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\"\n};\n\nvar HEX_NUMBER = /^[\\da-fA-F]+$/;\nvar DECIMAL_NUMBER = /^\\d+$/;\n\ntypes$1.j_oTag = new TokContext(\"<tag\", false);\ntypes$1.j_cTag = new TokContext(\"</tag\", false);\ntypes$1.j_expr = new TokContext(\"<tag>...</tag>\", true, true);\n\ntypes.jsxName = new TokenType(\"jsxName\");\ntypes.jsxText = new TokenType(\"jsxText\", { beforeExpr: true });\ntypes.jsxTagStart = new TokenType(\"jsxTagStart\", { startsExpr: true });\ntypes.jsxTagEnd = new TokenType(\"jsxTagEnd\");\n\ntypes.jsxTagStart.updateContext = function () {\n  this.state.context.push(types$1.j_expr); // treat as beginning of JSX expression\n  this.state.context.push(types$1.j_oTag); // start opening tag context\n  this.state.exprAllowed = false;\n};\n\ntypes.jsxTagEnd.updateContext = function (prevType) {\n  var out = this.state.context.pop();\n  if (out === types$1.j_oTag && prevType === types.slash || out === types$1.j_cTag) {\n    this.state.context.pop();\n    this.state.exprAllowed = this.curContext() === types$1.j_expr;\n  } else {\n    this.state.exprAllowed = true;\n  }\n};\n\nvar pp$9 = Parser.prototype;\n\n// Reads inline JSX contents token.\n\npp$9.jsxReadToken = function () {\n  var out = \"\";\n  var chunkStart = this.state.pos;\n  for (;;) {\n    if (this.state.pos >= this.input.length) {\n      this.raise(this.state.start, \"Unterminated JSX contents\");\n    }\n\n    var ch = this.input.charCodeAt(this.state.pos);\n\n    switch (ch) {\n      case 60: // \"<\"\n      case 123:\n        // \"{\"\n        if (this.state.pos === this.state.start) {\n          if (ch === 60 && this.state.exprAllowed) {\n            ++this.state.pos;\n            return this.finishToken(types.jsxTagStart);\n          }\n          return this.getTokenFromCode(ch);\n        }\n        out += this.input.slice(chunkStart, this.state.pos);\n        return this.finishToken(types.jsxText, out);\n\n      case 38:\n        // \"&\"\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadEntity();\n        chunkStart = this.state.pos;\n        break;\n\n      default:\n        if (isNewLine(ch)) {\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadNewLine(true);\n          chunkStart = this.state.pos;\n        } else {\n          ++this.state.pos;\n        }\n    }\n  }\n};\n\npp$9.jsxReadNewLine = function (normalizeCRLF) {\n  var ch = this.input.charCodeAt(this.state.pos);\n  var out = void 0;\n  ++this.state.pos;\n  if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {\n    ++this.state.pos;\n    out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n  } else {\n    out = String.fromCharCode(ch);\n  }\n  ++this.state.curLine;\n  this.state.lineStart = this.state.pos;\n\n  return out;\n};\n\npp$9.jsxReadString = function (quote) {\n  var out = \"\";\n  var chunkStart = ++this.state.pos;\n  for (;;) {\n    if (this.state.pos >= this.input.length) {\n      this.raise(this.state.start, \"Unterminated string constant\");\n    }\n\n    var ch = this.input.charCodeAt(this.state.pos);\n    if (ch === quote) break;\n    if (ch === 38) {\n      // \"&\"\n      out += this.input.slice(chunkStart, this.state.pos);\n      out += this.jsxReadEntity();\n      chunkStart = this.state.pos;\n    } else if (isNewLine(ch)) {\n      out += this.input.slice(chunkStart, this.state.pos);\n      out += this.jsxReadNewLine(false);\n      chunkStart = this.state.pos;\n    } else {\n      ++this.state.pos;\n    }\n  }\n  out += this.input.slice(chunkStart, this.state.pos++);\n  return this.finishToken(types.string, out);\n};\n\npp$9.jsxReadEntity = function () {\n  var str = \"\";\n  var count = 0;\n  var entity = void 0;\n  var ch = this.input[this.state.pos];\n\n  var startPos = ++this.state.pos;\n  while (this.state.pos < this.input.length && count++ < 10) {\n    ch = this.input[this.state.pos++];\n    if (ch === \";\") {\n      if (str[0] === \"#\") {\n        if (str[1] === \"x\") {\n          str = str.substr(2);\n          if (HEX_NUMBER.test(str)) entity = fromCodePoint$1(parseInt(str, 16));\n        } else {\n          str = str.substr(1);\n          if (DECIMAL_NUMBER.test(str)) entity = fromCodePoint$1(parseInt(str, 10));\n        }\n      } else {\n        entity = XHTMLEntities[str];\n      }\n      break;\n    }\n    str += ch;\n  }\n  if (!entity) {\n    this.state.pos = startPos;\n    return \"&\";\n  }\n  return entity;\n};\n\n// Read a JSX identifier (valid tag or attribute name).\n//\n// Optimized version since JSX identifiers can\"t contain\n// escape characters and so can be read as single slice.\n// Also assumes that first character was already checked\n// by isIdentifierStart in readToken.\n\npp$9.jsxReadWord = function () {\n  var ch = void 0;\n  var start = this.state.pos;\n  do {\n    ch = this.input.charCodeAt(++this.state.pos);\n  } while (isIdentifierChar(ch) || ch === 45); // \"-\"\n  return this.finishToken(types.jsxName, this.input.slice(start, this.state.pos));\n};\n\n// Transforms JSX element name to string.\n\nfunction getQualifiedJSXName(object) {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n\n  if (object.type === \"JSXMemberExpression\") {\n    return getQualifiedJSXName(object.object) + \".\" + getQualifiedJSXName(object.property);\n  }\n}\n\n// Parse next token as JSX identifier\n\npp$9.jsxParseIdentifier = function () {\n  var node = this.startNode();\n  if (this.match(types.jsxName)) {\n    node.name = this.state.value;\n  } else if (this.state.type.keyword) {\n    node.name = this.state.type.keyword;\n  } else {\n    this.unexpected();\n  }\n  this.next();\n  return this.finishNode(node, \"JSXIdentifier\");\n};\n\n// Parse namespaced identifier.\n\npp$9.jsxParseNamespacedName = function () {\n  var startPos = this.state.start;\n  var startLoc = this.state.startLoc;\n  var name = this.jsxParseIdentifier();\n  if (!this.eat(types.colon)) return name;\n\n  var node = this.startNodeAt(startPos, startLoc);\n  node.namespace = name;\n  node.name = this.jsxParseIdentifier();\n  return this.finishNode(node, \"JSXNamespacedName\");\n};\n\n// Parses element name in any form - namespaced, member\n// or single identifier.\n\npp$9.jsxParseElementName = function () {\n  var startPos = this.state.start;\n  var startLoc = this.state.startLoc;\n  var node = this.jsxParseNamespacedName();\n  while (this.eat(types.dot)) {\n    var newNode = this.startNodeAt(startPos, startLoc);\n    newNode.object = node;\n    newNode.property = this.jsxParseIdentifier();\n    node = this.finishNode(newNode, \"JSXMemberExpression\");\n  }\n  return node;\n};\n\n// Parses any type of JSX attribute value.\n\npp$9.jsxParseAttributeValue = function () {\n  var node = void 0;\n  switch (this.state.type) {\n    case types.braceL:\n      node = this.jsxParseExpressionContainer();\n      if (node.expression.type === \"JSXEmptyExpression\") {\n        this.raise(node.start, \"JSX attributes must only be assigned a non-empty expression\");\n      } else {\n        return node;\n      }\n\n    case types.jsxTagStart:\n    case types.string:\n      node = this.parseExprAtom();\n      node.extra = null;\n      return node;\n\n    default:\n      this.raise(this.state.start, \"JSX value should be either an expression or a quoted JSX text\");\n  }\n};\n\n// JSXEmptyExpression is unique type since it doesn't actually parse anything,\n// and so it should start at the end of last read token (left brace) and finish\n// at the beginning of the next one (right brace).\n\npp$9.jsxParseEmptyExpression = function () {\n  var node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);\n  return this.finishNodeAt(node, \"JSXEmptyExpression\", this.state.start, this.state.startLoc);\n};\n\n// Parse JSX spread child\n\npp$9.jsxParseSpreadChild = function () {\n  var node = this.startNode();\n  this.expect(types.braceL);\n  this.expect(types.ellipsis);\n  node.expression = this.parseExpression();\n  this.expect(types.braceR);\n\n  return this.finishNode(node, \"JSXSpreadChild\");\n};\n\n// Parses JSX expression enclosed into curly brackets.\n\n\npp$9.jsxParseExpressionContainer = function () {\n  var node = this.startNode();\n  this.next();\n  if (this.match(types.braceR)) {\n    node.expression = this.jsxParseEmptyExpression();\n  } else {\n    node.expression = this.parseExpression();\n  }\n  this.expect(types.braceR);\n  return this.finishNode(node, \"JSXExpressionContainer\");\n};\n\n// Parses following JSX attribute name-value pair.\n\npp$9.jsxParseAttribute = function () {\n  var node = this.startNode();\n  if (this.eat(types.braceL)) {\n    this.expect(types.ellipsis);\n    node.argument = this.parseMaybeAssign();\n    this.expect(types.braceR);\n    return this.finishNode(node, \"JSXSpreadAttribute\");\n  }\n  node.name = this.jsxParseNamespacedName();\n  node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null;\n  return this.finishNode(node, \"JSXAttribute\");\n};\n\n// Parses JSX opening tag starting after \"<\".\n\npp$9.jsxParseOpeningElementAt = function (startPos, startLoc) {\n  var node = this.startNodeAt(startPos, startLoc);\n  node.attributes = [];\n  node.name = this.jsxParseElementName();\n  while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) {\n    node.attributes.push(this.jsxParseAttribute());\n  }\n  node.selfClosing = this.eat(types.slash);\n  this.expect(types.jsxTagEnd);\n  return this.finishNode(node, \"JSXOpeningElement\");\n};\n\n// Parses JSX closing tag starting after \"</\".\n\npp$9.jsxParseClosingElementAt = function (startPos, startLoc) {\n  var node = this.startNodeAt(startPos, startLoc);\n  node.name = this.jsxParseElementName();\n  this.expect(types.jsxTagEnd);\n  return this.finishNode(node, \"JSXClosingElement\");\n};\n\n// Parses entire JSX element, including it\"s opening tag\n// (starting after \"<\"), attributes, contents and closing tag.\n\npp$9.jsxParseElementAt = function (startPos, startLoc) {\n  var node = this.startNodeAt(startPos, startLoc);\n  var children = [];\n  var openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);\n  var closingElement = null;\n\n  if (!openingElement.selfClosing) {\n    contents: for (;;) {\n      switch (this.state.type) {\n        case types.jsxTagStart:\n          startPos = this.state.start;startLoc = this.state.startLoc;\n          this.next();\n          if (this.eat(types.slash)) {\n            closingElement = this.jsxParseClosingElementAt(startPos, startLoc);\n            break contents;\n          }\n          children.push(this.jsxParseElementAt(startPos, startLoc));\n          break;\n\n        case types.jsxText:\n          children.push(this.parseExprAtom());\n          break;\n\n        case types.braceL:\n          if (this.lookahead().type === types.ellipsis) {\n            children.push(this.jsxParseSpreadChild());\n          } else {\n            children.push(this.jsxParseExpressionContainer());\n          }\n\n          break;\n\n        // istanbul ignore next - should never happen\n        default:\n          this.unexpected();\n      }\n    }\n\n    if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n      this.raise(closingElement.start, \"Expected corresponding JSX closing tag for <\" + getQualifiedJSXName(openingElement.name) + \">\");\n    }\n  }\n\n  node.openingElement = openingElement;\n  node.closingElement = closingElement;\n  node.children = children;\n  if (this.match(types.relational) && this.state.value === \"<\") {\n    this.raise(this.state.start, \"Adjacent JSX elements must be wrapped in an enclosing tag\");\n  }\n  return this.finishNode(node, \"JSXElement\");\n};\n\n// Parses entire JSX element from current position.\n\npp$9.jsxParseElement = function () {\n  var startPos = this.state.start;\n  var startLoc = this.state.startLoc;\n  this.next();\n  return this.jsxParseElementAt(startPos, startLoc);\n};\n\nvar jsxPlugin = function (instance) {\n  instance.extend(\"parseExprAtom\", function (inner) {\n    return function (refShortHandDefaultPos) {\n      if (this.match(types.jsxText)) {\n        var node = this.parseLiteral(this.state.value, \"JSXText\");\n        // https://github.com/babel/babel/issues/2078\n        node.extra = null;\n        return node;\n      } else if (this.match(types.jsxTagStart)) {\n        return this.jsxParseElement();\n      } else {\n        return inner.call(this, refShortHandDefaultPos);\n      }\n    };\n  });\n\n  instance.extend(\"readToken\", function (inner) {\n    return function (code) {\n      if (this.state.inPropertyName) return inner.call(this, code);\n\n      var context = this.curContext();\n\n      if (context === types$1.j_expr) {\n        return this.jsxReadToken();\n      }\n\n      if (context === types$1.j_oTag || context === types$1.j_cTag) {\n        if (isIdentifierStart(code)) {\n          return this.jsxReadWord();\n        }\n\n        if (code === 62) {\n          ++this.state.pos;\n          return this.finishToken(types.jsxTagEnd);\n        }\n\n        if ((code === 34 || code === 39) && context === types$1.j_oTag) {\n          return this.jsxReadString(code);\n        }\n      }\n\n      if (code === 60 && this.state.exprAllowed) {\n        ++this.state.pos;\n        return this.finishToken(types.jsxTagStart);\n      }\n\n      return inner.call(this, code);\n    };\n  });\n\n  instance.extend(\"updateContext\", function (inner) {\n    return function (prevType) {\n      if (this.match(types.braceL)) {\n        var curContext = this.curContext();\n        if (curContext === types$1.j_oTag) {\n          this.state.context.push(types$1.braceExpression);\n        } else if (curContext === types$1.j_expr) {\n          this.state.context.push(types$1.templateQuasi);\n        } else {\n          inner.call(this, prevType);\n        }\n        this.state.exprAllowed = true;\n      } else if (this.match(types.slash) && prevType === types.jsxTagStart) {\n        this.state.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore\n        this.state.context.push(types$1.j_cTag); // reconsider as closing tag context\n        this.state.exprAllowed = false;\n      } else {\n        return inner.call(this, prevType);\n      }\n    };\n  });\n};\n\nplugins.estree = estreePlugin;\nplugins.flow = flowPlugin;\nplugins.jsx = jsxPlugin;\n\nfunction parse(input, options) {\n  return new Parser(options, input).parse();\n}\n\nfunction parseExpression(input, options) {\n  var parser = new Parser(options, input);\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n  return parser.getExpression();\n}\n\nexports.parse = parse;\nexports.parseExpression = parseExpression;\nexports.tokTypes = types;\n","import * as types from \"babel-types\";\nimport { Path } from \"./path\";\nimport { IEcmaScriptMap } from \"./type\";\nimport { es5 } from \"./standard/es5\";\nimport { es2015 } from \"./standard/es2015\";\nimport { es2016 } from \"./standard/es2016\";\nimport { es2017 } from \"./standard/es2017\";\nimport { experimental } from \"./standard/experimental\";\n\nconst visitors: IEcmaScriptMap = {\n  ...es5,\n  ...es2015,\n  ...es2016,\n  ...es2017,\n  ...experimental\n};\n\nexport default function evaluate(path: Path<types.Node>) {\n  path.evaluate = evaluate;\n  const handler = visitors[path.node.type];\n  return handler(path);\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__13__;","export class Prototype {\n  constructor(public constructor) {}\n}\n","export class This {\n  constructor(public context) {}\n}\n","import * as types from \"babel-types\";\nimport * as isFunction from \"lodash.isfunction\";\nimport {\n  ErrInvalidIterable,\n  ErrNoSuper,\n  ErrNotDefined,\n  ErrIsNotFunction\n} from \"../error\";\nimport { Path } from \"../path\";\nimport {\n  _classCallCheck,\n  _createClass,\n  _inherits,\n  _possibleConstructorReturn,\n  _taggedTemplateLiteral\n} from \"../runtime\";\nimport { ES2015Map, ScopeType } from \"../type\";\nimport { Signal } from \"../signal\";\nimport { Scope } from \"../scope\";\nimport { Stack } from \"../stack\";\nimport { MODULE, THIS, REQUIRE, ARGUMENTS, NEW, ANONYMOUS } from \"../constant\";\n\nimport {\n  isCallExpression,\n  isClassMethod,\n  isClassProperty,\n  isIdentifier,\n  isImportDefaultSpecifier,\n  isImportSpecifier,\n  isMemberExpression,\n  isVariableDeclaration\n} from \"../packages/babel-types\";\n\nimport { defineFunctionLength, defineFunctionName } from \"../utils\";\n\nfunction overriteStack(err: Error, stack: Stack, node: types.Node): Error {\n  stack.push({\n    filename: ANONYMOUS,\n    stack: stack.currentStackName,\n    location: node.loc\n  });\n  err.stack = err.toString() + \"\\n\" + stack.raw;\n  return err;\n}\n\nexport const es2015: ES2015Map = {\n  ArrowFunctionExpression(path) {\n    const { node, scope } = path;\n    const func = (...args) => {\n      const newScope = scope.createChild(ScopeType.Function);\n\n      for (let i = 0; i < node.params.length; i++) {\n        const { name } = node.params[i] as types.Identifier;\n        newScope.const(name, args[i]);\n      }\n\n      const lastThis = scope.hasBinding(THIS);\n\n      newScope.const(THIS, lastThis ? lastThis.value : null);\n      newScope.const(ARGUMENTS, args);\n      const result = path.evaluate(path.createChild(node.body, newScope));\n\n      if (Signal.isReturn(result)) {\n        return result.value;\n      } else {\n        return result;\n      }\n    };\n\n    defineFunctionLength(func, node.params.length);\n    defineFunctionName(func, node.id ? node.id.name : \"\");\n\n    return func;\n  },\n  TemplateLiteral(path) {\n    const { node } = path;\n    return ([] as types.Node[])\n      .concat(node.expressions, node.quasis)\n      .sort((a, b) => a.start - b.start)\n      .map(element => path.evaluate(path.createChild(element)))\n      .join(\"\");\n  },\n  TemplateElement(path) {\n    return path.node.value.raw;\n  },\n  ForOfStatement(path) {\n    const { node, scope, ctx, stack } = path;\n    const labelName: string | void = ctx.labelName;\n    const entity = path.evaluate(path.createChild(node.right));\n    const SymbolConst: any = (() => {\n      const $var = scope.hasBinding(\"Symbol\");\n      return $var ? $var.value : undefined;\n    })();\n    // not support for of, it mean not support native for of\n    if (SymbolConst) {\n      if (!entity || !entity[SymbolConst.iterator]) {\n        // FIXME: how to get function name\n        // for (let value of get()){}\n        throw overriteStack(\n          ErrInvalidIterable((node.right as types.Identifier).name),\n          stack,\n          node.right\n        );\n      }\n    }\n\n    if (isVariableDeclaration(node.left)) {\n      /**\n       * for (let value in array){ // value should define in block scope\n       *\n       * }\n       */\n      const declarator: types.VariableDeclarator = node.left.declarations[0];\n      const varName = (declarator.id as types.Identifier).name;\n      for (const value of entity) {\n        const forOfScope = scope.createChild(ScopeType.ForOf);\n        forOfScope.invasive = true;\n        forOfScope.isolated = false;\n        forOfScope.declare(node.left.kind, varName, value); // define in current scope\n        const signal = path.evaluate(path.createChild(node.body, forOfScope));\n        if (Signal.isBreak(signal)) {\n          if (!signal.value) {\n            break;\n          }\n          if (signal.value === labelName) {\n            break;\n          }\n          return signal;\n        } else if (Signal.isContinue(signal)) {\n          if (!signal.value) {\n            continue;\n          }\n          if (signal.value === labelName) {\n            continue;\n          }\n          return signal;\n        } else if (Signal.isReturn(signal)) {\n          return signal;\n        }\n      }\n    } else if (isIdentifier(node.left)) {\n      /**\n       * for (value in array){  // value should define in parent scope\n       *\n       * }\n       */\n      const varName = node.left.name;\n      for (const value of entity) {\n        const forOfScope = scope.createChild(ScopeType.ForOf);\n        forOfScope.invasive = true;\n        scope.var(varName, value); // define in parent scope\n        const signal = path.evaluate(path.createChild(node.body, forOfScope));\n        if (Signal.isBreak(signal)) {\n          if (!signal.value) {\n            break;\n          }\n          if (signal.value === labelName) {\n            break;\n          }\n          return signal;\n        } else if (Signal.isContinue(signal)) {\n          if (!signal.value) {\n            continue;\n          }\n          if (signal.value === labelName) {\n            continue;\n          }\n          return signal;\n        } else if (Signal.isReturn(signal)) {\n          return signal;\n        }\n      }\n    }\n  },\n  ClassDeclaration(path) {\n    const ClassConstructor = path.evaluate(\n      path.createChild(path.node.body, path.scope.createChild(ScopeType.Class))\n    );\n\n    // support class decorators\n    const classDecorators = (path.node.decorators || [])\n      .map(node => path.evaluate(path.createChild(node)))\n      .reverse(); // revers decorators\n\n    // TODO: support class property decorator\n    // support class method decorators\n    // const propertyDecorators = path.node.body.body.filter(\n    //   node => node.decorators && node.decorators.length\n    // );\n\n    for (const decorator of classDecorators) {\n      decorator(ClassConstructor);\n    }\n\n    path.scope.const(path.node.id.name, ClassConstructor);\n  },\n  ClassBody(path) {\n    const { node, scope, stack } = path;\n    const constructor: types.ClassMethod | void = node.body.find(\n      n => isClassMethod(n) && n.kind === \"constructor\"\n    ) as types.ClassMethod | void;\n    const methods: types.ClassMethod[] = node.body.filter(\n      n => isClassMethod(n) && n.kind !== \"constructor\"\n    ) as types.ClassMethod[];\n    const properties: types.ClassProperty[] = node.body.filter(n =>\n      isClassProperty(n)\n    ) as types.ClassProperty[];\n\n    const parentNode = (path.parent as Path<types.ClassDeclaration>).node;\n\n    const Class = (SuperClass => {\n      if (SuperClass) {\n        _inherits(ClassConstructor, SuperClass);\n      }\n\n      function ClassConstructor(...args) {\n        stack.enter(parentNode.id.name + \".constructor\");\n        _classCallCheck(this, ClassConstructor);\n        const classScope = scope.createChild(ScopeType.Constructor);\n\n        // define class property\n        properties.forEach(p => {\n          this[p.key.name] = path.evaluate(\n            path.createChild(p.value, classScope)\n          );\n        });\n\n        if (constructor) {\n          // defined the params\n          constructor.params.forEach((param: types.LVal, i) => {\n            classScope.const((param as types.Identifier).name, args[i]);\n          });\n\n          if (!SuperClass) {\n            classScope.const(THIS, this);\n          }\n\n          classScope.const(NEW, {\n            target: ClassConstructor\n          });\n\n          for (const n of constructor.body.body) {\n            path.evaluate(\n              path.createChild(n, classScope, {\n                SuperClass,\n                ClassConstructor,\n                ClassConstructorArguments: args,\n                ClassEntity: this,\n                classScope\n              })\n            );\n          }\n        } else {\n          classScope.const(THIS, this);\n          // apply super if constructor not exist\n          _possibleConstructorReturn(\n            this,\n            (\n              (ClassConstructor as any).__proto__ ||\n              Object.getPrototypeOf(ClassConstructor)\n            ).apply(this, args)\n          );\n        }\n\n        if (!classScope.hasOwnBinding(THIS)) {\n          throw overriteStack(ErrNoSuper(), path.stack, node);\n        }\n\n        stack.leave();\n\n        return this;\n      }\n\n      // define class name and length\n      defineFunctionLength(\n        ClassConstructor,\n        constructor ? constructor.params.length : 0\n      );\n      defineFunctionName(ClassConstructor, parentNode.id.name);\n\n      const classMethods = methods\n        .map((method: types.ClassMethod) => {\n          const methodName: string = method.id\n            ? method.id.name\n            : method.computed\n              ? path.evaluate(path.createChild(method.key))\n              : (method.key as types.Identifier).name;\n          const methodScope = scope.createChild(ScopeType.Function);\n          const func = function(...args) {\n            stack.enter(parentNode.id.name + \".\" + methodName);\n            methodScope.const(THIS, this);\n            methodScope.const(NEW, { target: undefined });\n\n            // defined the params\n            method.params.forEach((p: types.LVal, i) => {\n              if (isIdentifier(p)) {\n                methodScope.const(p.name, args[i]);\n              }\n            });\n\n            const result = path.evaluate(\n              path.createChild(method.body, methodScope, {\n                SuperClass,\n                ClassConstructor,\n                ClassMethodArguments: args,\n                ClassEntity: this\n              })\n            );\n\n            stack.leave();\n\n            if (Signal.isReturn(result)) {\n              return result.value;\n            }\n          };\n\n          defineFunctionLength(func, method.params.length);\n          defineFunctionName(func, methodName);\n\n          return {\n            key: (method.key as any).name,\n            [method.kind === \"method\" ? \"value\" : method.kind]: func\n          };\n        })\n        .concat([{ key: \"constructor\", value: ClassConstructor }]);\n      // define class methods\n      _createClass(ClassConstructor, classMethods);\n\n      return ClassConstructor;\n    })(\n      parentNode.superClass\n        ? (() => {\n            const $var = scope.hasBinding((parentNode.superClass as any).name);\n            return $var ? $var.value : null;\n          })()\n        : null\n    );\n\n    return Class;\n  },\n  ClassMethod(path) {\n    return path.evaluate(path.createChild(path.node.body));\n  },\n  // refactor class\n  ClassExpression(path) {\n    //\n  },\n  Super(path) {\n    const { ctx } = path;\n    const { SuperClass, ClassConstructor, ClassEntity } = ctx;\n    const classScope: Scope = ctx.classScope;\n    const ClassBodyPath = path.findParent(\"ClassBody\");\n    // make sure it include in ClassDeclaration\n    if (!ClassBodyPath) {\n      throw new Error(\"super() only can use in ClassDeclaration\");\n    }\n    const parentPath = path.parent;\n    if (parentPath) {\n      // super()\n      if (isCallExpression(parentPath.node)) {\n        if (classScope && !classScope.hasOwnBinding(THIS)) {\n          classScope.const(THIS, ClassEntity);\n        }\n        return function inherits(...args) {\n          _possibleConstructorReturn(\n            ClassEntity,\n            (\n              (ClassConstructor as any).__proto__ ||\n              Object.getPrototypeOf(ClassConstructor)\n            ).apply(ClassEntity, args)\n          );\n        }.bind(ClassEntity);\n      } else if (isMemberExpression(parentPath.node)) {\n        // super.eat()\n        // then return the superclass prototype\n        return SuperClass.prototype;\n      }\n    }\n  },\n  SpreadElement(path) {\n    return path.evaluate(path.createChild(path.node.argument));\n  },\n  ImportDeclaration(path) {\n    const { node, scope, stack } = path;\n    let defaultImport: string = \"\"; // default import object\n    const otherImport: string[] = []; // import property\n    const moduleName: string = path.evaluate(path.createChild(node.source));\n    node.specifiers.forEach(n => {\n      if (isImportDefaultSpecifier(n)) {\n        // defaultImport = visitors.ImportDefaultSpecifier(path.createChild(n));\n        defaultImport = path.evaluate(path.createChild(n));\n      } else if (isImportSpecifier(n)) {\n        otherImport.push(path.evaluate(path.createChild(n)));\n        // otherImport.push(visitors.ImportSpecifier(path.createChild(n)));\n      } else {\n        throw n;\n      }\n    });\n\n    const requireVar = scope.hasBinding(REQUIRE);\n\n    if (requireVar === undefined) {\n      throw overriteStack(ErrNotDefined(REQUIRE), stack, node);\n    }\n\n    const requireFunc = requireVar.value;\n\n    if (!isFunction(requireFunc)) {\n      throw overriteStack(ErrIsNotFunction(REQUIRE), stack, node);\n    }\n\n    const targetModule: any = requireFunc(moduleName) || {};\n\n    if (defaultImport) {\n      scope.const(\n        defaultImport,\n        targetModule.default ? targetModule.default : targetModule\n      );\n    }\n\n    for (const varName of otherImport) {\n      scope.const(varName, targetModule[varName]);\n    }\n  },\n  ExportDefaultDeclaration(path) {\n    const { node, scope } = path;\n    const moduleVar = scope.hasBinding(MODULE);\n    if (moduleVar) {\n      const moduleObject = moduleVar.value;\n      moduleObject.exports = {\n        ...moduleObject.exports,\n        ...path.evaluate(path.createChild(node.declaration))\n      };\n    }\n  },\n  ExportNamedDeclaration(path) {\n    const { node } = path;\n    node.specifiers.forEach(n => path.evaluate(path.createChild(n)));\n  },\n  AssignmentPattern(path) {\n    const { node, scope, ctx } = path;\n    const { value } = ctx;\n    scope.const(\n      node.left.name,\n      value === undefined ? path.evaluate(path.createChild(node.right)) : value\n    );\n  },\n  RestElement(path) {\n    const { node, scope, ctx } = path;\n    const { value } = ctx;\n    scope.const((node.argument as types.Identifier).name, value);\n  },\n  YieldExpression(path) {\n    const { next } = path.ctx;\n    next(path.evaluate(path.createChild(path.node.argument))); // call next\n  },\n  TaggedTemplateExpression(path) {\n    const str = path.node.quasi.quasis.map(v => v.value.cooked);\n    const raw = path.node.quasi.quasis.map(v => v.value.raw);\n    const templateObject = _taggedTemplateLiteral(str, raw);\n    const func = path.evaluate(path.createChild(path.node.tag));\n    const expressionResultList =\n      path.node.quasi.expressions.map(n =>\n        path.evaluate(path.createChild(n))\n      ) || [];\n    return func(templateObject, ...expressionResultList);\n  },\n  MetaProperty(path) {\n    const obj = path.evaluate(path.createChild(path.node.meta));\n    return obj[path.node.property.name];\n  }\n};\n","import * as es5 from \"./es5\";\nimport { ES2016Map } from \"../type\";\n\nconst BinaryExpressionOperatorEvaluateMap = {\n  ...es5.BinaryExpressionOperatorEvaluateMap,\n  \"**\": (a, b) => Math.pow(a, b)\n};\n\nexport const es2016: ES2016Map = {\n  BinaryExpression(path) {\n    const { node } = path;\n    return BinaryExpressionOperatorEvaluateMap[node.operator](\n      path.evaluate(path.createChild(node.left)),\n      path.evaluate(path.createChild(node.right))\n    );\n  }\n};\n","import { ES2017Map } from \"../type\";\n\nexport const es2017: ES2017Map = {\n  AwaitExpression(path) {\n    const { next } = path.ctx;\n    next(path.evaluate(path.createChild(path.node.argument))); // call next\n  }\n};\n","import { ExperimentalMap, ScopeType } from \"../type\";\nimport { MODULE } from \"../constant\";\n\nexport const experimental: ExperimentalMap = {\n  ImportSpecifier(path) {\n    return path.node.local.name;\n  },\n  ImportDefaultSpecifier(path) {\n    return path.node.local.name;\n  },\n  ExportSpecifier(path) {\n    const { node, scope } = path;\n    const moduleVar = scope.hasBinding(MODULE);\n    if (moduleVar) {\n      const moduleObject = moduleVar.value;\n      moduleObject.exports[node.local.name] = path.evaluate(\n        path.createChild(node.local)\n      );\n    }\n  },\n  SpreadProperty(path) {\n    const { node, ctx } = path;\n    const { object } = ctx;\n    Object.assign(object, path.evaluate(path.createChild(node.argument)));\n  },\n  DoExpression(path) {\n    const newScope = path.scope.createChild(ScopeType.Do);\n    newScope.invasive = true;\n    return path.evaluate(path.createChild(path.node.body, newScope));\n  },\n  Decorator(path) {\n    return path.evaluate(path.createChild(path.node.expression));\n  }\n};\n","import { Node } from \"babel-types\";\nimport { Scope } from \"./scope\";\nimport { ScopeType, EvaluateFunc, presetMap } from \"./type\";\nimport { Stack } from \"./stack\";\n\nexport interface ICtx {\n  [k: string]: any;\n}\n\nexport class Path<T extends Node> {\n  public evaluate!: EvaluateFunc;\n  public preset!: presetMap;\n  constructor(\n    public node: T,\n    public parent: Path<Node> | null,\n    public scope: Scope,\n    public ctx: ICtx,\n    public stack: Stack\n  ) {}\n  /**\n   * Generate child scope\n   * @template Child\n   * @param {Child} node\n   * @param {(ScopeType | Scope)} [scope]\n   * @param {ICtx} [ctx={}]\n   * @returns {Path<Child>}\n   * @memberof Path\n   */\n  public createChild<Child extends Node>(\n    node: Child,\n    scope?: ScopeType | Scope,\n    ctx?: ICtx\n  ): Path<Child> {\n    const path = new Path(\n      node,\n      this,\n      scope\n        ? typeof scope === \"number\"\n          ? this.scope.createChild(scope)\n          : scope\n        : this.scope,\n      { ...this.ctx, ...ctx },\n      this.stack\n    );\n    path.evaluate = this.evaluate;\n    path.preset = this.preset;\n    return path;\n  }\n  /**\n   * Find scope scope with type\n   * @param {string} type\n   * @returns {(Path<Node> | null)}\n   * @memberof Path\n   */\n  public findParent(type: string): Path<Node> | null {\n    return this.parent\n      ? this.parent.node.type === type\n        ? this.parent\n        : this.parent.findParent(type)\n      : null;\n  }\n}\n","import { Context } from \"./context\";\nimport { ErrDuplicateDeclard } from \"./error\";\nimport { Kind, KindType, ScopeType, isolatedScopeMap } from \"./type\";\nimport { Var } from \"./var\";\n\nexport class Scope {\n  // the scope have invasive property\n  // if the scope is block scope.\n  // it can define variables in parent scope via `var`\n  // for example\n  /**\n   * var a = 2;\n   *\n   * for(var i=0;i<a;i++){\n   *   var b = i;\n   * }\n   *\n   * // in here, b is not defined in the top scope.\n   * // but it defined in for loop\n   * // mark invasive = true. then var keyword can defined variables in parent scope\n   * console.log(b); // 1\n   *\n   */\n  public invasive: boolean = false;\n\n  /**\n   * The level of scope.\n   * The top scope's level is 0.\n   * every child scope will increase 1\n   */\n  public level: number = 0;\n\n  // scope context\n  public context: Context;\n\n  // isolated scope.\n  // if isolated = true\n  // it will create a new scope in blockStatement\n  public isolated: boolean = true;\n\n  // the scope fork from witch scope\n  public origin: Scope | null = null;\n\n  // scope var\n  private content: { [key: string]: Var<any> } = {};\n\n  constructor(public readonly type: ScopeType, public parent: Scope | null) {\n    this.context = new Context();\n  }\n\n  get length(): number {\n    return Object.keys(this.content).length;\n  }\n\n  get raw(): { [key: string]: any } {\n    const raw = {};\n    for (const attr in this.content) {\n      if (this.content.hasOwnProperty(attr)) {\n        raw[attr] = this.content[attr].value;\n      }\n    }\n    return raw;\n  }\n\n  /**\n   * Set context of a scope\n   * @param {Context} context\n   * @memberof Scope\n   */\n  public setContext(context: Context) {\n    this.context = context;\n    for (const name in context) {\n      if (context.hasOwnProperty(name)) {\n        // here should use $var\n        this.var(name, context[name]);\n      }\n    }\n  }\n\n  /**\n   * check the scope have binding a var\n   * @param {string} varName\n   * @returns {(Var<any> | void)}\n   * @memberof Scope\n   */\n  public hasBinding(varName: string): Var<any> | void {\n    if (this.content.hasOwnProperty(varName)) {\n      return this.content[varName];\n    } else if (this.parent) {\n      return this.parent.hasBinding(varName);\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * check scope have binding a var in current scope\n   * @param {string} varName\n   * @returns {(Var<any> | void)}\n   * @memberof Scope\n   */\n  public hasOwnBinding(varName: string): Var<any> | void {\n    if (this.content.hasOwnProperty(varName)) {\n      return this.content[varName];\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * get root scope\n   * @readonly\n   * @type {Scope}\n   * @memberof Scope\n   */\n  get global(): Scope {\n    if (this.parent) {\n      return this.parent.global;\n    } else {\n      return this;\n    }\n  }\n\n  /**\n   * Declaring variables with let\n   * @param {string} varName\n   * @param {*} value\n   * @returns {boolean}\n   * @memberof Scope\n   */\n  public let(varName: string, value: any): boolean {\n    if (!this.content.hasOwnProperty(varName)) {\n      this.content[varName] = new Var(Kind.Let, varName, value, this);\n      return true;\n    } else {\n      throw ErrDuplicateDeclard(varName);\n    }\n  }\n\n  /**\n   * Declaring variables with const\n   * @param {string} varName\n   * @param {*} value\n   * @returns {boolean}\n   * @memberof Scope\n   */\n  public const(varName: string, value: any): boolean {\n    if (!this.content.hasOwnProperty(varName)) {\n      this.content[varName] = new Var(Kind.Const, varName, value, this);\n      return true;\n    } else {\n      throw ErrDuplicateDeclard(varName);\n    }\n  }\n\n  /**\n   * Declaring variables with var\n   * @param {string} varName\n   * @param {*} value\n   * @returns {boolean}\n   * @memberof Scope\n   */\n  public var(varName: string, value: any): boolean {\n    // tslint:disable-next-line\n    let targetScope: Scope = this;\n\n    // When to stop?\n    // 1. if the current scope is top-level scope\n    // 2. if the current scope type is one of types `function`, `constructor`\n    while (targetScope.parent !== null && !isolatedScopeMap[targetScope.type]) {\n      targetScope = targetScope.parent;\n    }\n\n    if (targetScope.content.hasOwnProperty(varName)) {\n      const $var = targetScope.content[varName];\n      if ($var.kind !== Kind.Var) {\n        // only cover var with var, not const and let\n        throw ErrDuplicateDeclard(varName);\n      } else {\n        if (targetScope.level === 0 && targetScope.context[varName]) {\n          // top level context can not be cover\n          // here we do nothing\n        } else {\n          // new var cover the old var\n          targetScope.content[varName] = new Var(\n            Kind.Var,\n            varName,\n            value,\n            targetScope\n          );\n        }\n      }\n    } else {\n      // set the new var\n      targetScope.content[varName] = new Var(\n        Kind.Var,\n        varName,\n        value,\n        targetScope\n      );\n    }\n    return true;\n  }\n\n  /**\n   * Declaring variables\n   * @param {Kind} kind\n   * @param {string} rawName\n   * @param {*} value\n   * @returns {boolean}\n   * @memberof Scope\n   */\n  public declare(kind: Kind | KindType, rawName: string, value: any): boolean {\n    return {\n      [Kind.Const]: () => this.const(rawName, value),\n      [Kind.Let]: () => this.let(rawName, value),\n      [Kind.Var]: () => this.var(rawName, value)\n    }[kind]();\n  }\n\n  /**\n   * Delete variables\n   * @param {string} varName\n   * @memberof Scope\n   */\n  public del(varName: string): boolean {\n    if (this.content.hasOwnProperty(varName)) {\n      delete this.content[varName];\n    }\n    return true;\n  }\n\n  /**\n   * Create a child scope\n   * @param {ScopeType} type\n   * @returns {Scope}\n   * @memberof Scope\n   */\n  public createChild(type: ScopeType): Scope {\n    const childScope = new Scope(type, this);\n    childScope.level = this.level + 1;\n    return childScope;\n  }\n\n  /**\n   * Fork a scope\n   * @param {ScopeType} [type]\n   * @returns {Scope}\n   * @memberof Scope\n   */\n  public fork(type?: ScopeType): Scope {\n    // forks a new scope\n    const siblingScope = new Scope(type || this.type, null);\n\n    // copy the properties\n    siblingScope.invasive = this.invasive;\n    siblingScope.level = this.level;\n    siblingScope.context = this.context;\n    siblingScope.parent = this.parent;\n    siblingScope.origin = this;\n\n    // copy the vars\n    for (const varName in this.content) {\n      if (this.content.hasOwnProperty(varName)) {\n        const $var = this.content[varName];\n        siblingScope.declare($var.kind, $var.name, $var.value);\n      }\n    }\n    return siblingScope;\n  }\n\n  /**\n   * Locate a scope with var\n   * @param {string} varName\n   * @returns {(Scope | null)}\n   * @memberof Scope\n   */\n  public locate(varName: string): Scope | void {\n    if (this.hasOwnBinding(varName)) {\n      return this;\n    } else {\n      if (this.parent) {\n        return this.parent.locate.call(this.parent, varName);\n      } else {\n        return undefined;\n      }\n    }\n  }\n}\n","import { Scope } from \"./scope\";\nimport { Kind, KindType } from \"./type\";\n\nexport interface IVar {\n  kind: Kind | KindType;\n  readonly value: any;\n  set(value: any): void;\n}\n\nexport class Var<T> implements IVar {\n  constructor(\n    public kind: Kind | KindType,\n    public name: string,\n    private val: T,\n    public scope: Scope\n  ) {}\n  public get value(): T {\n    return this.val;\n  }\n  public set(value: any): void {\n    this.val = value;\n  }\n}\n","export interface IPoint {\n  line: number;\n  column: number;\n}\n\nexport interface ILocation {\n  start: IPoint;\n  end: IPoint;\n}\n\nexport interface IPen {\n  stack: string;\n  filename: string;\n  location: ILocation;\n}\n\nexport class Stack {\n  private stackList: string[] = [];\n  private items: IPen[] = [];\n  constructor(private limitSize: number = Error.stackTraceLimit || 10) {}\n  public enter(stackName: string) {\n    this.stackList.push(stackName);\n  }\n  public leave() {\n    this.stackList.pop();\n    this.items.pop();\n  }\n  public push(item: IPen) {\n    if (this.size > this.limitSize) {\n      this.items.shift();\n    }\n    this.items.push(item);\n  }\n\n  public get currentStackName(): string {\n    return this.stackList.length\n      ? this.stackList[this.stackList.length - 1]\n      : \"\";\n  }\n\n  public peek(): IPen {\n    return this.items[this.items.length - 1];\n  }\n\n  public isEmpty() {\n    return this.items.length === 0;\n  }\n\n  public clear() {\n    this.items = [];\n  }\n\n  public get raw(): string {\n    return this.items\n      .reverse()\n      .map(v => {\n        const meta = `<${v.filename}>:${v.location.start.line}:${\n          v.location.start.column + 1 // while + 1 ? because the stack track diffrent with babylon parser\n        }`;\n        return v.stack ? `at ${v.stack} (${meta})` : `at ${meta}`;\n      })\n      .map(v => \"    \" + v)\n      .join(\"\\n\");\n  }\n\n  get size() {\n    return this.items.length;\n  }\n}\n"],"sourceRoot":""}